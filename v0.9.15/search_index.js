var documenterSearchIndex = {"docs":
[{"location":"internal_interface/#Internal-Interfaces","page":"Internal Interfaces","title":"Internal Interfaces","text":"","category":"section"},{"location":"internal_interface/#Parser-Interface","page":"Internal Interfaces","title":"Parser Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Parsers.find_end_of_header\nHTTP.Parsers.find_end_of_chunk_size\nHTTP.Parsers.find_end_of_trailer\nHTTP.Parsers.parse_status_line!\nHTTP.Parsers.parse_request_line!\nHTTP.Parsers.parse_header_field\nHTTP.Parsers.parse_chunk_size","category":"page"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_header","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_header","text":"find_end_of_header(bytes) -> length or 0\n\nFind length of header delimited by \\r\\n\\r\\n or \\n\\n.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_chunk_size","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_chunk_size","text":"Find \\n after chunk size in bytes.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_trailer","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_trailer","text":"find_end_of_trailer(bytes) -> length or 0\n\nFind length of trailer delimited by \\r\\n\\r\\n (or starting with \\r\\n). RFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_status_line!","page":"Internal Interfaces","title":"HTTP.Parsers.parse_status_line!","text":"Parse HTTP response-line bytes and set the status and version fields of response. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_request_line!","page":"Internal Interfaces","title":"HTTP.Parsers.parse_request_line!","text":"Parse HTTP request-line bytes and set the method, target and version fields of request. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_header_field","page":"Internal Interfaces","title":"HTTP.Parsers.parse_header_field","text":"Parse HTTP header-field. Return Pair(field-name => field-value) and a SubString containing the remaining header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_chunk_size","page":"Internal Interfaces","title":"HTTP.Parsers.parse_chunk_size","text":"Parse HTTP chunk-size. Return number of bytes of chunk-data.\n\nchunk-size = 1*HEXDIG\n\nRFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Messages-Interface","page":"Internal Interfaces","title":"Messages Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Messages.iserror\nHTTP.Messages.isredirect\nHTTP.Messages.ischunked\nHTTP.Messages.issafe\nHTTP.Messages.isidempotent\nHTTP.Messages.header\nHTTP.Messages.hasheader\nHTTP.Messages.setheader\nHTTP.Messages.defaultheader!\nHTTP.Messages.appendheader\nHTTP.Messages.readheaders\nHTTP.MessageRequest.setuseragent!\nHTTP.Messages.readchunksize\nHTTP.Messages.headerscomplete(::HTTP.Messages.Response)\nHTTP.Messages.writestartline\nHTTP.Messages.writeheaders\nBase.write(::IO,::HTTP.Messages.Message)","category":"page"},{"location":"internal_interface/#HTTP.Messages.iserror","page":"Internal Interfaces","title":"HTTP.Messages.iserror","text":"iserror(::Response)\n\nDoes this Response have an error status?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.isredirect","page":"Internal Interfaces","title":"HTTP.Messages.isredirect","text":"isredirect(::Response)\n\nDoes this Response have a redirect status?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.ischunked","page":"Internal Interfaces","title":"HTTP.Messages.ischunked","text":"ischunked(::Message)\n\nDoes the Message have a \"Transfer-Encoding: chunked\" header?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.issafe","page":"Internal Interfaces","title":"HTTP.Messages.issafe","text":"issafe(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.isidempotent","page":"Internal Interfaces","title":"HTTP.Messages.isidempotent","text":"isidempotent(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.2\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.header","page":"Internal Interfaces","title":"HTTP.Messages.header","text":"header(::Message, key [, default=\"\"]) -> String\n\nGet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.hasheader","page":"Internal Interfaces","title":"HTTP.Messages.hasheader","text":"hasheader(::Message, key) -> Bool\n\nDoes header value for key exist (case-insensitive)?\n\n\n\n\n\nhasheader(::Message, key, value) -> Bool\n\nDoes header for key match value (both case-insensitive)?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.setheader","page":"Internal Interfaces","title":"HTTP.Messages.setheader","text":"setheader(::Message, key => value)\n\nSet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.defaultheader!","page":"Internal Interfaces","title":"HTTP.Messages.defaultheader!","text":"defaultheader!(::Message, key => value)\n\nSet header value in message for key if it is not already set.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.appendheader","page":"Internal Interfaces","title":"HTTP.Messages.appendheader","text":"appendheader(::Message, key => value)\n\nAppend a header value to message.headers.\n\nIf key is the same as the previous header, the value is appended to the value of the previous header with a comma delimiter\n\nSet-Cookie headers are not comma-combined because cookies often contain internal commas.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.readheaders","page":"Internal Interfaces","title":"HTTP.Messages.readheaders","text":"readheaders(::IO, ::Message)\n\nRead headers (and startline) from an IO stream into a Message struct. Throw EOFError if input is incomplete.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.MessageRequest.setuseragent!","page":"Internal Interfaces","title":"HTTP.MessageRequest.setuseragent!","text":"setuseragent!(x::Union{String, Nothing})\n\nSet the default User-Agent string to be used in each HTTP request. Can be manually overridden by passing an explicit User-Agent header. Setting nothing will prevent the default User-Agent header from being passed.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.readchunksize","page":"Internal Interfaces","title":"HTTP.Messages.readchunksize","text":"Read chunk-size from an IO stream. After the final zero size chunk, read trailers into a Message struct.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}","page":"Internal Interfaces","title":"HTTP.Messages.headerscomplete","text":"headerscomplete(::Message)\n\nHave the headers been read into this Message?\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.Messages.writestartline","page":"Internal Interfaces","title":"HTTP.Messages.writestartline","text":"writestartline(::IO, ::Message)\n\ne.g. \"GET /path HTTP/1.1\\r\\n\" or \"HTTP/1.1 200 OK\\r\\n\"\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.writeheaders","page":"Internal Interfaces","title":"HTTP.Messages.writeheaders","text":"writeheaders(::IO, ::Message)\n\nWrite Message start line and a line for each \"name: value\" pair and a trailing blank line.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Base.write-Tuple{IO, HTTP.Messages.Message}","page":"Internal Interfaces","title":"Base.write","text":"write(::IO, ::Message)\n\nWrite start line, headers and body of HTTP Message.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#IOExtras-Interface","page":"Internal Interfaces","title":"IOExtras Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.IOExtras\nHTTP.IOExtras.startwrite(::IO)\nHTTP.IOExtras.isioerror","category":"page"},{"location":"internal_interface/#HTTP.IOExtras","page":"Internal Interfaces","title":"HTTP.IOExtras","text":"IOExtras\n\nThis module defines extensions to the Base.IO interface to support:\n\nstartwrite, closewrite, startread and closeread for streams  with transactional semantics.\n\n\n\n\n\n","category":"module"},{"location":"internal_interface/#HTTP.IOExtras.isioerror","page":"Internal Interfaces","title":"HTTP.IOExtras.isioerror","text":"isioerror(exception)\n\nIs exception caused by a possibly recoverable IO error.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Streams-Interface","page":"Internal Interfaces","title":"Streams Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Streams.closebody\nHTTP.Streams.isaborted","category":"page"},{"location":"internal_interface/#HTTP.Streams.closebody","page":"Internal Interfaces","title":"HTTP.Streams.closebody","text":"closebody(::Stream)\n\nWrite the final 0 chunk if needed.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Streams.isaborted","page":"Internal Interfaces","title":"HTTP.Streams.isaborted","text":"isaborted(::Stream{Response})\n\nHas the server signaled that it does not wish to receive the message body?\n\n\"If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.\" RFC7230, 6.5\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Connection-Pooling-Interface","page":"Internal Interfaces","title":"Connection Pooling Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.ConnectionPool.Connection\nHTTP.ConnectionPool.Transaction\nHTTP.ConnectionPool.getconnection\nHTTP.ConnectionPool.POOL\nHTTP.IOExtras.startwrite(::HTTP.ConnectionPool.Transaction)\nHTTP.IOExtras.closewrite(::HTTP.ConnectionPool.Transaction)\nHTTP.IOExtras.startread(::HTTP.ConnectionPool.Transaction)\nHTTP.IOExtras.closeread(::HTTP.ConnectionPool.Transaction)","category":"page"},{"location":"internal_interface/#HTTP.ConnectionPool.Connection","page":"Internal Interfaces","title":"HTTP.ConnectionPool.Connection","text":"Connection{T <: IO}\n\nA TCPSocket or SSLContext connection to a HTTP host and port.\n\nFields:\n\nhost::String\nport::String, exactly as specified in the URI (i.e. may be empty).\npipeline_limit, number of requests to send before waiting for responses.\nidle_timeout, No. of seconds to maintain connection after last transaction.\npeerip, remote IP adress (used for debug/log messages).\npeerport, remote TCP port number (used for debug/log messages).\nlocalport, local TCP port number (used for debug messages).\nio::T, the TCPSocket or `SSLContext.\nclientconnection::Bool, whether the Connection was created from client code (as opposed to server code)\nbuffer::IOBuffer, left over bytes read from the connection after  the end of a response header (or chunksize). These bytes are usually  part of the response body.\nsequence, number of most recent Transaction.\nwritecount, number of Messages that have been written, protected by writelock\nwritelock, lock writecount and writebusy, and signal that writecount was incremented.\nwritebusy, whether a Transaction currently holds the Connection write lock, protected by writelock\nreadcount, number of Messages that have been read, protected by readlock\nreadlock, lock readcount and readbusy, and signal that readcount was incremented.\nreadbusy, whether a Transaction currently holds the Connection read lock, protectecd by readlock\ntimestamp, time data was last received.\n\n\n\n\n\n","category":"type"},{"location":"internal_interface/#HTTP.ConnectionPool.Transaction","page":"Internal Interfaces","title":"HTTP.ConnectionPool.Transaction","text":"Transaction\n\nA single pipelined HTTP Request/Response transaction.\n\nFields:\n\nc, the shared Connection used for this Transaction.\nsequence::Int, identifies this Transaction among the others that share c.\nwritebusy::Bool, whether this Transaction holds its parent Connection write lock, protected by c.writelock\nreadbusy::Bool, whether this Transaction holds its parent Connection read lock, protected by c.readlock\n\n\n\n\n\n","category":"type"},{"location":"internal_interface/#HTTP.ConnectionPool.getconnection","page":"Internal Interfaces","title":"HTTP.ConnectionPool.getconnection","text":"getconnection(type, host, port) -> Connection\n\nFind a reusable Connection in the pool, or create a new Connection if required.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.ConnectionPool.POOL","page":"Internal Interfaces","title":"HTTP.ConnectionPool.POOL","text":"POOL\n\nGlobal connection pool keeping track of active connections.\n\n\n\n\n\n","category":"constant"},{"location":"internal_interface/#HTTP.IOExtras.startwrite-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.startwrite","text":"startwrite(::Transaction)\n\nWait for prior pending writes to complete.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.closewrite-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.closewrite","text":"closewrite(::Transaction)\n\nSignal that an entire Request Message has been written to the Transaction.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.startread-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.startread","text":"startread(::Transaction)\n\nWait for prior pending reads to complete.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.closeread-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.closeread","text":"closeread(::Transaction)\n\nSignal that an entire Response Message has been read from the Transaction.\n\nIncrement readcount and wake up tasks waiting in startread.\n\n\n\n\n\n","category":"method"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using \"\"\" syntax","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples that may prove potentially useful for those using  HTTP.jl. The code for these examples can also be found on Github  in the docs/examples folder.","category":"page"},{"location":"examples/#Simple-Server","page":"Examples","title":"Simple Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a server with HTTP.jl. It handles creating, deleting,  updating, and retrieving Animals from a dictionary through 4 different routes","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\nend\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# \"service\" functions to actually do the work\nfunction createAnimal(req::HTTP.Request)\n    animal = JSON3.read(IOBuffer(HTTP.payload(req)), Animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    animal = ANIMALS[parse(Int, animalId)]\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = JSON3.read(IOBuffer(HTTP.payload(req)), Animal)\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, parse(Int, animal.id))\n    return HTTP.Response(200)\nend\n\n# define REST endpoints to dispatch to \"service\" functions\nconst ANIMAL_ROUTER = HTTP.Router()\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/animals\", createAnimal)\n# note the use of `*` to capture the path segment \"variable\" animal id\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"PUT\", \"/api/zoo/v1/animals\", updateAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/animals/*\", deleteAnimal)\n\nHTTP.serve(ANIMAL_ROUTER, ip\"127.0.0.1\", 8080)\n\n","category":"page"},{"location":"examples/#Cors-Server","page":"Examples","title":"Cors Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Server example that takes after the simple server, however, handles dealing with CORS preflight headers when dealing with more than just a simple request","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\nend\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# CORS headers that show what kinds of complex requests are allowed to API\nheaders = [\n    \"Access-Control-Allow-Origin\" => \"*\",\n    \"Access-Control-Allow-Headers\" => \"*\",\n    \"Access-Control-Allow-Methods\" => \"POST, GET, OPTIONS\"\n]\n\n#= \nJSONHandler minimizes code by automatically converting the request body\nto JSON to pass to the other service functions automatically. JSONHandler\nrecieves the body of the response from the other service funtions and sends\nback a success response code\n=#\nfunction JSONHandler(req::HTTP.Request)\n    # first check if there's any request body\n    body = IOBuffer(HTTP.payload(req))\n    if eof(body)\n        # no request body\n        response_body = handle(ANIMAL_ROUTER, req)\n    else\n        # there's a body, so pass it on to the handler we dispatch to\n        response_body = handle(ANIMAL_ROUTER, req, JSON3.read(body, Animal))\n    end\n    return HTTP.Response(200, JSON3.write(response_body))\nend\n\n#= CorsHandler: handles preflight request with the OPTIONS flag\nIf a request was recieved with the correct headers, then a response will be \nsent back with a 200 code, if the correct headers were not specified in the request,\nthen a CORS error will be recieved on the client side\n\nSince each request passes throught the CORS Handler, then if the request is \nnot a preflight request, it will simply go to the JSONHandler to be passed to the\ncorrect service function =#\nfunction CorsHandler(req)\n    if HTTP.hasheader(req, \"OPTIONS\")\n        return HTTP.Response(200, headers = headers)\n    else \n        return JSONHandler(req)\n    end\n\n\n# **simplified** \"service\" functions\nfunction createAnimal(req::HTTP.Request, animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    return ANIMALS[animalId]\nend\n\nfunction updateAnimal(req::HTTP.Request, animal)\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, animal.id)\n    return \"\"\nend\n\n# add an additional endpoint for user creation\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users\", createUser)\n# modify service endpoints to have user pass UUID in\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/users/*/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/users/*/animals/*\", deleteAnimal)\n\n\nHTTP.serve(CorsHandler, ip\"127.0.0.1\", 8080)\n","category":"page"},{"location":"examples/#Server-Sent-Events","page":"Examples","title":"Server Sent Events","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server that implements server-sent events, loosely following this tutorial.","category":"page"},{"location":"examples/#Example-client-code-(JS):","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Server-sent events demo</title>\n</head>\n<body>\n    <h3>Fetched items:</h3>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    const evtSource = new EventSource(\"http://127.0.0.1:8080/api/events\")\n    evtSource.onmessage = async function (event) {\n        const newElement = document.createElement(\"li\");\n        const eventList = document.getElementById(\"list\");\n        if (parseFloat(event.data) > 0.5) {\n            const r = await fetch(\"http://127.0.0.1:8080/api/getItems\")\n            if (r.ok) {\n                const body = await r.json()\n                newElement.textContent = body;\n                eventList.appendChild(newElement);\n            }\n        }\n    }\n    evtSource.addEventListener(\"ping\", function(event) {\n        console.log('ping:', event.data)\n    });\n</script>\n</html>","category":"page"},{"location":"examples/#Example-client-code-(Julia)","page":"Examples","title":"Example client code (Julia)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nHTTP.open(\"GET\", \"http://127.0.0.1:8080/api/events\") do io\n    while !eof(io)\n        println(String(readavailable(io)))\n    end\nend","category":"page"},{"location":"examples/#Server-code:","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nconst ROUTER = HTTP.Router()\n\nfunction getItems(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\"\n    ]\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    return HTTP.Response(200, headers; body = JSON.json(rand(2)))\nend\n\nfunction events(stream::HTTP.Stream)\n    HTTP.setheader(stream, \"Access-Control-Allow-Origin\" => \"*\")\n    HTTP.setheader(stream, \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\")\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n\n    if HTTP.method(stream.message) == \"OPTIONS\"\n        return nothing\n    end\n\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n    HTTP.setheader(stream, \"Cache-Control\" => \"no-cache\")\n    while true\n        write(stream, \"event: ping\\ndata: $(round(Int, time()))\\n\\n\")\n        if rand(Bool)\n            write(stream, \"data: $(rand())\\n\\n\")\n        end\n        sleep(1)\n    end\n    return nothing\nend\n\nHTTP.@register(ROUTER, \"GET\", \"/api/getItems\", getItems)\nHTTP.@register(ROUTER, \"/api/events\", HTTP.Handlers.StreamHandlerFunction(events))\n\nHTTP.serve(ROUTER, \"127.0.0.1\", 8080)\n","category":"page"},{"location":"examples/#Session","page":"Examples","title":"Session","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a persistent session and logging into a web form. HTTP.jl does not have a distinct session object like requests.session() or rvest::html_session() but rather uses the cookies flag along with standard functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n#dummy site, any credentials work\nurl = \"http://quotes.toscrape.com/login\"\nsession = HTTP.get(url; cookies = true)\n\ncredentials = Dict(\n    \"Username\" => \"username\",\n    \"Password\" => \"password\")\n\nresponse = HTTP.post(url, credentials)\n","category":"page"},{"location":"examples/#Squaring-Server-Client","page":"Examples","title":"Squaring Server Client","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server in Julia and client code in JS.","category":"page"},{"location":"examples/#Example-client-code-(JS):-2","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Squaring numbers</title>\n</head>\n<body>\n    <input id=\"number\" placeholder=\"Input a number\" type=\"number\">\n    <button id=\"submit\">Square</button>\n    <h4>Outputs</h4>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    document.getElementById('submit').addEventListener('click', async function (event) {\n        const list = document.getElementById('list');\n        try {\n            const r = await fetch('http://127.0.0.1:8080/api/square', {\n                method: 'POST',\n                body: document.getElementById('number').value\n            });\n\n            if (r.ok) {\n                const body = await r.text()\n                const newElement = document.createElement('li');\n                newElement.textContent = body;\n                list.insertBefore(newElement, list.firstChild);\n            } else {\n                console.error(r)\n            };\n        } catch (err) {\n            console.error(err)\n        }\n    })\n</script>\n</html>","category":"page"},{"location":"examples/#Server-code:-2","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nconst ROUTER = HTTP.Router()\n\nfunction square(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"POST, OPTIONS\"\n    ]\n    # handle CORS requests\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    body = parse(Float64, String(HTTP.body(req)))\n    square = body^2\n    HTTP.Response(200, headers; body = string(square))\nend\n\nHTTP.@register(ROUTER, \"POST\", \"/api/square\", square)\n\nHTTP.serve(ROUTER, \"127.0.0.1\", 8080)\n","category":"page"},{"location":"examples/#Readme-Examples","page":"Examples","title":"Readme Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"#CLIENT\n\n#HTTP.request sends a HTTP Request Message and returns a Response Message.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\"; verbose=3)\nprintln(r.status) \nprintln(String(r.body)) \n\n#HTTP.open sends a HTTP Request Message and opens an IO stream from which the Response can be read.\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n#SERVERS\n\n#Using HTTP.Servers.listen:\n#The server will start listening on 127.0.0.1:8081 by default.\n\nusing HTTP\n\nHTTP.listen() do http::HTTP.Stream\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    HTTP.startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\n#Using HTTP.Handlers.serve:\n\nusing HTTP\n\nHTTP.serve() do request::HTTP.Request\n   @show request\n   @show request.method\n   @show HTTP.header(request, \"Content-Type\")\n   @show HTTP.payload(request)\n   try\n       return HTTP.Response(\"Hello\")\n   catch e\n       return HTTP.Response(404, \"Error: $e\")\n   end\nend\n\n#WebSocket Examples\n@async HTTP.WebSockets.listen(\"127.0.0.1\", UInt16(8081)) do ws\n    while !eof(ws)\n        data = readavailable(ws)\n        write(ws, data)\n    end\nend\n\nHTTP.WebSockets.open(\"ws://127.0.0.1:8081\") do ws\n    write(ws, \"Hello\")\n    x = readavailable(ws)\n    @show x\n    println(String(x))\nend;\nx = UInt8[0x48, 0x65, 0x6c, 0x6c, 0x6f]\n#Output: Hello\n\n#=Custom HTTP Layer Examples\nNotes:\nThere is no enforcement of a \"well-defined\" stack, you can insert a layer anywhere in the stack even if it logically does not make sense\nWhen creating a custom layer, you need to create a request(), see below for an example\nCustom layers is only implemented with the \"low-level\" request() calls, not the \"convenience\" functions such as HTTP.get(), HTTP.put(), etc.\nmodule TestRequest=#\n        import HTTP: Layer, request, Response\n\n        abstract type TestLayer{Next <: Layer} <: Layer{Next} end\n        export TestLayer, request\n\n        function request(::Type{TestLayer{Next}}, io::IO, req, body; kw...)::Response where Next\n                println(\"Insert your custom layer logic here!\")\n                return request(Next, io, req, body; kw...)\n        end\nend\n\nusing HTTP\nusing ..TestRequest\n\ncustom_stack = insert(stack(), StreamLayer, TestLayer)\n\nresult = request(custom_stack, \"GET\", \"https://httpbin.org/ip\")\n\n# Insert your custom layer logic here!\n\n# HTTP.Messages.Response:\n# \"\"\"\n# HTTP/1.1 200 OK\n# Access-Control-Allow-Credentials: true\n# Access-Control-Allow-Origin: *\n# Content-Type: application/json\n# Date: Fri, 30 Aug 2019 14:13:17 GMT\n# Referrer-Policy: no-referrer-when-downgrade\n# Server: nginx\n# X-Content-Type-Options: nosniff\n# X-Frame-Options: DENY\n# X-XSS-Protection: 1; mode=block\n# Content-Length: 45\n# Connection: keep-alive\n\n# {\n#   \"origin\": \"--Redacted--\"\n# }\n# \"\"\"\n\n ","category":"page"},{"location":"internal_architecture/#Internal-Architecture","page":"Internal Architecture","title":"Internal Architecture","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Layer\nHTTP.stack","category":"page"},{"location":"internal_architecture/#HTTP.Layers.Layer","page":"Internal Architecture","title":"HTTP.Layers.Layer","text":"Request Execution Stack\n\nThe Request Execution Stack is separated into composable layers.\n\nEach layer is defined by a nested type Layer{Next} where the Next parameter defines the next layer in the stack. The request method for each layer takes a Layer{Next} type as its first argument and dispatches the request to the next layer using request(Next, ...).\n\nThe example below defines three layers and three stacks each with a different combination of layers.\n\nabstract type Layer end\nabstract type Layer1{Next <: Layer} <: Layer end\nabstract type Layer2{Next <: Layer} <: Layer end\nabstract type Layer3 <: Layer end\n\nrequest(::Type{Layer1{Next}}, data) where Next = \"L1\", request(Next, data)\nrequest(::Type{Layer2{Next}}, data) where Next = \"L2\", request(Next, data)\nrequest(::Type{Layer3}, data) = \"L3\", data\n\nconst stack1 = Layer1{Layer2{Layer3}}\nconst stack2 = Layer2{Layer1{Layer3}}\nconst stack3 = Layer1{Layer3}\n\njulia> request(stack1, \"foo\")\n(\"L1\", (\"L2\", (\"L3\", \"foo\")))\n\njulia> request(stack2, \"bar\")\n(\"L2\", (\"L1\", (\"L3\", \"bar\")))\n\njulia> request(stack3, \"boo\")\n(\"L1\", (\"L3\", \"boo\"))\n\nThis stack definition pattern gives the user flexibility in how layers are combined but still allows Julia to do whole-stack compile time optimisations.\n\ne.g. the request(stack1, \"foo\") call above is optimised down to a single function:\n\njulia> code_typed(request, (Type{stack1}, String))[1].first\nCodeInfo(:(begin\n    return (Core.tuple)(\"L1\", (Core.tuple)(\"L2\", (Core.tuple)(\"L3\", data)))\nend))\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.stack","page":"Internal Architecture","title":"HTTP.stack","text":"The stack() function returns the default HTTP Layer-stack type. This type is passed as the first parameter to the HTTP.request function.\n\nstack() accepts optional keyword arguments to enable/disable specific layers in the stack: request(method, args...; kw...) request(stack(; kw...), args...; kw...)\n\nThe minimal request execution stack is:\n\nstack = MessageLayer{ConnectionPoolLayer{StreamLayer}}\n\nThe figure below illustrates the full request execution stack and its relationship with HTTP.Response, HTTP.Parsers, HTTP.Stream and the HTTP.ConnectionPool.\n\n ┌────────────────────────────────────────────────────────────────────────────┐\n │                                            ┌───────────────────┐           │\n │  HTTP.jl Request Execution Stack           │ HTTP.ParsingError ├ ─ ─ ─ ─ ┐ │\n │                                            └───────────────────┘           │\n │                                            ┌───────────────────┐         │ │\n │                                            │ HTTP.IOError      ├ ─ ─ ─     │\n │                                            └───────────────────┘      │  │ │\n │                                            ┌───────────────────┐           │\n │                                            │ HTTP.StatusError  │─ ─   │  │ │\n │                                            └───────────────────┘   │       │\n │                                            ┌───────────────────┐      │  │ │\n │     request(method, url, headers, body) -> │ HTTP.Response     │   │       │\n │             ──────────────────────────     └─────────▲─────────┘      │  │ │\n │                           ║                          ║             │       │\n │   ┌────────────────────────────────────────────────────────────┐      │  │ │\n │   │ request(TopLayer,          method, ::URI, ::Headers, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(BasicAuthLayer,    method, ::URI, ::Headers, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(BasicAuthLayer,    method, ::URI, ::Headers, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(CookieLayer,       method, ::URI, ::Headers, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(CanonicalizeLayer, method, ::URI, ::Headers, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(MessageLayer,      method, ::URI, ::Headers, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(AWS4AuthLayer,             ::URI, ::Request, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(RetryLayer,                ::URI, ::Request, body) │   │       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n │   │ request(ExceptionLayer,            ::URI, ::Request, body) ├ ─ ┘       │\n │   ├────────────────────────────────────────────────────────────┤      │  │ │\n┌┼───┤ request(ConnectionPoolLayer,       ::URI, ::Request, body) ├ ─ ─ ─     │\n││   ├────────────────────────────────────────────────────────────┤         │ │\n││   │ request(DebugLayer,                ::IO,  ::Request, body) │           │\n││   ├────────────────────────────────────────────────────────────┤         │ │\n││   │ request(TimeoutLayer,              ::IO,  ::Request, body) │           │\n││   ├────────────────────────────────────────────────────────────┤         │ │\n││   │ request(StreamLayer,               ::IO,  ::Request, body) │           │\n││   └──────────────┬───────────────────┬─────────────────────────┘         │ │\n│└──────────────────┼────────║──────────┼───────────────║─────────────────────┘\n│                   │        ║          │               ║                   │\n│┌──────────────────▼───────────────┐   │  ┌──────────────────────────────────┐\n││ HTTP.Request                     │   │  │ HTTP.Response                  │ │\n││                                  │   │  │                                  │\n││ method::String                   ◀───┼──▶ status::Int                    │ │\n││ target::String                   │   │  │ headers::Vector{Pair}            │\n││ headers::Vector{Pair}            │   │  │ body::Vector{UInt8}            │ │\n││ body::Vector{UInt8}              │   │  │                                  │\n│└──────────────────▲───────────────┘   │  └───────────────▲────────────────┼─┘\n│┌──────────────────┴────────║──────────▼───────────────║──┴──────────────────┐\n││ HTTP.Stream <:IO          ║           ╔══════╗       ║                   │ │\n││   ┌───────────────────────────┐       ║   ┌──▼─────────────────────────┐   │\n││   │ startwrite(::Stream)      │       ║   │ startread(::Stream)        │ │ │\n││   │ write(::Stream, body)     │       ║   │ read(::Stream) -> body     │   │\n││   │ ...                       │       ║   │ ...                        │ │ │\n││   │ closewrite(::Stream)      │       ║   │ closeread(::Stream)        │   │\n││   └───────────────────────────┘       ║   └────────────────────────────┘ │ │\n│└───────────────────────────║────────┬──║──────║───────║──┬──────────────────┘\n│┌──────────────────────────────────┐ │  ║ ┌────▼───────║──▼────────────────┴─┐\n││ HTTP.Messages                    │ │  ║ │ HTTP.Parsers                     │\n││                                  │ │  ║ │                                  │\n││ writestartline(::IO, ::Request)  │ │  ║ │ parse_status_line(bytes, ::Req') │\n││ writeheaders(::IO, ::Request)    │ │  ║ │ parse_header_field(bytes, ::Req')│\n│└──────────────────────────────────┘ │  ║ └──────────────────────────────────┘\n│                            ║        │  ║\n│┌───────────────────────────║────────┼──║────────────────────────────────────┐\n└▶ HTTP.ConnectionPool       ║        │  ║                                    │\n │                     ┌──────────────▼────────┐ ┌───────────────────────┐    │\n │ getconnection() ->  │ HTTP.Transaction <:IO │ │ HTTP.Transaction <:IO │    │\n │                     └───────────────────────┘ └───────────────────────┘    │\n │                           ║    ╲│╱    ║                  ╲│╱               │\n │                           ║     │     ║                   │                │\n │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │\n │              pool: [│ HTTP.Connection       │,│ HTTP.Connection       │...]│\n │                     └───────────┬───────────┘ └───────────┬───────────┘    │\n │                           ║     │     ║                   │                │\n │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │\n │                     │ Base.TCPSocket <:IO   │ │MbedTLS.SSLContext <:IO│    │\n │                     └───────────────────────┘ └───────────┬───────────┘    │\n │                           ║           ║                   │                │\n │                           ║           ║       ┌───────────▼───────────┐    │\n │                           ║           ║       │ Base.TCPSocket <:IO   │    │\n │                           ║           ║       └───────────────────────┘    │\n └───────────────────────────║───────────║────────────────────────────────────┘\n                             ║           ║\n ┌───────────────────────────║───────────║──────────────┐  ┏━━━━━━━━━━━━━━━━━━┓\n │ HTTP Server               ▼                          │  ┃ data flow: ════▶ ┃\n │                        Request     Response          │  ┃ reference: ────▶ ┃\n └──────────────────────────────────────────────────────┘  ┗━━━━━━━━━━━━━━━━━━┛\n\nSee docs/src/layers.monopic.\n\n\n\n\n\n","category":"function"},{"location":"internal_architecture/#Request-Execution-Layers","page":"Internal Architecture","title":"Request Execution Layers","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.RedirectLayer\nHTTP.BasicAuthLayer\nHTTP.CookieLayer\nHTTP.CanonicalizeLayer\nHTTP.MessageLayer\nHTTP.AWS4AuthLayer\nHTTP.RetryLayer\nHTTP.ExceptionLayer\nHTTP.ConnectionPoolLayer\nHTTP.TimeoutLayer\nHTTP.StreamLayer","category":"page"},{"location":"internal_architecture/#HTTP.RedirectRequest.RedirectLayer","page":"Internal Architecture","title":"HTTP.RedirectRequest.RedirectLayer","text":"request(RedirectLayer, method, ::URI, headers, body) -> HTTP.Response\n\nRedirects the request in the case of 3xx response status.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.BasicAuthRequest.BasicAuthLayer","page":"Internal Architecture","title":"HTTP.BasicAuthRequest.BasicAuthLayer","text":"request(BasicAuthLayer, method, ::URI, headers, body) -> HTTP.Response\n\nAdd Authorization: Basic header using credentials from url userinfo.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.CookieRequest.CookieLayer","page":"Internal Architecture","title":"HTTP.CookieRequest.CookieLayer","text":"request(CookieLayer, method, ::URI, headers, body) -> HTTP.Response\n\nAdd locally stored Cookies to the request headers. Store new Cookies found in the response headers.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.CanonicalizeRequest.CanonicalizeLayer","page":"Internal Architecture","title":"HTTP.CanonicalizeRequest.CanonicalizeLayer","text":"request(CanonicalizeLayer, method, ::URI, headers, body) -> HTTP.Response\n\nRewrite request and response headers in Canonical-Camel-Dash-Format.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.MessageRequest.MessageLayer","page":"Internal Architecture","title":"HTTP.MessageRequest.MessageLayer","text":"request(MessageLayer, method, ::URI, headers, body) -> HTTP.Response\n\nConstruct a Request object and set mandatory headers.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.AWS4AuthRequest.AWS4AuthLayer","page":"Internal Architecture","title":"HTTP.AWS4AuthRequest.AWS4AuthLayer","text":"request(AWS4AuthLayer, ::URI, ::Request, body) -> HTTP.Response\n\nAdd a AWS Signature Version 4 Authorization header to a Request.\n\nCredentials are read from environment variables AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY and AWS_SESSION_TOKEN.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.RetryRequest.RetryLayer","page":"Internal Architecture","title":"HTTP.RetryRequest.RetryLayer","text":"request(RetryLayer, ::URI, ::Request, body) -> HTTP.Response\n\nRetry the request if it throws a recoverable exception.\n\nBase.retry and Base.ExponentialBackOff implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.\n\nMethods of isrecoverable(e) define which exception types lead to a retry. e.g. HTTP.IOError, Sockets.DNSError, Base.EOFError and HTTP.StatusError (if status is `5xx).\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.ExceptionRequest.ExceptionLayer","page":"Internal Architecture","title":"HTTP.ExceptionRequest.ExceptionLayer","text":"request(ExceptionLayer, ::URI, ::Request, body) -> HTTP.Response\n\nThrow a StatusError if the request returns an error response status.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.ConnectionRequest.ConnectionPoolLayer","page":"Internal Architecture","title":"HTTP.ConnectionRequest.ConnectionPoolLayer","text":"request(ConnectionPoolLayer, ::URI, ::Request, body) -> HTTP.Response\n\nRetrieve an IO connection from the ConnectionPool.\n\nClose the connection if the request throws an exception. Otherwise leave it open so that it can be reused.\n\nIO related exceptions from Base are wrapped in HTTP.IOError. See isioerror.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.TimeoutRequest.TimeoutLayer","page":"Internal Architecture","title":"HTTP.TimeoutRequest.TimeoutLayer","text":"request(TimeoutLayer, ::IO, ::Request, body) -> HTTP.Response\n\nClose IO if no data has been received for timeout seconds.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.StreamRequest.StreamLayer","page":"Internal Architecture","title":"HTTP.StreamRequest.StreamLayer","text":"request(StreamLayer, ::IO, ::Request, body) -> HTTP.Response\n\nCreate a Stream to send a Request and body to an IO stream and read the response.\n\nSend the Request body in a background task and begins reading the response immediately so that the transmission can be aborted if the Response status indicates that the server does not wish to receive the message body. RFC7230 6.5.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#Parser","page":"Internal Architecture","title":"Parser","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Parsers.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Parsers","category":"page"},{"location":"internal_architecture/#HTTP.Parsers","page":"Internal Architecture","title":"HTTP.Parsers","text":"The parser separates a raw HTTP Message into its component parts.\n\nIf the input data is invalid the Parser throws a HTTP.ParseError.\n\nThe parse_* functions processes a single element of a HTTP Message at a time and return a SubString containing the unused portion of the input.\n\nThe Parser does not interpret the Message Headers. It is beyond the scope of the Parser to deal with repeated header fields, multi-line values, cookies or case normalization.\n\nThe Parser has no knowledge of the high-level Request and Response structs defined in Messages.jl. However, the Request and Response structs must have field names compatible with those expected by the parse_status_line! and parse_request_line! functions.\n\n\n\n\n\n","category":"module"},{"location":"internal_architecture/#Messages","page":"Internal Architecture","title":"Messages","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Messages.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Messages","category":"page"},{"location":"internal_architecture/#HTTP.Messages","page":"Internal Architecture","title":"HTTP.Messages","text":"The Messages module defines structs that represent HTTP.Request and HTTP.Response Messages.\n\nThe Response struct has a request field that points to the corresponding Request; and the Request struct has a response field. The Request struct also has a parent field that points to a Response in the case of HTTP Redirect.\n\nThe Messages module defines IO read and write methods for Messages but it does not deal with URIs, creating connections, or executing requests.\n\nThe read methods throw EOFError exceptions if input data is incomplete. and call parser functions that may throw HTTP.ParsingError exceptions. The read and write methods may also result in low level IO exceptions.\n\nSending Messages\n\nMessages are formatted and written to an IO stream by Base.write(::IO,::HTTP.Messages.Message) and or HTTP.Messages.writeheaders.\n\nReceiving Messages\n\nMessages are parsed from IO stream data by HTTP.Messages.readheaders. This function calls HTTP.Parsers.parse_header_field and passes each header-field to HTTP.Messages.appendheader.\n\nHeaders\n\nHeaders are represented by Vector{Pair{String,String}}. As compared to Dict{String,String} this allows repeated header fields and preservation of order.\n\nHeader values can be accessed by name using HTTP.Messages.header and HTTP.Messages.setheader (case-insensitive).\n\nThe HTTP.Messages.appendheader function handles combining multi-line values, repeated header fields and special handling of multiple Set-Cookie headers.\n\nBodies\n\nThe HTTP.Message structs represent the Message Body as Vector{UInt8}.\n\nStreaming of request and response bodies is handled by the HTTP.StreamLayer and the HTTP.Stream <: IO stream.\n\n\n\n\n\n","category":"module"},{"location":"internal_architecture/#Streams","page":"Internal Architecture","title":"Streams","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Streams.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Streams.Stream","category":"page"},{"location":"internal_architecture/#HTTP.Streams.Stream","page":"Internal Architecture","title":"HTTP.Streams.Stream","text":"Stream(::Request, ::IO)\n\nCreates a HTTP.Stream that wraps an existing IO stream.\n\nstartwrite(::Stream) sends the Request headers to the IO stream.\nwrite(::Stream, body) sends the body (or a chunk of the body).\nclosewrite(::Stream) sends the final 0 chunk (if needed) and calls closewrite on the IO stream. When the IO stream is a HTTP.ConnectionPool.Transaction, calling closewrite releases the HTTP.ConnectionPool.Connection back into the pool for use by the next pipelined request.\nstartread(::Stream) calls startread on the IO stream then  reads and parses the Response headers.  When the IO stream is a HTTP.ConnectionPool.Transaction, calling startread waits for other pipelined responses to be read from the HTTP.ConnectionPool.Connection.\neof(::Stream) and readavailable(::Stream) parse the body from the IO  stream.\ncloseread(::Stream) reads the trailers and calls closeread on the IO  stream.  When the IO stream is a HTTP.ConnectionPool.Transaction,  calling closeread releases the readlock and allows the next pipelined  response to be read by another Stream that is waiting in startread.  If a complete response has not been received, closeread throws EOFError.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#Connections","page":"Internal Architecture","title":"Connections","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: ConnectionPool.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.ConnectionPool","category":"page"},{"location":"internal_architecture/#HTTP.ConnectionPool","page":"Internal Architecture","title":"HTTP.ConnectionPool","text":"This module provides the getconnection function with support for:\n\nOpening TCP and SSL connections.\nReusing connections for multiple Request/Response Messages,\nPipelining Request/Response Messages. i.e. allowing a new Request to be sent before previous Responses have been read.\n\nThis module defines a Connection struct to manage pipelining and connection reuse and a Transaction<: IO struct to manage a single pipelined request. Methods are provided for eof, readavailable, unsafe_write and close. This allows the Transaction object to act as a proxy for the TCPSocket or SSLContext that it wraps.\n\nThe POOL is used to manage connection pooling. Connections are identified by their host, port, pipeline limit, whether they require ssl verification, and whether they are a client or server connection. If a subsequent request matches these properties of a previous connection and limits are respected (reuse limit, idle timeout), and it wasn't otherwise remotely closed, a connection will be reused. Transactions pipeline their requests and responses concurrently on a Connection by calling startwrite and closewrite, with corresponding startread and closeread.\n\n\n\n\n\n","category":"module"},{"location":"#HTTP.jl-Documentation","page":"Home","title":"HTTP.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using \"\"\" syntax","category":"page"},{"location":"","page":"Home","title":"Home","text":"HTTP.jl is a Julia library for HTTP Messages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HTTP.request sends a HTTP Request Message and returns a Response Message.","category":"page"},{"location":"","page":"Home","title":"Home","text":"r = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nprintln(r.status)\nprintln(String(r.body))","category":"page"},{"location":"","page":"Home","title":"Home","text":"HTTP.open sends a HTTP Request Message and opens an IO stream from which the Response can be read.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"public_interface.md\", \"internal_architecture.md\", \"internal_interface.md\"]","category":"page"},{"location":"public_interface/#Public-Interface","page":"Public Interface","title":"Public Interface","text":"","category":"section"},{"location":"public_interface/#Requests","page":"Public Interface","title":"Requests","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.request\nHTTP.open\nHTTP.get\nHTTP.put\nHTTP.post\nHTTP.head","category":"page"},{"location":"public_interface/#HTTP.request","page":"Public Interface","title":"HTTP.request","text":"HTTP.request(method, url [, headers [, body]]; <keyword arguments>]) -> HTTP.Response\n\nSend a HTTP Request Message and receive a HTTP Response Message.\n\ne.g.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nprintln(r.status)\nprintln(String(r.body))\n\nheaders can be any collection where [string(k) => string(v) for (k,v) in headers] yields Vector{Pair}. e.g. a Dict(), a Vector{Tuple}, a Vector{Pair} or an iterator.\n\nbody can take a number of forms:\n\na String, a Vector{UInt8} or any T accepted by write(::IO, ::T)\na collection of String or AbstractVector{UInt8} or IO streams or items of any type T accepted by write(::IO, ::T...)\na readable IO stream or any IO-like type T for which eof(T) and readavailable(T) are defined.\n\nThe HTTP.Response struct contains:\n\nstatus::Int16 e.g. 200\nheaders::Vector{Pair{String,String}}  e.g. [\"Server\" => \"Apache\", \"Content-Type\" => \"text/html\"]\nbody::Vector{UInt8}, the Response Body bytes  (empty if a response_stream was specified in the request).\n\nFunctions HTTP.get, HTTP.put, HTTP.post and HTTP.head are defined as shorthand for HTTP.request(\"GET\", ...), etc.\n\nHTTP.request and HTTP.open also accept optional keyword parameters.\n\ne.g.\n\nHTTP.request(\"GET\", \"http://httpbin.org/ip\"; retries=4, cookies=true)\n\nHTTP.get(\"http://s3.us-east-1.amazonaws.com/\"; aws_authorization=true)\n\nconf = (readtimeout = 10,\n        pipeline_limit = 4,\n        retry = false,\n        redirect = false)\n\nHTTP.get(\"http://httpbin.org/ip\"; conf...)\nHTTP.put(\"http://httpbin.org/put\", [], \"Hello\"; conf...)\n\nURL options\n\nquery = nothing, replaces the query part of url.\n\nStreaming options\n\nresponse_stream = nothing, a writeable IO stream or any IO-like  type T for which write(T, AbstractVector{UInt8}) is defined.\nverbose = 0, set to 1 or 2 for extra message logging.\n\nConnection Pool options\n\nconnect_timeout = 0, close the connection after this many seconds if it is still attempting to connect. Use connect_timeout = 0 to disable.\nconnection_limit = 8, number of concurrent connections to each host:port.\npipeline_limit = 16, number of concurrent requests per connection.\nreuse_limit = nolimit, number of times a connection is reused after the                          first request.\nsocket_type = TCPSocket\n\nTimeout options\n\nreadtimeout = 0, close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable.\n\nRetry options\n\nretry = true, retry idempotent requests in case of error.\nretries = 4, number of times to retry.\nretry_non_idempotent = false, retry non-idempotent requests too. e.g. POST.\n\nRedirect options\n\nredirect = true, follow 3xx redirect responses.\nredirect_limit = 3, number of times to redirect.\nforwardheaders = true, forward original headers on redirect.\n\nStatus Exception options\n\nstatus_exception = true, throw HTTP.StatusError for response status >= 300.\n\nSSLContext options\n\nrequire_ssl_verification = NetworkOptions.verify_host(host), pass MBEDTLS_SSL_VERIFY_REQUIRED to the mbed TLS library. \"... peer must present a valid certificate, handshake is aborted if   verification failed.\"\nsslconfig = SSLConfig(require_ssl_verification)\n\nBasic Authentication options\n\nBasic authentication is detected automatically from the provided url's userinfo (in the form scheme://user:password@host) and adds the Authorization: Basic header\n\nAWS Authentication options\n\naws_authorization = false, enable AWS4 Authentication.\naws_service = split(url.host, \".\")[1]\naws_region = split(url.host, \".\")[2]\naws_access_key_id = ENV[\"AWS_ACCESS_KEY_ID\"]\naws_secret_access_key = ENV[\"AWS_SECRET_ACCESS_KEY\"]\naws_session_token = get(ENV, \"AWS_SESSION_TOKEN\", \"\")\nbody_sha256 = digest(MD_SHA256, body),\nbody_md5 = digest(MD_MD5, body),\n\nCookie options\n\ncookies::Union{Bool, Dict{<:AbstractString, <:AbstractString}} = false, enable cookies, or alternatively,      pass a Dict{AbstractString, AbstractString} of name-value pairs to manually pass cookies\ncookiejar::Dict{String, Set{Cookie}}=default_cookiejar,\n\nCanonicalization options\n\ncanonicalize_headers = false, rewrite request and response headers in Canonical-Camel-Dash-Format.\n\nProxy options\n\nproxy = proxyurl, pass request through a proxy given as a url\n\nAlternatively, HTTP.jl also respects the http_proxy, HTTP_PROXY, https_proxy, HTTPS_PROXY, and no_proxy environment variables; if set, they will be used automatically when making requests.\n\nRequest Body Examples\n\nString body:\n\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], \"post body data\")\n\nStream body from file:\n\nio = open(\"post_data.txt\", \"r\")\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], io)\n\nGenerator body:\n\nchunks = (\"chunk$i\" for i in 1:1000)\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nCollection body:\n\nchunks = [preamble_chunk, data_chunk, checksum(data_chunk)]\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nopen() do io body:\n\nHTTP.open(\"POST\", \"http://httpbin.org/post\") do io\n    write(io, preamble_chunk)\n    write(io, data_chunk)\n    write(io, checksum(data_chunk))\nend\n\nResponse Body Examples\n\nString body:\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\")\nprintln(String(r.body))\n\nStream body to file:\n\nio = open(\"get_data.txt\", \"w\")\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\nprintln(read(\"get_data.txt\"))\n\nStream body through buffer:\n\nio = Base.BufferStream()\n@async while !eof(io)\n    bytes = readavailable(io)\n    println(\"GET data: $bytes\")\nend\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\n\nStream body through open() do io:\n\nr = HTTP.open(\"GET\", \"http://httpbin.org/stream/10\") do io\n   while !eof(io)\n       println(String(readavailable(io)))\n   end\nend\n\nusing HTTP.IOExtras\n\nHTTP.open(\"GET\", \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    n = 0\n    r = startread(http)\n    l = parse(Int, HTTP.header(r, \"Content-Length\"))\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        while !eof(http)\n            bytes = readavailable(http)\n            write(vlc, bytes)\n            n += length(bytes)\n            println(\"streamed $n-bytes $((100*n)÷l)%\\u1b[1A\")\n        end\n    end\nend\n\nRequest and Response Body Examples\n\nString bodies:\n\nr = HTTP.request(\"POST\", \"http://httpbin.org/post\", [], \"post body data\")\nprintln(String(r.body))\n\nInterfacing with RESTful JSON APIs:\n\nusing JSON\nparams = Dict(\"user\"=>\"RAO...tjN\", \"token\"=>\"NzU...Wnp\", \"message\"=>\"Hello!\")\nbase_url = \"http://api.domain.com\"\nendpoint = \"/1/messages.json\"\nurl = base_url * endpoint\nr = HTTP.request(\"POST\", url,\n             [\"Content-Type\" => \"application/json\"],\n             JSON.json(params))\nprintln(JSON.parse(String(r.body)))\n\nStream bodies from and to files:\n\nin = open(\"foo.png\", \"r\")\nout = open(\"foo.jpg\", \"w\")\nHTTP.request(\"POST\", \"http://convert.com/png2jpg\", [], in, response_stream=out)\n\nStream bodies through: open() do io:\n\nusing HTTP.IOExtras\n\nHTTP.open(\"POST\", \"http://music.com/play\") do io\n    write(io, JSON.json([\n        \"auth\" => \"12345XXXX\",\n        \"song_id\" => 7,\n    ]))\n    r = startread(io)\n    @show r.status\n    while !eof(io)\n        bytes = readavailable(io)\n        play_audio(bytes)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.open","page":"Public Interface","title":"HTTP.open","text":"HTTP.open(method, url, [,headers]) do io\n    write(io, body)\n    [startread(io) -> HTTP.Response]\n    while !eof(io)\n        readavailable(io) -> AbstractVector{UInt8}\n    end\nend -> HTTP.Response\n\nThe HTTP.open API allows the Request Body to be written to (and/or the Response Body to be read from) an IO stream.\n\ne.g. Streaming an audio file to the vlc player:\n\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.get","page":"Public Interface","title":"HTTP.get","text":"HTTP.get(url [, headers]; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"GET\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.put","page":"Public Interface","title":"HTTP.put","text":"HTTP.put(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"PUT\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.post","page":"Public Interface","title":"HTTP.post","text":"HTTP.post(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"POST\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.head","page":"Public Interface","title":"HTTP.head","text":"HTTP.head(url; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"HEAD\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Request-body-types","page":"Public Interface","title":"Request body types","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.Form\nHTTP.Multipart","category":"page"},{"location":"public_interface/#HTTP.Form","page":"Public Interface","title":"HTTP.Form","text":"Form(data; boundary=string(rand(UInt128), base=16))\n\nConstruct a request body for multipart/form-data encoding from data.\n\ndata must iterate key-value pairs (e.g. Dict or Vector{Pair}) where the key/value of the iterator is the key/value of each mutipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an IOStream such as returned via open(file), or an IOBuffer for in-memory data.\n\nFor complete control over a multipart chunk's details, an HTTP.Multipart type is provided to support setting the filename, Content-Type, and Content-Transfer-Encoding.\n\nExamples\n\ndata = Dict(\n    \"text\" => \"text data\",\n    # filename (cat.png) and content-type (image/png) inferred from the IOStream\n    \"file1\" => open(\"cat.png\"),\n    # manully controlled chunk\n    \"file2\" => HTTP.Multipart(\"dog.jpeg\", open(\"mydog.jpg\"), \"image/jpeg\"),\n)\nbody = HTTP.Form(data)\nheaders = []\nHTTP.post(url, headers, body)\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Multipart","page":"Public Interface","title":"HTTP.Multipart","text":"Multipart(filename::String, data::IO, content_type=HTTP.sniff(data), content_transfer_encoding=\"\")\n\nA type to represent a single multipart upload chunk for a file. This type would be used as the value in a key-value pair when constructing a HTTP.Form for a request body (see example below). The data argument must be an IO type such as IOStream, or IOBuffer. The content_type and content_transfer_encoding arguments allow manual setting of these multipart headers. Content-Type will default to the result of the HTTP.sniff(data) mimetype detection algorithm, whereas Content-Transfer-Encoding will be left out if not specified.\n\nExamples\n\nbody = HTTP.Form(Dict(\n    \"key\" => HTTP.Multipart(\"File.txt\", open(\"MyFile.txt\"), \"text/plain\"),\n))\nheaders = []\nHTTP.post(url, headers, body)\n\nExtended help\n\nFilename SHOULD be included when the Multipart represents the contents of a file RFC7578 4.2\n\nContent-Disposition set to \"form-data\" MUST be included with each Multipart. An additional \"name\" parameter MUST be included An optional \"filename\" parameter SHOULD be included if the contents of a file are sent This will be formatted such as:   Content-Disposition: form-data; name=\"user\"; filename=\"myfile.txt\" RFC7578 4.2\n\nContent-Type for each Multipart is optional, but SHOULD be included if the contents of a file are sent. RFC7578 4.4\n\nContent-Transfer-Encoding for each Multipart is deprecated RFC7578 4.7\n\nOther Content- header fields MUST be ignored RFC7578 4.8\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#Request-exceptions","page":"Public Interface","title":"Request exceptions","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"Request functions may throw the following exceptions:","category":"page"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.StatusError\nHTTP.ParseError\nHTTP.IOError","category":"page"},{"location":"public_interface/#HTTP.ExceptionRequest.StatusError","page":"Public Interface","title":"HTTP.ExceptionRequest.StatusError","text":"StatusError <: Exception\n\nThe Response has a 4xx, 5xx or unrecognised status code.\n\nFields:\n\nstatus::Int16, the response status code.\nresponse the HTTP.Response\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Parsers.ParseError","page":"Public Interface","title":"HTTP.Parsers.ParseError","text":"ParseError <: Exception\n\nParser input was invalid.\n\nFields:\n\ncode, error code\nbytes, the offending input.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.IOExtras.IOError","page":"Public Interface","title":"HTTP.IOExtras.IOError","text":"IOError <: Exception\n\nThe request terminated with due to an IO-related error.\n\nFields:\n\ne, the error.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"Sockets.DNSError","category":"page"},{"location":"public_interface/#Sockets.DNSError","page":"Public Interface","title":"Sockets.DNSError","text":"DNSError\n\nThe type of exception thrown when an error occurs in DNS lookup. The host field indicates the host URL string. The code field indicates the error code based on libuv.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#URIs","page":"Public Interface","title":"URIs","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.jl uses the URIs.jl package for handling URIs. Some functionality from URIs.jl, relevant to HTTP.jl, are listed below:","category":"page"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"URI\nURIs.escapeuri\nURIs.unescapeuri\nURIs.splitpath\nBase.isvalid(::URIs.URI)","category":"page"},{"location":"public_interface/#URIs.URI","page":"Public Interface","title":"URIs.URI","text":"URI(; scheme=\"\", host=\"\", port=\"\", etc...)\nURI(str) = parse(URI, str::String)\n\nA type representing a URI (e.g. a URL). Can be constructed from distinct parts using the various supported keyword arguments, or from a string. The URI constructors will automatically escape any provided query arguments, typically provided as \"key\"=>\"value\"::Pair or Dict(\"key\"=>\"value\"). Note that multiple values for a single query key can provided like Dict(\"key\"=>[\"value1\", \"value2\"]).\n\nWhen constructing a URI from a String, you need to first unescape that string: URI( URIs.unescapeuri(str) ).\n\nThe URI struct stores the complete URI in the uri::String field and the component parts in the following SubString fields:\n\nscheme, e.g. \"http\" or \"https\"\nuserinfo, e.g. \"username:password\"\nhost e.g. \"julialang.org\"\nport e.g. \"80\" or \"\"\npath e.g \"/\"\nquery e.g. \"Foo=1&Bar=2\"\nfragment\n\nThe queryparams(::URI) function returns a Dict containing the query.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#URIs.escapeuri","page":"Public Interface","title":"URIs.escapeuri","text":"escapeuri(x)\n\nApply URI percent-encoding to escape special characters in x.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#URIs.unescapeuri","page":"Public Interface","title":"URIs.unescapeuri","text":"unescapeuri(str)\n\nPercent-decode a string according to the URI escaping rules.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#URIs.splitpath","page":"Public Interface","title":"URIs.splitpath","text":"URIs.splitpath(path|uri; rstrip_empty_segment=true)\n\nSplits the path into component segments based on /, according to http://tools.ietf.org/html/rfc3986#section-3.3. Any fragment and query parts of the string are ignored if present.\n\nA final empty path segment (trailing '/') is removed, if present. This is technically incompatible with the segment grammar of RFC3986, but it seems to be a common recommendation to make paths with and without a trailing slash equivalent. To preserve any final empty path segment, set rstrip_empty_segment=false.\n\nExamples\n\njulia> URIs.splitpath(URI(\"http://example.com/foo/bar?a=b&c=d\"))\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\njulia> URIs.splitpath(\"/foo/bar/\")\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Base.isvalid-Tuple{URI}","page":"Public Interface","title":"Base.isvalid","text":"checks if a URI is valid\n\n\n\n\n\n","category":"method"},{"location":"public_interface/#Cookies","page":"Public Interface","title":"Cookies","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.Cookie","category":"page"},{"location":"public_interface/#HTTP.Cookies.Cookie","page":"Public Interface","title":"HTTP.Cookies.Cookie","text":"Cookie()\nCookie(; kwargs...)\nCookie(name, value; kwargs...)\n\nA Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:\n\nname: name of the cookie\nvalue: value of the cookie\npath: applicable path for the cookie\ndomain: applicable domain for the cookie\nexpires: a Dates.DateTime representing when the cookie should expire\nmaxage: maxage == 0 means no max age, maxage < 0 means delete cookie now, max age > 0 means the # of seconds until expiration\nsecure::Bool: secure cookie attribute\nhttponly::Bool: httponly cookie attribute\nhostonly::Bool: hostonly cookie attribute\n\nSee http:#tools.ietf.org/html/rfc6265 for details.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#Utilities","page":"Public Interface","title":"Utilities","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.sniff\nHTTP.Strings.escapehtml\nHTTP.statustext","category":"page"},{"location":"public_interface/#HTTP.sniff","page":"Public Interface","title":"HTTP.sniff","text":"HTTP.sniff(content::Union{Vector{UInt8}, String, IO}) => String (mimetype)\n\nHTTP.sniff will look at the first 512 bytes of content to try and determine a valid mimetype. If a mimetype can't be determined appropriately, \"application/octet-stream\" is returned.\n\nSupports JSON detection through the HTTP.isjson(content) function.\n\nExamples\n\njulia> HTTP.sniff(\"Hello world!!\")\n\"text/plain; charset=utf-8\"\n\njulia> HTTP.sniff(\"<html><body>Hello world!!</body></html>\")\n\"text/html; charset=utf-8\"\n\njulia> HTTP.sniff(\"{\"a\": -1.0}\")\n\"application/json; charset=utf-8\"\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Strings.escapehtml","page":"Public Interface","title":"HTTP.Strings.escapehtml","text":"escapehtml(i::String)\n\nReturns a string with special HTML characters escaped: &, <, >, \", '\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.statustext","page":"Public Interface","title":"HTTP.Messages.statustext","text":"statustext(::Int) -> String\n\nString representation of a HTTP status code.\n\nExamples\n\njulia> statustext(200)\n\"OK\"\n\njulia> statustext(404)\n\"Not Found\"\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Server-/-Handlers","page":"Public Interface","title":"Server / Handlers","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.listen\nHTTP.serve\nHTTP.Handlers\nHTTP.handle\nHTTP.RequestHandlerFunction\nHTTP.StreamHandlerFunction\nHTTP.Router\nHTTP.@register\nHTTP.@logfmt_str","category":"page"},{"location":"public_interface/#HTTP.Servers.listen","page":"Public Interface","title":"HTTP.Servers.listen","text":"HTTP.listen([host=Sockets.localhost[, port=8081]]; kw...) do http::HTTP.Stream\n    ...\nend\n\nListen for HTTP connections and execute the do function for each request.\n\nThe do function should be of the form f(::HTTP.Stream)::Nothing, and should at the minimum set a status via setstatus() and call startwrite() either explicitly or implicitly by writing out a response via write().  Failure to do this will result in an HTTP 500 error being transmitted to the client.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl  connections. Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl  verification (useful for testing).\nreuse_limit = nolimit, number of times a connection is allowed to be reused after the first request.\ntcpisvalid = tcp->true, function f(::TCPSocket)::Bool to, check accepted  connection before processing requests. e.g. to do source IP filtering.\nreadtimeout::Int=0, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple servers to listen on the same port.\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows closing the server.\nconnection_count::Ref{Int}, reference to track the number of currently  open connections.\nrate_limit::Rational{Int}=nothing\", number of connections//second  allowed per client IP address; excess connections are immediately closed.  e.g. 5//1.\nverbose::Bool=false, log connection information to stdout.\naccess_log::Function, function for formatting access log messages. The  function should accept two arguments, io::IO to which the messages should  be written, and http::HTTP.Stream which can be used to query information  from. See also @logfmt_str.\non_shutdown::Union{Function, Vector{<:Function}, Nothing}=nothing, one or  more functions to be run if the server is closed (for example by an  InterruptException). Note, shutdown function(s) will not run if an  IOServer object is supplied to the server keyword argument and closed  by close(server).\n\ne.g.\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    HTTP.setheader(http, \"Content-Type\" => \"text/html\")\n    write(http, \"target uri: $(http.message.target)<BR>\")\n    write(http, \"request body:<BR><PRE>\")\n    write(http, read(http))\n    write(http, \"</PRE>\")\n    return\nend\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\nThe server= option can be used to pass an already listening socket to HTTP.listen. This allows manual control of server shutdown.\n\ne.g.\n\nusing Sockets\nserver = Sockets.listen(Sockets.InetAddr(parse(IPAddr, host), port))\n@async HTTP.listen(f, host, port; server=server)\n\n# Closing server will stop HTTP.listen.\nclose(server)\n\nTo run the following HTTP chat example, open two Julia REPL windows and paste the example code into both of them. Then in one window run chat_server() and in the other run chat_client(), then type hello and press return. Whatever you type on the client will be displayed on the server and vis-versa.\n\nusing HTTP\n\nfunction chat(io::HTTP.Stream)\n    @async while !eof(io)\n        write(stdout, readavailable(io), \"\\n\")\n    end\n    while isopen(io)\n        write(io, readline(stdin))\n    end\nend\n\nchat_server() = HTTP.listen(\"127.0.0.1\", 8087) do io\n    write(io, \"HTTP.jl Chat Server. Welcome!\")\n    chat(io)\nend\n\nchat_client() = HTTP.open(\"POST\", \"http://127.0.0.1:8087\") do io\n    chat(io)\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers.serve","page":"Public Interface","title":"HTTP.Handlers.serve","text":"HTTP.serve([host=Sockets.localhost[, port=8081]]; kw...) do req::HTTP.Request\n    ...\nend\nHTTP.serve([host=Sockets.localhost[, port=8081]]; stream=true, kw...) do stream::HTTP.Stream\n    ...\nend\nHTTP.serve(handler, [host=Sockets.localhost[, port=8081]]; kw...)\n\nListen for HTTP connections and handle each request received. The \"handler\" can be a function that operates directly on HTTP.Stream, HTTP.Request, or any kind of HTTP.Handler instance. For functions like f(::HTTP.Stream), also pass stream=true to signal a streaming handler.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl connections.  Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl verification (useful for testing)\nreuse_limit = nolimit, number of times a connection is allowed to be reused  after the first request.\ntcpisvalid::Function (::TCPSocket) -> Bool, check accepted connection before  processing requests. e.g. to implement source IP filtering, rate-limiting, etc.\nreadtimeout::Int=0, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple server processes to listen on the same port. Only fully supported on linux; OSX will allow multiple server processes to listen, but only one will accept connections\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows manual control over closing the server.\nconnection_count::Ref{Int}, reference to track the # of currently open connections.\nrate_limit::Rational{Int}=nothing\", number of connections//second allowed  per client IP address; excess connections are immediately closed. e.g. 5//1.\nstream::Bool=false, the handler will operate on an HTTP.Stream instead of HTTP.Request\nverbose::Bool=false, log connection information to stdout.\non_shutdown::Union{Function, Vector{<:Function}, Nothing}=nothing, one or  more functions to be run if the server is closed (for example by an  InterruptException). Note, shutdown function(s) will not run if an  IOServer object is supplied to the server keyword argument and closed  by close(server).\n\nExamples\n\nHTTP.serve(; stream=true) do http::HTTP.Stream\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\n    return\nend\n\n# pass in own server socket to control shutdown\nusing Sockets\nserver = Sockets.listen(Sockets.InetAddr(parse(IPAddr, host), port))\n@async HTTP.serve(f, host, port; server=server)\n# close server which will stop HTTP.serve\nclose(server)\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers","page":"Public Interface","title":"HTTP.Handlers","text":"Examples\n\nLet's put together an example http REST server for our hypothetical \"ZooApplication\" that utilizes various parts of the Servers & Handler frameworks.\n\nOur application allows users to interact with custom \"animal\" JSON objects.\n\nFirst we have our \"model\" or data structures:\n\nmutable struct Animal\n    id::Int\n    type::String\n    name::String\nend\n\nNow we want to define our REST api, or how do we allow users to create, update, retrieve and delete animals:\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# \"service\" functions to actually do the work\nfunction createAnimal(req::HTTP.Request)\n    animal = JSON3.read(IOBuffer(HTTP.payload(req)), Animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    animal = ANIMALS[parse(Int, animalId)]\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = JSON3.read(IOBuffer(HTTP.payload(req)), Animal)\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, parse(Int, animal.id))\n    return HTTP.Response(200)\nend\n\n# define REST endpoints to dispatch to \"service\" functions\nconst ANIMAL_ROUTER = HTTP.Router()\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/animals\", createAnimal)\n# note the use of `*` to capture the path segment \"variable\" animal id\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"PUT\", \"/api/zoo/v1/animals\", updateAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/animals/*\", deleteAnimal)\n\nGreat! At this point, we could spin up our server and let users start managing their animals:\n\nHTTP.serve(ANIMAL_ROUTER, Sockets.localhost, 8081)\n\nNow, you may have noticed that there was a bit of repetition in our \"service\" functions, particularly with regards to the JSON serialization/deserialization. Perhaps we can simplify things by writing a custom \"JSONHandler\" to do some of the repetitive work for us.\n\nfunction JSONHandler(req::HTTP.Request)\n    # first check if there's any request body\n    body = IOBuffer(HTTP.payload(req))\n    if eof(body)\n        # no request body\n        response_body = handle(ANIMAL_ROUTER, req)\n    else\n        # there's a body, so pass it on to the handler we dispatch to\n        response_body = handle(ANIMAL_ROUTER, req, JSON3.read(body, Animal))\n    end\n    return HTTP.Response(200, JSON3.write(response_body))\nend\n\n# **simplified** \"service\" functions\nfunction createAnimal(req::HTTP.Request, animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    return ANIMALS[animalId]\nend\n\nfunction updateAnimal(req::HTTP.Request, animal)\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, animal.id)\n    return \"\"\nend\n\nAnd we modify slightly how we run our server, letting our new JSONHandler be the entry point instead of our router:\n\nHTTP.serve(JSONHandler, Sockets.localhost, 8081)\n\nOur JSONHandler is nice because it saves us a bunch of repetition: if a request body comes in, we automatically deserialize it and pass it on to the service function. And each service function doesn't need to worry about returning HTTP.Responses anymore, but can just focus on returning plain Julia objects/strings. The other huge advantage is it provides a clean separation of concerns between the \"service\" layer, which should really concern itself with application logic, and the \"REST API\" layer, which should take care of translating between our model and a web data format (JSON).\n\nLet's take this one step further and allow multiple users to manage users, and add in one more custom handler to provide an authentication layer to our application. We can't just let anybody be modifying another user's animals!\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\nend\n\n# modify our data store to allow for multiple users\nconst ANIMALS = Dict{Base.UUID, Dict{Int, Animal}}()\n\n# creating a user returns a new UUID key unique to the user\ncreateUser(req) = Base.UUID(rand(UInt128))\n\n# add an additional endpoint for user creation\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users\", createUser)\n# modify service endpoints to have user pass UUID in\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/users/*/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/users/*/animals/*\", deleteAnimal)\n\n# modified service functions to account for multiple users\nfunction createAnimal(req::HTTP.Request, animal)\n    animal.id = getNextId()\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    paths = HTTP.URIs.splitpath(req.target)\n    userId = path[5] # /api/zoo/v1/users/x92jf-.../animals/10, get user UUID\n    animalId = path[7] # /api/zoo/v1/users/x92jf-.../animals/10, get 10\n    return ANIMALS[userId][parse(Int, animalId)]\nend\n\nfunction updateAnimal(req::HTTP.Request, animal)\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    paths = HTTP.URIs.splitpath(req.target)\n    userId = path[5] # /api/zoo/v1/users/x92jf-.../animals/10, get user UUID\n    animalId = path[7] # /api/zoo/v1/users/x92jf-.../animals/10, get 10\n    delete!(ANIMALS[userId], parse(Int, animal.id))\n    return \"\"\nend\n\n# AuthHandler to reject any unknown users\nfunction AuthHandler(req)\n    if HTTP.hasheader(req, \"Animal-UUID\")\n        uuid = HTTP.header(req, \"Animal-UUID\")\n        if haskey(ANIMALS, uuid)\n            return JSONHandler(req)\n        end\n    end\n    return HTTP.Response(401, \"unauthorized\")\nend\n\nAnd our modified server invocation:\n\nHTTP.serve(AuthHandler, Sockets.localhost, 8081)\n\nLet's review what's going on here:\n\nEach Animal object now includes a UUID object unique to a user\nWe added a /api/zoo/v1/users endpoint for creating a new user\nEach of our service functions now account for individual users\nWe made a new AuthHandler as the very first entry point in our middleware stack, this means that every single request must first pass through this authentication layer before reaching the service layer. Our AuthHandler checks that the user provided our security request header Animal-UUID and if so, ensures the provided UUID corresponds to a valid user. If not, the AuthHandler returns a 401 HTTP response, signalling that the request is unauthorized\n\nVoila, hopefully that helps provide a slightly-more-than-trivial example of utilizing the HTTP.Handler framework in conjunction with running an HTTP server.\n\n\n\n\n\n","category":"module"},{"location":"public_interface/#HTTP.Handlers.handle","page":"Public Interface","title":"HTTP.Handlers.handle","text":"HTTP.handle(handler::HTTP.RequestHandler, ::HTTP.Request) => HTTP.Response\nHTTP.handle(handler::HTTP.StreamHandler, ::HTTP.Stream)\n\nDispatch function used to handle incoming requests to a server. Can be overloaded by custom HTTP.Handler subtypes to implement custom \"handling\" behavior.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers.RequestHandlerFunction","page":"Public Interface","title":"HTTP.Handlers.RequestHandlerFunction","text":"RequestHandlerFunction(f)\n\nA function-wrapper type that is a subtype of RequestHandler. Takes a single function as an argument that should be of the form f(::HTTP.Request) => HTTP.Response\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Handlers.StreamHandlerFunction","page":"Public Interface","title":"HTTP.Handlers.StreamHandlerFunction","text":"StreamHandlerFunction(f)\n\nA function-wrapper type that is a subtype of StreamHandler. Takes a single function as an argument that should be of the form f(::HTTP.Stream) => Nothing, i.e. it accepts a raw HTTP.Stream, handles the incoming request, writes a response back out to the stream directly, then returns.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Handlers.Router","page":"Public Interface","title":"HTTP.Handlers.Router","text":"HTTP.Router(h::Handler)\nHTTP.Router(f::Function)\nHTTP.Router()\n\nAn HTTP.Handler type that supports pattern matching request url paths to registered HTTP.Handlers. Can accept a default Handler or Function that will be used in case no other handlers match; by default, a 404 response handler is used. Paths can be mapped to a handler via HTTP.@register(r::Router, path, handler), see ?HTTP.@register for more details.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Handlers.@register","page":"Public Interface","title":"HTTP.Handlers.@register","text":"HTTP.@register(r::Router, path, handler)\nHTTP.@register(r::Router, method::String, path, handler)\nHTTP.@register(r::Router, method::String, scheme::String, host::String, path, handler)\n\nFunction to map request urls matching path and optional method, scheme, host to another handler::HTTP.Handler. URL paths are registered one at a time, and multiple urls can map to the same handler. The URL can be passed as a String. Requests can be routed based on: method, scheme, hostname, or path. The following examples show how various urls will direct how a request is routed by a server:\n\n\"http://*\": match all HTTP requests, regardless of path\n\"https://*\": match all HTTPS requests, regardless of path\n\"/gmail\": regardless of scheme or host, match any request with a path starting with \"gmail\"\n\"/gmail/userId/*/inbox: match any request matching the path pattern, \"*\" is used as a wildcard that matches any value between the two \"/\"\n\nNote that due to being a macro (and the internal routing functionality), routes can only be registered statically, i.e. at the top level of a module, and not dynamically, i.e. inside a function.\n\n\n\n\n\n","category":"macro"},{"location":"public_interface/#HTTP.@logfmt_str","page":"Public Interface","title":"HTTP.@logfmt_str","text":"logfmt\"...\"\n\nParse an NGINX-style log format string and return a function mapping (io::IO, http::HTTP.Stream) -> body suitable for passing to HTTP.listen using the access_logfmt keyword argument.\n\nThe following variables are currently supported:\n\n$http_name: arbitrary request header (with - replaced with _, e.g. http_user_agent)\n$sent_http_name: arbitrary response header (with - replaced with _)\n$request: the request line, e.g. GET /index.html HTTP/1.1\n$request_method: the request method\n$request_uri: the request URI\n$remote_addr: client address\n$remote_port: client port\n$remote_user: user name supplied with the Basic authentication\n$server_protocol: server protocol\n$time_iso8601: local time in ISO8601 format\n$time_local: local time in Common Log Format\n$status: response status code\n$body_bytes_sent: number of bytes in response body\n\nExamples\n\nlogfmt\"[$time_iso8601] \\\"$request\\\" $status\" # [2021-05-01T12:34:40+0100] \"GET /index.html HTTP/1.1\" 200\n\nlogfmt\"$remote_addr \\\"$http_user_agent\\\"\" # 127.0.0.1 \"curl/7.47.0\"\n\n\n\n\n\n","category":"macro"},{"location":"public_interface/#Messages-Interface","page":"Public Interface","title":"Messages Interface","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.Request\nHTTP.Response\nHTTP.status\nHTTP.headers\nHTTP.body\nHTTP.method\nHTTP.uri","category":"page"},{"location":"public_interface/#HTTP.Messages.Request","page":"Public Interface","title":"HTTP.Messages.Request","text":"Request <: Message\n\nRepresents a HTTP Request Message.\n\nmethod::String  RFC7230 3.1.1\ntarget::String  RFC7230 5.3\nversion::VersionNumber  RFC7230 2.6\nheaders::Vector{Pair{String,String}}  RFC7230 3.2\nbody::Vector{UInt8}  RFC7230 3.3\nresponse, the Response to this Request\ntxcount, number of times this Request has been sent (see RetryRequest.jl).\nparent, the Response (if any) that led to this request (e.g. in the case of a redirect).  RFC7230 6.4\n\nYou can get each data with HTTP.method, HTTP.headers, HTTP.uri, and HTTP.body.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Messages.Response","page":"Public Interface","title":"HTTP.Messages.Response","text":"Response <: Message\n\nRepresents a HTTP Response Message.\n\nversion::VersionNumber  RFC7230 2.6\nstatus::Int16  RFC7230 3.1.2  RFC7231 6\nheaders::Vector{Pair{String,String}}  RFC7230 3.2\nbody::Vector{UInt8}  RFC7230 3.3\nrequest, the Request that yielded this Response.\n\nYou can get each data with HTTP.status, HTTP.headers, and HTTP.body.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Messages.status","page":"Public Interface","title":"HTTP.Messages.status","text":"status(r::Response)\n\nGet status from a response.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.headers","page":"Public Interface","title":"HTTP.Messages.headers","text":"headers(r::Response)\n\nGet headers from a response.\n\n\n\n\n\nheaders(r::Request)\n\nGet headers from a request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.body","page":"Public Interface","title":"HTTP.Messages.body","text":"body(r::Response)\n\nGet body from a response.\n\n\n\n\n\nbody(r::Request)\n\nGet body from a request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.method","page":"Public Interface","title":"HTTP.Messages.method","text":"method(r::Request)\n\nGet method from a request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.uri","page":"Public Interface","title":"HTTP.Messages.uri","text":"uri(r::Request)\n\nGet URI from a request.\n\n\n\n\n\n","category":"function"}]
}
