<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HTTP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Requests-1">Requests</a></li><li><a class="toctext" href="#Server-/-Handlers-1">Server / Handlers</a></li><li><a class="toctext" href="#URIs-1">URIs</a></li><li><a class="toctext" href="#Cookies-1">Cookies</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li class="toplevel"><a class="toctext" href="#HTTP.jl-Internal-Architecture-1">HTTP.jl Internal Architecture</a></li><li><a class="toctext" href="#Request-Execution-Layers-1">Request Execution Layers</a></li><li><a class="toctext" href="#Parser-1">Parser</a></li><li><a class="toctext" href="#Messages-1">Messages</a></li><li><a class="toctext" href="#Streams-1">Streams</a></li><li><a class="toctext" href="#Connections-1">Connections</a></li><li class="toplevel"><a class="toctext" href="#Internal-Interfaces-1">Internal Interfaces</a></li><li><a class="toctext" href="#Parser-Interface-1">Parser Interface</a></li><li><a class="toctext" href="#Messages-Interface-1">Messages Interface</a></li><li><a class="toctext" href="#IOExtras-Interface-1">IOExtras Interface</a></li><li><a class="toctext" href="#Streams-Interface-1">Streams Interface</a></li><li><a class="toctext" href="#Connection-Pooling-Interface-1">Connection Pooling Interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaWeb/HTTP.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HTTP.jl-Documentation-1" href="#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></h1><p><code>HTTP.jl</code> is a Julia library for HTTP Messages.</p><p><a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a> sends a HTTP Request Message and returns a Response Message.</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;)
println(r.status)
println(String(r.body))</code></pre><p><a href="index.html#HTTP.open"><code>HTTP.open</code></a> sends a HTTP Request Message and opens an <code>IO</code> stream from which the Response can be read.</p><pre><code class="language-julia">HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        write(vlc, http)
    end
end</code></pre><ul><li><a href="index.html#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></li><ul><li><a href="index.html#Requests-1">Requests</a></li><li><a href="index.html#Server-/-Handlers-1">Server / Handlers</a></li><li><a href="index.html#URIs-1">URIs</a></li><li><a href="index.html#Cookies-1">Cookies</a></li><li><a href="index.html#Utilities-1">Utilities</a></li></ul><li><a href="index.html#HTTP.jl-Internal-Architecture-1">HTTP.jl Internal Architecture</a></li><ul><li><a href="index.html#Request-Execution-Layers-1">Request Execution Layers</a></li><li><a href="index.html#Parser-1">Parser</a></li><li><a href="index.html#Messages-1">Messages</a></li><li><a href="index.html#Streams-1">Streams</a></li><li><a href="index.html#Connections-1">Connections</a></li></ul><li><a href="index.html#Internal-Interfaces-1">Internal Interfaces</a></li><ul><li><a href="index.html#Parser-Interface-1">Parser Interface</a></li><li><a href="index.html#Messages-Interface-1">Messages Interface</a></li><li><a href="index.html#IOExtras-Interface-1">IOExtras Interface</a></li><li><a href="index.html#Streams-Interface-1">Streams Interface</a></li><li><a href="index.html#Connection-Pooling-Interface-1">Connection Pooling Interface</a></li></ul></ul><h2><a class="nav-anchor" id="Requests-1" href="#Requests-1">Requests</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}" href="#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">HTTP.request(method, url [, headers [, body]]; &lt;keyword arguments&gt;]) -&gt; HTTP.Response</code></pre><p>Send a HTTP Request Message and recieve a HTTP Response Message.</p><p>e.g.</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;)
println(r.status)
println(String(r.body))</code></pre><p><code>headers</code> can be any collection where <code>[string(k) =&gt; string(v) for (k,v) in headers]</code> yields <code>Vector{Pair}</code>. e.g. a <code>Dict()</code>, a <code>Vector{Tuple}</code>, a <code>Vector{Pair}</code> or an iterator.</p><p><code>body</code> can take a number of forms:</p><ul><li><p>a <code>String</code>, a <code>Vector{UInt8}</code> or any <code>T</code> accepted by <code>write(::IO, ::T)</code></p></li><li><p>a collection of <code>String</code> or <code>AbstractVector{UInt8}</code> or <code>IO</code> streams or items of any type <code>T</code> accepted by <code>write(::IO, ::T...)</code></p></li><li><p>a readable <code>IO</code> stream or any <code>IO</code>-like type <code>T</code> for which <code>eof(T)</code> and <code>readavailable(T)</code> are defined.</p></li></ul><p>The <code>HTTP.Response</code> struct contains:</p><ul><li><p><code>status::Int16</code> e.g. <code>200</code></p></li><li><p><code>headers::Vector{Pair{String,String}}</code>  e.g. [&quot;Server&quot; =&gt; &quot;Apache&quot;, &quot;Content-Type&quot; =&gt; &quot;text/html&quot;]</p></li><li><p><code>body::Vector{UInt8}</code>, the Response Body bytes  (empty if a <code>response_stream</code> was specified in the <code>request</code>).</p></li></ul><p>Functions <code>HTTP.get</code>, <code>HTTP.put</code>, <code>HTTP.post</code> and <code>HTTP.head</code> are defined as shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>, etc.</p><p><code>HTTP.request</code> and <code>HTTP.open</code> also accept optional keyword parameters.</p><p>e.g.</p><pre><code class="language-julia">HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;; retries=4, cookies=true)

HTTP.get(&quot;http://s3.us-east-1.amazonaws.com/&quot;; aws_authorization=true)

conf = (readtimeout = 10,
        pipeline_limit = 4,
        retry = false,
        redirect = false)

HTTP.get(&quot;http://httpbin.org/ip&quot;; conf..)
HTTP.put(&quot;http://httpbin.org/put&quot;, [], &quot;Hello&quot;; conf..)</code></pre><p>URL options</p><ul><li><p><code>query = nothing</code>, replaces the query part of <code>url</code>.</p></li></ul><p>Streaming options</p><ul><li><p><code>response_stream = nothing</code>, a writeable <code>IO</code> stream or any <code>IO</code>-like  type <code>T</code> for which <code>write(T, AbstractVector{UInt8})</code> is defined.</p></li><li><p><code>verbose = 0</code>, set to <code>1</code> or <code>2</code> for extra message logging.</p></li></ul><p>Connection Pool options</p><ul><li><p><code>connection_limit = 8</code>, number of concurrent connections to each host:port.</p></li><li><p><code>pipeline_limit = 16</code>, number of concurrent requests per connection.</p></li><li><p><code>reuse_limit = nolimit</code>, number of times a connection is reused after the                          first request.</p></li><li><p><code>socket_type = TCPSocket</code></p></li></ul><p>Timeout options</p><ul><li><p><code>readtimeout = 60</code>, close the connection if no data is recieved for this many seconds. Use <code>readtimeout = 0</code> to disable.</p></li></ul><p>Retry options</p><ul><li><p><code>retry = true</code>, retry idempotent requests in case of error.</p></li><li><p><code>retries = 4</code>, number of times to retry.</p></li><li><p><code>retry_non_idempotent = false</code>, retry non-idempotent requests too. e.g. POST.</p></li></ul><p>Redirect options</p><ul><li><p><code>redirect = true</code>, follow 3xx redirect responses.</p></li><li><p><code>redirect_limit = 3</code>, number of times to redirect.</p></li><li><p><code>forwardheaders = false</code>, forward original headers on redirect.</p></li></ul><p>Status Exception options</p><ul><li><p><code>status_exception = true</code>, throw <code>HTTP.StatusError</code> for response status &gt;= 300.</p></li></ul><p>SSLContext options</p><ul><li><p><code>require_ssl_verification = false</code>, pass <code>MBEDTLS_SSL_VERIFY_REQUIRED</code> to the mbed TLS library. <a href="https://tls.mbed.org/api/ssl_8h.html#a5695285c9dbfefec295012b566290f37">&quot;... peer must present a valid certificate, handshake is aborted if   verification failed.&quot;</a></p></li><li><p><code>sslconfig = SSLConfig(require_ssl_verification)</code></p></li></ul><p>Basic Authenticaiton options</p><ul><li><p>basic_authorization=false, add <code>Authorization: Basic</code> header using credentials from url userinfo.</p></li></ul><p>AWS Authenticaiton options</p><ul><li><p><code>aws_authorization = false</code>, enable AWS4 Authentication.</p></li><li><p><code>aws_service = split(url.host, &quot;.&quot;)[1]</code></p></li><li><p><code>aws_region = split(url.host, &quot;.&quot;)[2]</code></p></li><li><p><code>aws_access_key_id = ENV[&quot;AWS_ACCESS_KEY_ID&quot;]</code></p></li><li><p><code>aws_secret_access_key = ENV[&quot;AWS_SECRET_ACCESS_KEY&quot;]</code></p></li><li><p><code>aws_session_token = get(ENV, &quot;AWS_SESSION_TOKEN&quot;, &quot;&quot;)</code></p></li><li><p><code>body_sha256 = digest(MD_SHA256, body)</code>,</p></li><li><p><code>body_md5 = digest(MD_MD5, body)</code>,</p></li></ul><p>Cookie options</p><ul><li><p><code>cookies = false</code>, enable cookies.</p></li><li><p><code>cookiejar::Dict{String, Set{Cookie}}=default_cookiejar</code></p></li></ul><p>Cananoincalization options</p><ul><li><p><code>canonicalize_headers = false</code>, rewrite request and response headers in Canonical-Camel-Dash-Format.</p></li></ul><p><strong>Request Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)</code></pre><p>Stream body from file:</p><pre><code class="language-julia">io = open(&quot;post_data.txt&quot;, &quot;r&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], io)</code></pre><p>Generator body:</p><pre><code class="language-julia">chunks = (&quot;chunk$i&quot; for i in 1:1000)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p>Collection body:</p><pre><code class="language-julia">chunks = [preamble_chunk, data_chunk, checksum(data_chunk)]
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p><code>open() do io</code> body:</p><pre><code class="language-julia">HTTP.open(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;) do io
    write(io, preamble_chunk)
    write(io, data_chunk)
    write(io, checksum(data_chunk))
end</code></pre><p><strong>Response Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;)
println(String(r.body))</code></pre><p>Stream body to file:</p><pre><code class="language-julia">io = open(&quot;get_data.txt&quot;, &quot;w&quot;)
r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)
println(read(&quot;get_data.txt&quot;))</code></pre><p>Stream body through buffer:</p><pre><code class="language-julia">io = Base.BufferStream()
@async while !eof(io)
    bytes = readavailable(io))
    println(&quot;GET data: $bytes&quot;)
end
r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)</code></pre><p>Stream body through <code>open() do io</code>:</p><pre><code class="language-julia">r = HTTP.open(&quot;GET&quot;, &quot;http://httpbin.org/stream/10&quot;) do io
   while !eof(io)
       println(String(readavailable(io)))
   end
end

using HTTP.IOExtras

HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    n = 0
    r = startread(http)
    l = parse(Int, header(r, &quot;Content-Length&quot;))
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        while !eof(http)
            bytes = readavailable(http)
            write(vlc, bytes)
            n += length(bytes)
            println(&quot;streamed $n-bytes $((100*n)÷l)%\u1b[1A&quot;)
        end
    end
end</code></pre><p><strong>Request and Response Body Examples</strong></p><p>String bodies:</p><pre><code class="language-julia">r = HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)
println(String(r.body))</code></pre><p>Stream bodies from and to files:</p><pre><code class="language-julia">in = open(&quot;foo.png&quot;, &quot;r&quot;)
out = open(&quot;foo.jpg&quot;, &quot;w&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://convert.com/png2jpg&quot;, [], in, response_stream=out)</code></pre><p>Stream bodies through: <code>open() do io</code>:</p><pre><code class="language-julia">using HTTP.IOExtras

HTTP.open(&quot;POST&quot;, &quot;http://music.com/play&quot;) do io
    write(io, JSON.json([
        &quot;auth&quot; =&gt; &quot;12345XXXX&quot;,
        &quot;song_id&quot; =&gt; 7,
    ]))
    r = startread(io)
    @show r.status
    while !eof(io)
        bytes = readavailable(io))
        play_audio(bytes)
    end
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L30-L288">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.open" href="#HTTP.open"><code>HTTP.open</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.open(method, url, [,headers]) do io
    write(io, body)
    [startread(io) -&gt; HTTP.Response]
    while !eof(io)
        readavailable(io) -&gt; AbstractVector{UInt8}
    end
end -&gt; HTTP.Response</code></pre><p>The <code>HTTP.open</code> API allows the Request Body to be written to (and/or the Response Body to be read from) an <code>IO</code> stream.</p><p>e.g. Streaming an audio file to the <code>vlc</code> player:</p><pre><code class="language-julia">HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        write(vlc, http)
    end
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L306-L327">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.get" href="#HTTP.get"><code>HTTP.get</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.get(url [, headers]; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L331-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.put" href="#HTTP.put"><code>HTTP.put</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.put(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;PUT&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L339-L343">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.post" href="#HTTP.post"><code>HTTP.post</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.post(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;POST&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L346-L350">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.head" href="#HTTP.head"><code>HTTP.head</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.head(url; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;HEAD&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L353-L357">source</a></section><p>Request functions may throw the following exceptions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ExceptionRequest.StatusError" href="#HTTP.ExceptionRequest.StatusError"><code>HTTP.ExceptionRequest.StatusError</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The <code>Response</code> has a <code>4xx</code>, <code>5xx</code> or unrecognised status code.</p><p>Fields:</p><ul><li><p><code>status::Int16</code>, the response status code.</p></li><li><p><code>response</code> the <a href="index.html#HTTP.Messages.Response"><code>HTTP.Response</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ExceptionRequest.jl#L28-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.ParseError" href="#HTTP.Parsers.ParseError"><code>HTTP.Parsers.ParseError</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Parser input was invalid.</p><p>Fields:</p><ul><li><p><code>code</code>, error code</p></li><li><p><code>bytes</code>, the offending input.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Parsers.jl#L35-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.IOError" href="#HTTP.IOExtras.IOError"><code>HTTP.IOExtras.IOError</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The request terminated with due to an IO-related error.</p><p>Fields:</p><ul><li><p><code>e</code>, the error.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/IOExtras.jl#L47-L52">source</a></section><pre><code class="language-none">Sockets.DNSError</code></pre><h2><a class="nav-anchor" id="Server-/-Handlers-1" href="#Server-/-Handlers-1">Server / Handlers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Servers.listen" href="#HTTP.Servers.listen"><code>HTTP.Servers.listen</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.listen([host=&quot;localhost&quot; [, port=8081]]; &lt;keyword arguments&gt;) do http
    ...
end</code></pre><p>Listen for HTTP connections and execute the <code>do</code> function for each request.</p><p>Optional keyword arguments:</p><ul><li><p><code>ssl::Bool = false</code>, use https.</p></li><li><p><code>require_ssl_verification = true</code>, pass <code>MBEDTLS_SSL_VERIFY_REQUIRED</code> to the mbed TLS library. <a href="https://tls.mbed.org/api/ssl_8h.html#a5695285c9dbfefec295012b566290f37">&quot;... peer must present a valid certificate, handshake is aborted if   verification failed.&quot;</a></p></li><li><p><code>sslconfig = SSLConfig(require_ssl_verification)</code></p></li><li><p><code>pipeline_limit = 16</code>, number of concurrent requests per connection.</p></li><li><p><code>reuse_limit = nolimit</code>, number of times a connection is allowed to be reused                          after the first request.</p></li><li><p><code>tcpisvalid::Function (::TCPSocket) -&gt; Bool</code>, check accepted connection before  processing requests. e.g. to implement source IP filtering, rate-limiting,  etc.</p></li><li><p><code>tcpref::Ref{Sockets.TCPServer}</code>, this reference is set to the underlying                                <code>Sockets.TCPServer</code>. e.g. to allow closing the server.</p></li></ul><p>e.g.</p><pre><code class="language-none">    HTTP.listen() do http::HTTP.Stream
        @show http.message
        @show HTTP.header(http, &quot;Content-Type&quot;)
        while !eof(http)
            println(&quot;body data: &quot;, String(readavailable(http)))
        end
        setstatus(http, 404)
        setheader(http, &quot;Foo-Header&quot; =&gt; &quot;bar&quot;)
        startwrite(http)
        write(http, &quot;response body&quot;)
        write(http, &quot;more response body&quot;)
    end

    HTTP.listen() do request::HTTP.Request
        @show HTTP.header(request, &quot;Content-Type&quot;)
        @show HTTP.payload(request)
        return HTTP.Response(404)
    end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Servers.jl#L229-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Servers.serve" href="#HTTP.Servers.serve"><code>HTTP.Servers.serve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.serve([server,] host::IPAddr, port::Int; verbose::Bool=true, kwargs...)</code></pre><p>Start a server listening on the provided <code>host</code> and <code>port</code>. <code>verbose</code> indicates whether server activity should be logged. Optional keyword arguments allow construction of <code>Server</code> on the fly if the <code>server</code> argument isn&#39;t provided directly. See <code>?HTTP.Server</code> for more details on server construction and supported keyword arguments. By default, <code>HTTP.serve</code> aims to &quot;never die&quot;, catching and recovering from all internal errors. Two methods for stopping <code>HTTP.serve</code> include interrupting (ctrl/cmd+c) if blocking on the main task, or sending the kill signal via the server&#39;s in channel (<code>put!(server.in, HTTP.Servers.KILL)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Servers.jl#L185-L194">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Servers.Server" href="#HTTP.Servers.Server"><code>HTTP.Servers.Server</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Server(handler, logger::IO=stdout; kwargs...)</code></pre><p>An http/https server. Supports listening on a <code>host</code> and <code>port</code> via the <code>HTTP.serve(server, host, port)</code> function. <code>handler</code> is a function of the form <code>f(::Request, ::Response) -&gt; HTTP.Response</code>, i.e. it takes both a <code>Request</code> and pre-built <code>Response</code> objects as inputs and returns the, potentially modified, <code>Response</code>. <code>logger</code> indicates where logging output should be directed. When <code>HTTP.serve</code> is called, it aims to &quot;never die&quot;, catching and recovering from all internal errors. To forcefully stop, one can obviously kill the julia process, interrupt (ctrl/cmd+c) if main task, or send the kill signal over a server in channel like: <code>put!(server.in, HTTP.Servers.KILL)</code>.</p><p>Supported keyword arguments include:</p><ul><li><p><code>cert</code>: if https, the cert file to use, as passed to <code>HTTP.MbedTLS.SSLConfig(cert, key)</code></p></li><li><p><code>key</code>: if https, the key file to use, as passed to <code>HTTP.MbedTLS.SSLConfig(cert, key)</code></p></li><li><p><code>sslconfig</code>: pass in an already-constructed <code>HTTP.MbedTLS.SSLConfig</code> instance</p></li><li><p><code>readtimeout</code>: how long a client connection will be left open without receiving any bytes</p></li><li><p><code>ratelimit</code>: a <code>Rational{Int}</code> of the form <code>5//1</code> indicating how many <code>messages//second</code> should be allowed per client IP address; requests exceeding the rate limit will be dropped</p></li><li><p><code>support100continue</code>: a <code>Bool</code> indicating whether <code>Expect: 100-continue</code> headers should be supported for delayed request body sending; default = <code>true</code></p></li><li><p><code>logbody</code>: whether the Response body should be logged when <code>verbose=true</code> logging is enabled; default = <code>true</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Servers.jl#L73-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.Handler" href="#HTTP.Handlers.Handler"><code>HTTP.Handlers.Handler</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract type representing an object that knows how to &quot;handle&quot; a server request.</p><p>Types of handlers include <code>HandlerFunction</code> (a julia function of the form <code>f(request)</code> and <code>Router</code> (which pattern matches request url paths to other specific <code>Handler</code> types).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Handlers.jl#L17-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.HandlerFunction" href="#HTTP.Handlers.HandlerFunction"><code>HTTP.Handlers.HandlerFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><p>HandlerFunction(f::Function)</p><p>A Function-wrapper type that is a subtype of <code>Handler</code>. Takes a single Function as an argument. The provided argument should be of the form <code>f(request) =&gt; Response</code>, i.e. it accepts a <code>Request</code> returns a <code>Response</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Handlers.jl#L25-L30">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.Router" href="#HTTP.Handlers.Router"><code>HTTP.Handlers.Router</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Router(h::Handler) Router(f::Function) Router()</p><p>An <code>HTTP.Handler</code> type that supports mapping request url paths to other <code>HTTP.Handler</code> types. Can accept a default <code>Handler</code> or <code>Function</code> that will be used in case no other handlers match; by default, a 404 response handler is used. Paths can be mapped to a handler via <code>HTTP.register!(r::Router, path, handler)</code>, see <code>?HTTP.register!</code> for more details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Handlers.jl#L40-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.register!" href="#HTTP.Handlers.register!"><code>HTTP.Handlers.register!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>HTTP.register!(r::Router, url, handler) HTTP.register!(r::Router, m::String, url, handler)</p><p>Function to map request urls matching <code>url</code> and an optional method <code>m</code> to another <code>handler::HTTP.Handler</code>. URLs are registered one at a time, and multiple urls can map to the same handler. The URL can be passed as a String or <code>HTTP.URI</code> object directly. Requests can be routed based on: method, scheme, hostname, or path. The following examples show how various urls will direct how a request is routed by a server:</p><ul><li><p><code>&quot;http://*&quot;</code>: match all HTTP requests, regardless of path</p></li><li><p><code>&quot;https://*&quot;</code>: match all HTTPS requests, regardless of path</p></li><li><p><code>&quot;google&quot;</code>: regardless of scheme, match requests to the hostname &quot;google&quot;</p></li><li><p><code>&quot;google/gmail&quot;</code>: match requests to hostname &quot;google&quot;, and path starting with &quot;gmail&quot;</p></li><li><p><code>&quot;/gmail&quot;</code>: regardless of scheme or host, match any request with a path starting with &quot;gmail&quot;</p></li><li><p><code>&quot;/gmail/userId/*/inbox</code>: match any request matching the path pattern, &quot;*&quot; is used as a wildcard that matches any value between the two &quot;/&quot;</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Handlers.jl#L69-L85">source</a></section><h2><a class="nav-anchor" id="URIs-1" href="#URIs-1">URIs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.URI" href="#HTTP.URIs.URI"><code>HTTP.URIs.URI</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.URI(; scheme=&quot;&quot;, host=&quot;&quot;, port=&quot;&quot;, etc...)
HTTP.URI(str) = parse(HTTP.URI, str::String)</code></pre><p>A type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use <code>parse(HTTP.URI, str)</code> to parse the <code>HTTP.URI</code> directly. The <code>HTTP.URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>The <code>URI</code> struct stores the compelte URI in the <code>uri::String</code> field and the component parts in the following <code>SubString</code> fields:</p><ul><li><p><code>scheme</code>, e.g. <code>&quot;http&quot;</code> or <code>&quot;https&quot;</code></p></li><li><p><code>userinfo</code>, e.g. <code>&quot;username:password&quot;</code></p></li><li><p><code>host</code> e.g. <code>&quot;julialang.org&quot;</code></p></li><li><p><code>port</code> e.g. <code>&quot;80&quot;</code> or <code>&quot;&quot;</code></p></li><li><p><code>path</code> e.g <code>&quot;/&quot;</code></p></li><li><p><code>query</code> e.g. <code>&quot;Foo=1&amp;Bar=2&quot;</code></p></li><li><p><code>fragment</code></p></li></ul><p>The <code>HTTP.resource(::URI)</code> function returns a target-resource string for the URI <a href="https://tools.ietf.org/html/rfc7230#section-5.3">RFC7230 5.3</a>. e.g. <code>&quot;$path?$query#$fragment&quot;</code>.</p><p>The <code>HTTP.queryparams(::URI)</code> function returns a <code>Dict</code> containing the <code>query</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/URIs.jl#L23-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.escapeuri" href="#HTTP.URIs.escapeuri"><code>HTTP.URIs.escapeuri</code></a> — <span class="docstring-category">Function</span>.</div><div><p>percent-encode a string, dict, or pair for a uri</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/URIs.jl#L317">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.unescapeuri" href="#HTTP.URIs.unescapeuri"><code>HTTP.URIs.unescapeuri</code></a> — <span class="docstring-category">Function</span>.</div><div><p>unescape a percent-encoded uri/url</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/URIs.jl#L335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.splitpath" href="#HTTP.URIs.splitpath"><code>HTTP.URIs.splitpath</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Splits the path into components See: http://tools.ietf.org/html/rfc3986#section-3.3</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/URIs.jl#L357-L360">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{HTTP.URIs.URI}" href="#Base.isvalid-Tuple{HTTP.URIs.URI}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><p>checks if a <code>HTTP.URI</code> is valid</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/URIs.jl#L295">source</a></section><h2><a class="nav-anchor" id="Cookies-1" href="#Cookies-1">Cookies</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><p><code>name</code>: name of the cookie</p></li><li><p><code>value</code>: value of the cookie</p></li><li><p><code>path</code>: applicable path for the cookie</p></li><li><p><code>domain</code>: applicable domain for the cookie</p></li><li><p><code>expires</code>: a <code>Dates.DateTime</code> representing when the cookie should expire</p></li><li><p><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</p></li><li><p><code>secure::Bool</code>: secure cookie attribute</p></li><li><p><code>httponly::Bool</code>: httponly cookie attribute</p></li><li><p><code>hostonly::Bool</code>: hostonly cookie attribute</p></li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/cookies.jl#L50-L70">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.sniff" href="#HTTP.sniff"><code>HTTP.sniff</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>HTTP.sniff(content::Union{Vector{UInt8}, String, IO})</code> =&gt; <code>String</code> (mimetype)</p><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/sniff.jl#L21-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Strings.escapehtml" href="#HTTP.Strings.escapehtml"><code>HTTP.Strings.escapehtml</code></a> — <span class="docstring-category">Function</span>.</div><div><p>escapeHTML(i::String)</p><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Strings.jl#L8-L12">source</a></section><h1><a class="nav-anchor" id="HTTP.jl-Internal-Architecture-1" href="#HTTP.jl-Internal-Architecture-1">HTTP.jl Internal Architecture</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Layer" href="#HTTP.Layer"><code>HTTP.Layer</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Request Execution Stack</strong></p><p>The Request Execution Stack is separated into composable layers.</p><p>Each layer is defined by a nested type <code>Layer{Next}</code> where the <code>Next</code> parameter defines the next layer in the stack. The <code>request</code> method for each layer takes a <code>Layer{Next}</code> type as its first argument and dispatches the request to the next layer using <code>request(Next, ...)</code>.</p><p>The example below defines three layers and three stacks each with a different combination of layers.</p><pre><code class="language-julia">abstract type Layer end
abstract type Layer1{Next &lt;: Layer} &lt;: Layer end
abstract type Layer2{Next &lt;: Layer} &lt;: Layer end
abstract type Layer3 &lt;: Layer end

request(::Type{Layer1{Next}}, data) where Next = &quot;L1&quot;, request(Next, data)
request(::Type{Layer2{Next}}, data) where Next = &quot;L2&quot;, request(Next, data)
request(::Type{Layer3}, data) = &quot;L3&quot;, data

const stack1 = Layer1{Layer2{Layer3}}
const stack2 = Layer2{Layer1{Layer3}}
const stack3 = Layer1{Layer3}</code></pre><pre><code class="language-julia">julia&gt; request(stack1, &quot;foo&quot;)
(&quot;L1&quot;, (&quot;L2&quot;, (&quot;L3&quot;, &quot;foo&quot;)))

julia&gt; request(stack2, &quot;bar&quot;)
(&quot;L2&quot;, (&quot;L1&quot;, (&quot;L3&quot;, &quot;bar&quot;)))

julia&gt; request(stack3, &quot;boo&quot;)
(&quot;L1&quot;, (&quot;L3&quot;, &quot;boo&quot;))</code></pre><p>This stack definition pattern gives the user flexibility in how layers are combined but still allows Julia to do whole-stack comiple time optimistations.</p><p>e.g. the <code>request(stack1, &quot;foo&quot;)</code> call above is optimised down to a single function:</p><pre><code class="language-julia">julia&gt; code_typed(request, (Type{stack1}, String))[1].first
CodeInfo(:(begin
    return (Core.tuple)(&quot;L1&quot;, (Core.tuple)(&quot;L2&quot;, (Core.tuple)(&quot;L3&quot;, data)))
end))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L360-L413">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.stack" href="#HTTP.stack"><code>HTTP.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><p>The <code>stack()</code> function returns the default HTTP Layer-stack type. This type is passed as the first parameter to the <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{SubString{String},SubString{String}},1},Any}"><code>HTTP.request</code></a> function.</p><p><code>stack()</code> accepts optional keyword arguments to enable/disable specific layers in the stack: <code>request(method, args...; kw...) request(stack(;kw...), args...; kw...)</code></p><p>The minimal request execution stack is:</p><pre><code class="language-julia">stack = MessageLayer{ConnectionPoolLayer{StreamLayer}}</code></pre><p>The figure below illustrates the full request exection stack and its relationship with <a href="index.html#HTTP.Messages.Response"><code>HTTP.Response</code></a>, <a href="index.html#HTTP.Parsers"><code>HTTP.Parsers</code></a>, <a href="index.html#HTTP.Streams.Stream"><code>HTTP.Stream</code></a> and the <a href="index.html#HTTP.ConnectionPool"><code>HTTP.ConnectionPool</code></a>.</p><pre><code class="language-none"> ┌────────────────────────────────────────────────────────────────────────────┐
 │                                            ┌───────────────────┐           │
 │  HTTP.jl Request Execution Stack           │ HTTP.ParsingError ├ ─ ─ ─ ─ ┐ │
 │                                            └───────────────────┘           │
 │                                            ┌───────────────────┐         │ │
 │                                            │ HTTP.IOError      ├ ─ ─ ─     │
 │                                            └───────────────────┘      │  │ │
 │                                            ┌───────────────────┐           │
 │                                            │ HTTP.StatusError  │─ ─   │  │ │
 │                                            └───────────────────┘   │       │
 │                                            ┌───────────────────┐      │  │ │
 │     request(method, url, headers, body) -&gt; │ HTTP.Response     │   │       │
 │             ──────────────────────────     └─────────▲─────────┘      │  │ │
 │                           ║                          ║             │       │
 │   ┌────────────────────────────────────────────────────────────┐      │  │ │
 │   │ request(RedirectLayer,     method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(BasicAuthLayer,    method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(CookieLayer,       method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(CanonicalizeLayer, method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(MessageLayer,      method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(AWS4AuthLayer,             ::URI, ::Request, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(RetryLayer,                ::URI, ::Request, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(ExceptionLayer,            ::URI, ::Request, body) ├ ─ ┘       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
┌┼───┤ request(ConnectionPoolLayer,       ::URI, ::Request, body) ├ ─ ─ ─     │
││   ├────────────────────────────────────────────────────────────┤         │ │
││   │ request(TimeoutLayer,              ::IO,  ::Request, body) │           │
││   ├────────────────────────────────────────────────────────────┤         │ │
││   │ request(StreamLayer,               ::IO,  ::Request, body) │           │
││   └──────────────┬───────────────────┬─────────────────────────┘         │ │
│└──────────────────┼────────║──────────┼───────────────║─────────────────────┘
│                   │        ║          │               ║                   │  
│┌──────────────────▼───────────────┐   │  ┌──────────────────────────────────┐
││ HTTP.Request                     │   │  │ HTTP.Response                  │ │
││                                  │   │  │                                  │
││ method::String                   ◀───┼──▶ status::Int                    │ │
││ target::String                   │   │  │ headers::Vector{Pair}            │
││ headers::Vector{Pair}            │   │  │ body::Vector{UInt8}            │ │
││ body::Vector{UInt8}              │   │  │                                  │
│└──────────────────▲───────────────┘   │  └───────────────▲────────────────┼─┘
│┌──────────────────┴────────║──────────▼───────────────║──┴──────────────────┐
││ HTTP.Stream &lt;:IO          ║           ╔══════╗       ║                   │ │
││   ┌───────────────────────────┐       ║   ┌──▼─────────────────────────┐   │
││   │ startwrite(::Stream)      │       ║   │ startread(::Stream)        │ │ │
││   │ write(::Stream, body)     │       ║   │ read(::Stream) -&gt; body     │   │
││   │ ...                       │       ║   │ ...                        │ │ │
││   │ closewrite(::Stream)      │       ║   │ closeread(::Stream)        │   │
││   └───────────────────────────┘       ║   └────────────────────────────┘ │ │
│└───────────────────────────║────────┬──║──────║───────║──┬──────────────────┘
│┌──────────────────────────────────┐ │  ║ ┌────▼───────║──▼────────────────┴─┐
││ HTTP.Messages                    │ │  ║ │ HTTP.Parsers                     │
││                                  │ │  ║ │                                  │
││ writestartline(::IO, ::Request)  │ │  ║ │ parse_status_line(bytes, ::Req&#39;) │
││ writeheaders(::IO, ::Request)    │ │  ║ │ parse_header_field(bytes, ::Req&#39;)│
│└──────────────────────────────────┘ │  ║ └──────────────────────────────────┘
│                            ║        │  ║                                     
│┌───────────────────────────║────────┼──║────────────────────────────────────┐
└▶ HTTP.ConnectionPool       ║        │  ║                                    │
 │                     ┌──────────────▼────────┐ ┌───────────────────────┐    │
 │ getconnection() -&gt;  │ HTTP.Transaction &lt;:IO │ │ HTTP.Transaction &lt;:IO │    │
 │                     └───────────────────────┘ └───────────────────────┘    │
 │                           ║    ╲│╱    ║                  ╲│╱               │
 │                           ║     │     ║                   │                │
 │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │
 │              pool: [│ HTTP.Connection       │,│ HTTP.Connection       │...]│
 │                     └───────────┬───────────┘ └───────────┬───────────┘    │
 │                           ║     │     ║                   │                │
 │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │
 │                     │ Base.TCPSocket &lt;:IO   │ │MbedTLS.SSLContext &lt;:IO│    │
 │                     └───────────────────────┘ └───────────┬───────────┘    │
 │                           ║           ║                   │                │
 │                           ║           ║       ┌───────────▼───────────┐    │
 │                           ║           ║       │ Base.TCPSocket &lt;:IO   │    │
 │                           ║           ║       └───────────────────────┘    │
 └───────────────────────────║───────────║────────────────────────────────────┘
                             ║           ║                                     
 ┌───────────────────────────║───────────║──────────────┐  ┏━━━━━━━━━━━━━━━━━━┓
 │ HTTP Server               ▼                          │  ┃ data flow: ════▶ ┃
 │                        Request     Response          │  ┃ reference: ────▶ ┃
 └──────────────────────────────────────────────────────┘  ┗━━━━━━━━━━━━━━━━━━┛</code></pre><p><em>See <code>docs/src/layers</code><a href="http://monodraw.helftone.com"><code>.monopic</code></a>.</em></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/HTTP.jl#L430-L539">source</a></section><h2><a class="nav-anchor" id="Request-Execution-Layers-1" href="#Request-Execution-Layers-1">Request Execution Layers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RedirectRequest.RedirectLayer" href="#HTTP.RedirectRequest.RedirectLayer"><code>HTTP.RedirectRequest.RedirectLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(RedirectLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Redirects the request in the case of 3xx response status.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/RedirectRequest.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.BasicAuthRequest.BasicAuthLayer" href="#HTTP.BasicAuthRequest.BasicAuthLayer"><code>HTTP.BasicAuthRequest.BasicAuthLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(BasicAuthLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Add <code>Authorization: Basic</code> header using credentials from url userinfo.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/BasicAuthRequest.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.CookieRequest.CookieLayer" href="#HTTP.CookieRequest.CookieLayer"><code>HTTP.CookieRequest.CookieLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(CookieLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Add locally stored Cookies to the request headers. Store new Cookies found in the response headers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/CookieRequest.jl#L12-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.CanonicalizeRequest.CanonicalizeLayer" href="#HTTP.CanonicalizeRequest.CanonicalizeLayer"><code>HTTP.CanonicalizeRequest.CanonicalizeLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(CanonicalizeLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Rewrite request and response headers in Canonical-Camel-Dash-Format.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/CanonicalizeRequest.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.MessageRequest.MessageLayer" href="#HTTP.MessageRequest.MessageLayer"><code>HTTP.MessageRequest.MessageLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(MessageLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Construct a <a href="index.html#HTTP.Messages.Request"><code>Request</code></a> object and set mandatory headers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/MessageRequest.jl#L14-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.AWS4AuthRequest.AWS4AuthLayer" href="#HTTP.AWS4AuthRequest.AWS4AuthLayer"><code>HTTP.AWS4AuthRequest.AWS4AuthLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(AWS4AuthLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Add a <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">AWS Signature Version 4</a> <code>Authorization</code> header to a <code>Request</code>.</p><p>Credentials are read from environment variables <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code> and <code>AWS_SESSION_TOKEN</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/AWS4AuthRequest.jl#L11-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RetryRequest.RetryLayer" href="#HTTP.RetryRequest.RetryLayer"><code>HTTP.RetryRequest.RetryLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(RetryLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Retry the request if it throws a recoverable exception.</p><p><code>Base.retry</code> and <code>Base.ExponentialBackOff</code> implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.</p><p>Methods of <code>isrecoverable(e)</code> define which exception types lead to a retry. e.g. <code>HTTP.IOError</code>, <code>Sockets.DNSError</code>, <code>Base.EOFError</code> and <code>HTTP.StatusError</code> (if status is `<code>5xx</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/RetryRequest.jl#L11-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ExceptionRequest.ExceptionLayer" href="#HTTP.ExceptionRequest.ExceptionLayer"><code>HTTP.ExceptionRequest.ExceptionLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(ExceptionLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Throw a <code>StatusError</code> if the request returns an error response status.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ExceptionRequest.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionRequest.ConnectionPoolLayer" href="#HTTP.ConnectionRequest.ConnectionPoolLayer"><code>HTTP.ConnectionRequest.ConnectionPoolLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(ConnectionPoolLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Retrieve an <code>IO</code> connection from the <a href="index.html#HTTP.ConnectionPool"><code>ConnectionPool</code></a>.</p><p>Close the connection if the request throws an exception. Otherwise leave it open so that it can be reused.</p><p><code>IO</code> related exceptions from <code>Base</code> are wrapped in <code>HTTP.IOError</code>. See <a href="index.html#HTTP.IOExtras.isioerror"><code>isioerror</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionRequest.jl#L11-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.TimeoutRequest.TimeoutLayer" href="#HTTP.TimeoutRequest.TimeoutLayer"><code>HTTP.TimeoutRequest.TimeoutLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(TimeoutLayer, ::IO, ::Request, body) -&gt; HTTP.Response</code></pre><p>Close <code>IO</code> if no data has been received for <code>timeout</code> seconds.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/TimeoutRequest.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.StreamRequest.StreamLayer" href="#HTTP.StreamRequest.StreamLayer"><code>HTTP.StreamRequest.StreamLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(StreamLayer, ::IO, ::Request, body) -&gt; HTTP.Response</code></pre><p>Create a <a href="index.html#HTTP.Streams.Stream"><code>Stream</code></a> to send a <code>Request</code> and <code>body</code> to an <code>IO</code> stream and read the response.</p><p>Send the <code>Request</code> body in a background task and begins reading the response immediately so that the transmission can be aborted if the <code>Response</code> status indicates that the server does not wish to receive the message body. <a href="https://tools.ietf.org/html/rfc7230#section-6.5">RFC7230 6.5</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/StreamRequest.jl#L11-L21">source</a></section><h2><a class="nav-anchor" id="Parser-1" href="#Parser-1">Parser</a></h2><p><em>Source: <code>Parsers.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers" href="#HTTP.Parsers"><code>HTTP.Parsers</code></a> — <span class="docstring-category">Module</span>.</div><div><p>The parser separates a raw HTTP Message into its component parts.</p><p>If the input data is invalid the Parser throws a <code>HTTP.ParseError</code>.</p><p>The <code>parse_*</code> functions processes a single element of a HTTP Message at a time and return a <code>SubString</code> containing the unused portion of the input.</p><p>The Parser does not interpret the Message Headers. It is beyond the scope of the Parser to deal with repeated header fields, multi-line values, cookies or case normalization.</p><p>The Parser has no knowledge of the high-level <code>Request</code> and <code>Response</code> structs defined in <code>Messages.jl</code>. However, the <code>Request</code> and <code>Response</code> structs must have field names compatible with those expected by the <code>parse_status_line!</code> and <code>parse_request_line!</code> functions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Parsers.jl#L1-L17">source</a></section><h2><a class="nav-anchor" id="Messages-1" href="#Messages-1">Messages</a></h2><p><em>Source: <code>Messages.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages" href="#HTTP.Messages"><code>HTTP.Messages</code></a> — <span class="docstring-category">Module</span>.</div><div><p>The <code>Messages</code> module defines structs that represent <a href="index.html#HTTP.Messages.Request"><code>HTTP.Request</code></a> and <a href="index.html#HTTP.Messages.Response"><code>HTTP.Response</code></a> Messages.</p><p>The <code>Response</code> struct has a <code>request</code> field that points to the corresponding <code>Request</code>; and the <code>Request</code> struct has a <code>response</code> field. The <code>Request</code> struct also has a <code>parent</code> field that points to a <code>Response</code> in the case of HTTP Redirect.</p><p>The Messages module defines <code>IO</code> <code>read</code> and <code>write</code> methods for Messages but it does not deal with URIs, creating connections, or executing requests.</p><p>The <code>read</code> methods throw <code>EOFError</code> exceptions if input data is incomplete. and call parser functions that may throw <code>HTTP.ParsingError</code> exceptions. The <code>read</code> and <code>write</code> methods may also result in low level <code>IO</code> exceptions.</p><p><strong>Sending Messages</strong></p><p>Messages are formatted and written to an <code>IO</code> stream by <a href="index.html#Base.write-Tuple{IO,HTTP.Messages.Message}"><code>Base.write(::IO,::HTTP.Messages.Message)</code></a> and or <a href="index.html#HTTP.Messages.writeheaders"><code>HTTP.Messages.writeheaders</code></a>.</p><p><strong>Receiving Messages</strong></p><p>Messages are parsed from <code>IO</code> stream data by <a href="index.html#HTTP.Messages.readheaders"><code>HTTP.Messages.readheaders</code></a>. This function calls <a href="index.html#HTTP.Parsers.parse_header_field"><code>HTTP.Parsers.parse_header_field</code></a> and passes each header-field to <a href="index.html#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a>.</p><p><code>readheaders</code> relies on <a href="index.html#HTTP.IOExtras.unread!"><code>HTTP.IOExtras.unread!</code></a> to push excess data back to the input stream.</p><p><strong>Headers</strong></p><p>Headers are represented by <code>Vector{Pair{String,String}}</code>. As compared to <code>Dict{String,String}</code> this allows <a href="https://tools.ietf.org/html/rfc7230#section-3.2.2">repeated header fields and preservation of order</a>.</p><p>Header values can be accessed by name using <a href="index.html#HTTP.Messages.header"><code>HTTP.Messages.header</code></a> and <a href="index.html#HTTP.Messages.setheader"><code>HTTP.Messages.setheader</code></a> (case-insensitive).</p><p>The <a href="index.html#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a> function handles combining multi-line values, repeated header fields and special handling of multiple <code>Set-Cookie</code> headers.</p><p><strong>Bodies</strong></p><p>The <code>HTTP.Message</code> structs represent the Message Body as <code>Vector{UInt8}</code>.</p><p>Streaming of request and response bodies is handled by the <a href="index.html#HTTP.StreamRequest.StreamLayer"><code>HTTP.StreamLayer</code></a> and the <a href="index.html#HTTP.Streams.Stream"><code>HTTP.Stream</code></a> <code>&lt;: IO</code> stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L1-L57">source</a></section><h2><a class="nav-anchor" id="Streams-1" href="#Streams-1">Streams</a></h2><p><em>Source: <code>Streams.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Streams.Stream" href="#HTTP.Streams.Stream"><code>HTTP.Streams.Stream</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Stream(::IO, ::Request)</code></pre><p>Creates a <code>HTTP.Stream</code> that wraps an existing <code>IO</code> stream.</p><ul><li><p><code>startwrite(::Stream)</code> sends the <code>Request</code> headers to the <code>IO</code> stream.</p></li><li><p><code>write(::Stream, body)</code> sends the <code>body</code> (or a chunk of the body).</p></li><li><p><code>closewrite(::Stream)</code> sends the final <code>0</code> chunk (if needed) and calls <code>closewrite</code> on the <code>IO</code> stream. When the <code>IO</code> stream is a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>, calling <code>closewrite</code> releases the <a href="index.html#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a> back into the pool for use by the next pipelined request.</p></li><li><p><code>startread(::Stream)</code> calls <code>startread</code> on the <code>IO</code> stream then  reads and parses the <code>Response</code> headers.  When the <code>IO</code> stream is a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>, calling <code>startread</code> waits for other pipelined responses to be read from the <a href="index.html#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a>.</p></li><li><p><code>eof(::Stream)</code> and <code>readavailable(::Stream)</code> parse the body from the <code>IO</code>  stream.</p></li><li><p><code>closeread(::Stream)</code> reads the trailers and calls <code>closeread</code> on the <code>IO</code>  stream.  When the <code>IO</code> stream is a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>,  calling <code>closeread</code> releases the readlock and allows the next pipelined  response to be read by another <code>Stream</code> that is waiting in <code>startread</code>.  If a complete response has not been recieved, <code>closeread</code> throws <code>EOFError</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Streams.jl#L27-L51">source</a></section><h2><a class="nav-anchor" id="Connections-1" href="#Connections-1">Connections</a></h2><p><em>Source: <code>ConnectionPool.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool" href="#HTTP.ConnectionPool"><code>HTTP.ConnectionPool</code></a> — <span class="docstring-category">Module</span>.</div><div><p>This module provides the <a href="index.html#HTTP.ConnectionPool.getconnection"><code>getconnection</code></a> function with support for:</p><ul><li><p>Opening TCP and SSL connections.</p></li><li><p>Reusing connections for multiple Request/Response Messages,</p></li><li><p>Pipelining Request/Response Messages. i.e. allowing a new Request to be sent before previous Responses have been read.</p></li></ul><p>This module defines a <a href="index.html#HTTP.ConnectionPool.Connection"><code>Connection</code></a> struct to manage pipelining and connection reuse and a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>Transaction</code></a><code>&lt;: IO</code> struct to manage a single pipelined request. Methods are provided for <code>eof</code>, <code>readavailable</code>, <code>unsafe_write</code> and <code>close</code>. This allows the <code>Transaction</code> object to act as a proxy for the <code>TCPSocket</code> or <code>SSLContext</code> that it wraps.</p><p>The <a href="index.html#HTTP.ConnectionPool.pool"><code>pool</code></a> is a collection of open <code>Connection</code>s.  The <code>request</code> function calls <code>getconnection</code> to retrieve a connection from the <code>pool</code>.  When the <code>request</code> function has written a Request Message it calls <code>closewrite</code> to signal that the <code>Connection</code> can be reused for writing (to send the next Request). When the <code>request</code> function has read the Response Message it calls <code>closeread</code> to signal that the <code>Connection</code> can be reused for reading.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L1-L24">source</a></section><h1><a class="nav-anchor" id="Internal-Interfaces-1" href="#Internal-Interfaces-1">Internal Interfaces</a></h1><h2><a class="nav-anchor" id="Parser-Interface-1" href="#Parser-Interface-1">Parser Interface</a></h2><pre><code class="language-none">HTTP.Parsers.find_end_of_header
HTTP.Parsers.find_end_of_line
HTTP.Parsers.find_end_of_trailer
HTTP.Parsers.parse_status_line!
HTTP.Parsers.parse_request_line!
HTTP.Parsers.parse_header_field
HTTP.Parsers.parse_chunk_size</code></pre><h2><a class="nav-anchor" id="Messages-Interface-1" href="#Messages-Interface-1">Messages Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.Request" href="#HTTP.Messages.Request"><code>HTTP.Messages.Request</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Request &lt;: Message</code></pre><p>Represents a HTTP Request Message.</p><ul><li><p><code>method::String</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">RFC7230 3.1.1</a></p></li><li><p><code>target::String</code>  <a href="https://tools.ietf.org/html/rfc7230#section-5.3">RFC7230 5.3</a></p></li><li><p><code>version::VersionNumber</code>  <a href="https://tools.ietf.org/html/rfc7230#section-2.6">RFC7230 2.6</a></p></li><li><p><code>headers::Vector{Pair{String,String}}</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.2">RFC7230 3.2</a></p></li><li><p><code>body::Vector{UInt8}</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.3">RFC7230 3.3</a></p></li><li><p><code>response</code>, the <code>Response</code> to this <code>Request</code></p></li><li><p><code>txcount</code>, number of times this <code>Request</code> has been sent (see RetryRequest.jl).</p></li><li><p><code>parent</code>, the <code>Response</code> (if any) that led to this request (e.g. in the case of a redirect).  <a href="https://tools.ietf.org/html/rfc7231#section-6.4">RFC7230 6.4</a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L158-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.Response" href="#HTTP.Messages.Response"><code>HTTP.Messages.Response</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Response &lt;: Message</code></pre><p>Represents a HTTP Response Message.</p><ul><li><p><code>version::VersionNumber</code>  <a href="https://tools.ietf.org/html/rfc7230#section-2.6">RFC7230 2.6</a></p></li><li><p><code>status::Int16</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">RFC7230 3.1.2</a>  <a href="https://tools.ietf.org/html/rfc7231#section-6">RFC7231 6</a></p></li><li><p><code>headers::Vector{Pair{String,String}}</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.2">RFC7230 3.2</a></p></li><li><p><code>body::Vector{UInt8}</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.3">RFC7230 3.3</a></p></li><li><p><code>request</code>, the <code>Request</code> that yielded this <code>Response</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L85-L104">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.iserror" href="#HTTP.Messages.iserror"><code>HTTP.Messages.iserror</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">iserror(::Response)</code></pre><p>Does this <code>Response</code> have an error status?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L237-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.isredirect" href="#HTTP.Messages.isredirect"><code>HTTP.Messages.isredirect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isredirect(::Response)</code></pre><p>Does this <code>Response</code> have a redirect status?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L245-L249">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.ischunked" href="#HTTP.Messages.ischunked"><code>HTTP.Messages.ischunked</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ischunked(::Message)</code></pre><p>Does the <code>Message</code> have a &quot;Transfer-Encoding: chunked&quot; header?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L252-L256">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.issafe" href="#HTTP.Messages.issafe"><code>HTTP.Messages.issafe</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">issafe(::Request)</code></pre><p>https://tools.ietf.org/html/rfc7231#section-4.2.1</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L223-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.isidempotent" href="#HTTP.Messages.isidempotent"><code>HTTP.Messages.isidempotent</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isidempotent(::Request)</code></pre><p>https://tools.ietf.org/html/rfc7231#section-4.2.2</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L230-L234">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.header" href="#HTTP.Messages.header"><code>HTTP.Messages.header</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">header(::Message, key [, default=&quot;&quot;]) -&gt; String</code></pre><p>Get header value for <code>key</code> (case-insensitive).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L301-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.hasheader" href="#HTTP.Messages.hasheader"><code>HTTP.Messages.hasheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hasheader(::Message, key) -&gt; Bool</code></pre><p>Does header value for <code>key</code> exist (case-insensitive)?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L317-L321">source</a><div><pre><code class="language-none">hasheader(::Message, key, value) -&gt; Bool</code></pre><p>Does header for <code>key</code> match <code>value</code> (both case-insensitive)?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L324-L328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.setheader" href="#HTTP.Messages.setheader"><code>HTTP.Messages.setheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setheader(::Message, key =&gt; value)</code></pre><p>Set header <code>value</code> for <code>key</code> (case-insensitive).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L332-L336">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.defaultheader" href="#HTTP.Messages.defaultheader"><code>HTTP.Messages.defaultheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">defaultheader(::Message, key =&gt; value)</code></pre><p>Set header <code>value</code> for <code>key</code> if it is not already set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L342-L346">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.appendheader" href="#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">appendheader(::Message, key =&gt; value)</code></pre><p>Append a header value to <code>message.headers</code>.</p><p>If <code>key</code> is <code>&quot;&quot;</code> the <code>value</code> is appended to the value of the previous header.</p><p>If <code>key</code> is the same as the previous header, the <code>value</code> is <a href="https://stackoverflow.com/a/24502264">appended to the value of the previous header with a comma delimiter</a></p><p><code>Set-Cookie</code> headers are not comma-combined because <a href="https://tools.ietf.org/html/rfc6265#section-3">cookies often contain internal commas</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L354-L367">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.readheaders" href="#HTTP.Messages.readheaders"><code>HTTP.Messages.readheaders</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readheaders(::IO, ::Message)</code></pre><p>Read headers (and startline) from an <code>IO</code> stream into a <code>Message</code> struct. Throw <code>EOFError</code> if input is incomplete.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L461-L466">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.readchunksize" href="#HTTP.Messages.readchunksize"><code>HTTP.Messages.readchunksize</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Read chunk-size from an <code>IO</code> stream. After the final zero size chunk, read trailers into a <code>Message</code> struct.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L488-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}" href="#HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}"><code>HTTP.Messages.headerscomplete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">headerscomplete(::Message)</code></pre><p>Have the headers been read into this <code>Message</code>?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L261-L265">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.writestartline" href="#HTTP.Messages.writestartline"><code>HTTP.Messages.writestartline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writestartline(::IO, ::Message)</code></pre><p>e.g. <code>&quot;GET /path HTTP/1.1\r\n&quot;</code> or <code>&quot;HTTP/1.1 200 OK\r\n&quot;</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L412-L416">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.writeheaders" href="#HTTP.Messages.writeheaders"><code>HTTP.Messages.writeheaders</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writeheaders(::IO, ::Message)</code></pre><p>Write <code>Message</code> start line and a line for each &quot;name: value&quot; pair and a trailing blank line.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L427-L432">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.write-Tuple{IO,HTTP.Messages.Message}" href="#Base.write-Tuple{IO,HTTP.Messages.Message}"><code>Base.write</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">write(::IO, ::Message)</code></pre><p>Write start line, headers and body of HTTP Message.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Messages.jl#L442-L446">source</a></section><h2><a class="nav-anchor" id="IOExtras-Interface-1" href="#IOExtras-Interface-1">IOExtras Interface</a></h2><pre><code class="language-none">HTTP.IOExtras
HTTP.IOExtras.unread!
HTTP.IOExtras.startwrite(::IO)
HTTP.IOExtras.isioerror</code></pre><h2><a class="nav-anchor" id="Streams-Interface-1" href="#Streams-Interface-1">Streams Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Streams.closebody" href="#HTTP.Streams.closebody"><code>HTTP.Streams.closebody</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">closebody(::Stream)</code></pre><p>Write the final <code>0</code> chunk if needed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Streams.jl#L99-L103">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Streams.isaborted" href="#HTTP.Streams.isaborted"><code>HTTP.Streams.isaborted</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isaborted(::Stream{Response})</code></pre><p>Has the server signaled that it does not wish to receive the message body?</p><p>&quot;If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.&quot; <a href="https://tools.ietf.org/html/rfc7230#section-6.5">RFC7230, 6.5</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/Streams.jl#L234-L243">source</a></section><h2><a class="nav-anchor" id="Connection-Pooling-Interface-1" href="#Connection-Pooling-Interface-1">Connection Pooling Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.Connection" href="#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Connection{T &lt;: IO}</code></pre><p>A <code>TCPSocket</code> or <code>SSLContext</code> connection to a HTTP <code>host</code> and <code>port</code>.</p><p>Fields:</p><ul><li><p><code>host::String</code></p></li><li><p><code>port::String</code>, exactly as specified in the URI (i.e. may be empty).</p></li><li><p><code>pipeline_limit</code>, number of requests to send before waiting for responses.</p></li><li><p><code>peerport</code>, remote TCP port number (used for debug messages).</p></li><li><p><code>localport</code>, local TCP port number (used for debug messages).</p></li><li><p><code>io::T</code>, the <code>TCPSocket</code> or `SSLContext.</p></li><li><p><code>excess::ByteView</code>, left over bytes read from the connection after  the end of a response message. These bytes are probably the start of the  next response message.</p></li><li><p><code>sequence</code>, number of most recent <code>Transaction</code>.</p></li><li><p><code>writecount</code>, number of Messages that have been written.</p></li><li><p><code>writedone</code>, signal that <code>writecount</code> was incremented.</p></li><li><p><code>readcount</code>, number of Messages that have been read.</p></li><li><p><code>readdone</code>, signal that <code>readcount</code> was incremented.</p></li><li><p><code>timestamp</code>, time data was last recieved.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L45-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.Transaction" href="#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A single pipelined HTTP Request/Response transaction`.</p><p>Fields:</p><ul><li><p><code>c</code>, the shared <a href="index.html#HTTP.ConnectionPool.Connection"><code>Connection</code></a> used for this <code>Transaction</code>.</p></li><li><p><code>sequence::Int</code>, identifies this <code>Transaction</code> among the others that share <code>c</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L85-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.pool" href="#HTTP.ConnectionPool.pool"><code>HTTP.ConnectionPool.pool</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>The <code>pool</code> is a collection of open <code>Connection</code>s.  The <code>request</code> function calls <code>getconnection</code> to retrieve a connection from the <code>pool</code>.  When the <code>request</code> function has written a Request Message it calls <code>closewrite</code> to signal that the <code>Connection</code> can be reused for writing (to send the next Request). When the <code>request</code> function has read the Response Message it calls <code>closeread</code> to signal that the <code>Connection</code> can be reused for reading.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L295-L303">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.getconnection" href="#HTTP.ConnectionPool.getconnection"><code>HTTP.ConnectionPool.getconnection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconnection(type, host, port) -&gt; Connection</code></pre><p>Find a reusable <code>Connection</code> in the <code>pool</code>, or create a new <code>Connection</code> if required.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L392-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.unread!-Tuple{HTTP.ConnectionPool.Transaction,SubArray{UInt8,1,Array{UInt8,1},Tuple{UnitRange{Int64}},true}}" href="#HTTP.IOExtras.unread!-Tuple{HTTP.ConnectionPool.Transaction,SubArray{UInt8,1,Array{UInt8,1},Tuple{UnitRange{Int64}},true}}"><code>HTTP.IOExtras.unread!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">unread!(::Transaction, bytes)</code></pre><p>Push bytes back into a connection&#39;s <code>excess</code> buffer (to be returned by the next read).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L178-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.startwrite-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.startwrite-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.startwrite</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">startwrite(::Transaction)</code></pre><p>Wait for prior pending writes to complete.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L192-L196">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.closewrite-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.closewrite-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.closewrite</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">closewrite(::Transaction)</code></pre><p>Signal that an entire Request Message has been written to the <code>Transaction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L208-L212">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.startread-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.startread-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.startread</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">startread(::Transaction)</code></pre><p>Wait for prior pending reads to complete.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L225-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.closeread-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.closeread-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.closeread</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">closeread(::Transaction)</code></pre><p>Signal that an entire Response Message has been read from the <code>Transaction</code>.</p><p>Increment <code>readcount</code> and wake up tasks waiting in <code>startread</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/cb2cef20a24eac7d879c26b86f1bd8f2e7bc61ec/src/ConnectionPool.jl#L242-L248">source</a></section><footer><hr/></footer></article></body></html>
