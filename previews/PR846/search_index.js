var documenterSearchIndex = {"docs":
[{"location":"internal_interface/#Internal-Interfaces","page":"Internal Interfaces","title":"Internal Interfaces","text":"","category":"section"},{"location":"internal_interface/#Parser-Interface","page":"Internal Interfaces","title":"Parser Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Parsers.find_end_of_header\nHTTP.Parsers.find_end_of_chunk_size\nHTTP.Parsers.find_end_of_trailer\nHTTP.Parsers.parse_status_line!\nHTTP.Parsers.parse_request_line!\nHTTP.Parsers.parse_header_field\nHTTP.Parsers.parse_chunk_size","category":"page"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_header","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_header","text":"find_end_of_header(bytes) -> length or 0\n\nFind length of header delimited by \\r\\n\\r\\n or \\n\\n.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_chunk_size","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_chunk_size","text":"Find \\n after chunk size in bytes.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_trailer","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_trailer","text":"find_end_of_trailer(bytes) -> length or 0\n\nFind length of trailer delimited by \\r\\n\\r\\n (or starting with \\r\\n). RFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_status_line!","page":"Internal Interfaces","title":"HTTP.Parsers.parse_status_line!","text":"Parse HTTP response-line bytes and set the status and version fields of response. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_request_line!","page":"Internal Interfaces","title":"HTTP.Parsers.parse_request_line!","text":"Parse HTTP request-line bytes and set the method, target and version fields of request. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_header_field","page":"Internal Interfaces","title":"HTTP.Parsers.parse_header_field","text":"Parse HTTP header-field. Return Pair(field-name => field-value) and a SubString containing the remaining header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_chunk_size","page":"Internal Interfaces","title":"HTTP.Parsers.parse_chunk_size","text":"Parse HTTP chunk-size. Return number of bytes of chunk-data.\n\nchunk-size = 1*HEXDIG\n\nRFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Messages-Interface","page":"Internal Interfaces","title":"Messages Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Messages.iserror\nHTTP.Messages.isredirect\nHTTP.Messages.ischunked\nHTTP.Messages.issafe\nHTTP.Messages.isidempotent\nHTTP.Messages.header\nHTTP.Messages.hasheader\nHTTP.Messages.setheader\nHTTP.Messages.defaultheader!\nHTTP.Messages.appendheader\nHTTP.Messages.readheaders\nHTTP.MessageRequest.setuseragent!\nHTTP.Messages.readchunksize\nHTTP.Messages.headerscomplete(::HTTP.Messages.Response)\nHTTP.Messages.writestartline\nHTTP.Messages.writeheaders\nBase.write(::IO,::HTTP.Messages.Message)","category":"page"},{"location":"internal_interface/#HTTP.Messages.iserror","page":"Internal Interfaces","title":"HTTP.Messages.iserror","text":"iserror(::Response)\n\nDoes this Response have an error status?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.isredirect","page":"Internal Interfaces","title":"HTTP.Messages.isredirect","text":"isredirect(::Response)\n\nDoes this Response have a redirect status?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.ischunked","page":"Internal Interfaces","title":"HTTP.Messages.ischunked","text":"ischunked(::Message)\n\nDoes the Message have a \"Transfer-Encoding: chunked\" header?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.issafe","page":"Internal Interfaces","title":"HTTP.Messages.issafe","text":"issafe(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.isidempotent","page":"Internal Interfaces","title":"HTTP.Messages.isidempotent","text":"isidempotent(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.2\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.header","page":"Internal Interfaces","title":"HTTP.Messages.header","text":"HTTP.header(::Message, key [, default=\"\"]) -> String\n\nGet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.hasheader","page":"Internal Interfaces","title":"HTTP.Messages.hasheader","text":"HTTP.hasheader(::Message, key) -> Bool\n\nDoes header value for key exist (case-insensitive)?\n\n\n\n\n\nHTTP.hasheader(::Message, key, value) -> Bool\n\nDoes header for key match value (both case-insensitive)?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.setheader","page":"Internal Interfaces","title":"HTTP.Messages.setheader","text":"HTTP.setheader(::Message, key => value)\n\nSet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.defaultheader!","page":"Internal Interfaces","title":"HTTP.Messages.defaultheader!","text":"defaultheader!(::Message, key => value)\n\nSet header value in message for key if it is not already set.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.appendheader","page":"Internal Interfaces","title":"HTTP.Messages.appendheader","text":"HTTP.appendheader(::Message, key => value)\n\nAppend a header value to message.headers.\n\nIf key is the same as the previous header, the value is appended to the value of the previous header with a comma delimiter\n\nSet-Cookie headers are not comma-combined because cookies often contain internal commas.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.readheaders","page":"Internal Interfaces","title":"HTTP.Messages.readheaders","text":"readheaders(::IO, ::Message)\n\nRead headers (and startline) from an IO stream into a Message struct. Throw EOFError if input is incomplete.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.readchunksize","page":"Internal Interfaces","title":"HTTP.Messages.readchunksize","text":"Read chunk-size from an IO stream. After the final zero size chunk, read trailers into a Message struct.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}","page":"Internal Interfaces","title":"HTTP.Messages.headerscomplete","text":"headerscomplete(::Message)\n\nHave the headers been read into this Message?\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.Messages.writestartline","page":"Internal Interfaces","title":"HTTP.Messages.writestartline","text":"writestartline(::IO, ::Message)\n\ne.g. \"GET /path HTTP/1.1\\r\\n\" or \"HTTP/1.1 200 OK\\r\\n\"\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.writeheaders","page":"Internal Interfaces","title":"HTTP.Messages.writeheaders","text":"writeheaders(::IO, ::Message)\n\nWrite Message start line and a line for each \"name: value\" pair and a trailing blank line.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Base.write-Tuple{IO, HTTP.Messages.Message}","page":"Internal Interfaces","title":"Base.write","text":"write(::IO, ::Message)\n\nWrite start line, headers and body of HTTP Message.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#IOExtras-Interface","page":"Internal Interfaces","title":"IOExtras Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.IOExtras\nHTTP.IOExtras.startwrite(::IO)","category":"page"},{"location":"internal_interface/#HTTP.IOExtras","page":"Internal Interfaces","title":"HTTP.IOExtras","text":"IOExtras\n\nThis module defines extensions to the Base.IO interface to support:\n\nstartwrite, closewrite, startread and closeread for streams  with transactional semantics.\n\n\n\n\n\n","category":"module"},{"location":"internal_interface/#Streams-Interface","page":"Internal Interfaces","title":"Streams Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Streams.closebody\nHTTP.Streams.isaborted","category":"page"},{"location":"internal_interface/#HTTP.Streams.closebody","page":"Internal Interfaces","title":"HTTP.Streams.closebody","text":"closebody(::Stream)\n\nWrite the final 0 chunk if needed.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Streams.isaborted","page":"Internal Interfaces","title":"HTTP.Streams.isaborted","text":"isaborted(::Stream{<:Response})\n\nHas the server signaled that it does not wish to receive the message body?\n\n\"If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.\" RFC7230, 6.5\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Connection-Pooling-Interface","page":"Internal Interfaces","title":"Connection Pooling Interface","text":"","category":"section"},{"location":"internal_interface/","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.ConnectionPool.Connection\nHTTP.ConnectionPool.newconnection\nHTTP.ConnectionPool.POOL\nHTTP.IOExtras.startwrite(::HTTP.ConnectionPool.Connection)\nHTTP.IOExtras.closewrite(::HTTP.ConnectionPool.Connection)\nHTTP.IOExtras.startread(::HTTP.ConnectionPool.Connection)\nHTTP.IOExtras.closeread(::HTTP.ConnectionPool.Connection)","category":"page"},{"location":"internal_interface/#HTTP.ConnectionPool.Connection","page":"Internal Interfaces","title":"HTTP.ConnectionPool.Connection","text":"Connection{T <: IO}\n\nA TCPSocket or SSLContext connection to a HTTP host and port.\n\nFields:\n\nhost::String\nport::String, exactly as specified in the URI (i.e. may be empty).\nidle_timeout, No. of seconds to maintain connection after last request/response.\nrequire_ssl_verification, whether ssl verification is required for an ssl connection\npeerip, remote IP adress (used for debug/log messages).\npeerport, remote TCP port number (used for debug/log messages).\nlocalport, local TCP port number (used for debug messages).\nio::T, the TCPSocket or `SSLContext.\nclientconnection::Bool, whether the Connection was created from client code (as opposed to server code)\nbuffer::IOBuffer, left over bytes read from the connection after  the end of a response header (or chunksize). These bytes are usually  part of the response body.\ntimestamp, time data was last received.\nreadable, whether the Connection object is readable\nwriteable, whether the Connection object is writable\n\n\n\n\n\n","category":"type"},{"location":"internal_interface/#HTTP.ConnectionPool.newconnection","page":"Internal Interfaces","title":"HTTP.ConnectionPool.newconnection","text":"newconnection(type, host, port) -> Connection\n\nFind a reusable Connection in the pool, or create a new Connection if required.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.ConnectionPool.POOL","page":"Internal Interfaces","title":"HTTP.ConnectionPool.POOL","text":"POOL\n\nGlobal connection pool keeping track of active connections.\n\n\n\n\n\n","category":"constant"},{"location":"internal_interface/#HTTP.IOExtras.startwrite-Tuple{HTTP.ConnectionPool.Connection}","page":"Internal Interfaces","title":"HTTP.IOExtras.startwrite","text":"startwrite(::Connection)\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.closewrite-Tuple{HTTP.ConnectionPool.Connection}","page":"Internal Interfaces","title":"HTTP.IOExtras.closewrite","text":"closewrite(::Connection)\n\nSignal that an entire Request Message has been written to the Connection.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.startread-Tuple{HTTP.ConnectionPool.Connection}","page":"Internal Interfaces","title":"HTTP.IOExtras.startread","text":"startread(::Connection)\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.closeread-Tuple{HTTP.ConnectionPool.Connection}","page":"Internal Interfaces","title":"HTTP.IOExtras.closeread","text":"closeread(::Connection)\n\nSignal that an entire Response Message has been read from the Connection.\n\n\n\n\n\n","category":"method"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using \"\"\" syntax","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples that may prove potentially useful for those using  HTTP.jl. The code for these examples can also be found on Github  in the docs/examples folder.","category":"page"},{"location":"examples/#Simple-Server","page":"Examples","title":"Simple Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a server with HTTP.jl. It handles creating, deleting,  updating, and retrieving Animals from a dictionary through 4 different routes","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\nend\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# \"service\" functions to actually do the work\nfunction createAnimal(req::HTTP.Request)\n    animal = JSON3.read(IOBuffer(HTTP.payload(req)), Animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    animal = ANIMALS[parse(Int, animalId)]\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = JSON3.read(IOBuffer(HTTP.payload(req)), Animal)\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, parse(Int, animal.id))\n    return HTTP.Response(200)\nend\n\n# define REST endpoints to dispatch to \"service\" functions\nconst ANIMAL_ROUTER = HTTP.Router()\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/animals\", createAnimal)\n# note the use of `*` to capture the path segment \"variable\" animal id\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"PUT\", \"/api/zoo/v1/animals\", updateAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/animals/*\", deleteAnimal)\n\nHTTP.serve(ANIMAL_ROUTER, ip\"127.0.0.1\", 8080)\n\n","category":"page"},{"location":"examples/#Cors-Server","page":"Examples","title":"Cors Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Server example that takes after the simple server, however, handles dealing with CORS preflight headers when dealing with more than just a simple request","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\nend\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# CORS headers that show what kinds of complex requests are allowed to API\nheaders = [\n    \"Access-Control-Allow-Origin\" => \"*\",\n    \"Access-Control-Allow-Headers\" => \"*\",\n    \"Access-Control-Allow-Methods\" => \"POST, GET, OPTIONS\"\n]\n\n#= \nJSONHandler minimizes code by automatically converting the request body\nto JSON to pass to the other service functions automatically. JSONHandler\nrecieves the body of the response from the other service funtions and sends\nback a success response code\n=#\nfunction JSONHandler(req::HTTP.Request)\n    # first check if there's any request body\n    body = IOBuffer(HTTP.payload(req))\n    if eof(body)\n        # no request body\n        response_body = handle(ANIMAL_ROUTER, req)\n    else\n        # there's a body, so pass it on to the handler we dispatch to\n        response_body = handle(ANIMAL_ROUTER, req, JSON3.read(body, Animal))\n    end\n    return HTTP.Response(200, JSON3.write(response_body))\nend\n\n#= CorsHandler: handles preflight request with the OPTIONS flag\nIf a request was recieved with the correct headers, then a response will be \nsent back with a 200 code, if the correct headers were not specified in the request,\nthen a CORS error will be recieved on the client side\n\nSince each request passes throught the CORS Handler, then if the request is \nnot a preflight request, it will simply go to the JSONHandler to be passed to the\ncorrect service function =#\nfunction CorsHandler(req)\n    if HTTP.hasheader(req, \"OPTIONS\")\n        return HTTP.Response(200, headers = headers)\n    else \n        return JSONHandler(req)\n    end\n\n\n# **simplified** \"service\" functions\nfunction createAnimal(req::HTTP.Request, animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    return ANIMALS[animalId]\nend\n\nfunction updateAnimal(req::HTTP.Request, animal)\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, animal.id)\n    return \"\"\nend\n\n# add an additional endpoint for user creation\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users\", createUser)\n# modify service endpoints to have user pass UUID in\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/users/*/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/users/*/animals/*\", deleteAnimal)\n\n\nHTTP.serve(CorsHandler, ip\"127.0.0.1\", 8080)\n","category":"page"},{"location":"examples/#Server-Sent-Events","page":"Examples","title":"Server Sent Events","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server that implements server-sent events, loosely following this tutorial.","category":"page"},{"location":"examples/#Example-client-code-(JS):","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Server-sent events demo</title>\n</head>\n<body>\n    <h3>Fetched items:</h3>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    const evtSource = new EventSource(\"http://127.0.0.1:8080/api/events\")\n    evtSource.onmessage = async function (event) {\n        const newElement = document.createElement(\"li\");\n        const eventList = document.getElementById(\"list\");\n        if (parseFloat(event.data) > 0.5) {\n            const r = await fetch(\"http://127.0.0.1:8080/api/getItems\")\n            if (r.ok) {\n                const body = await r.json()\n                newElement.textContent = body;\n                eventList.appendChild(newElement);\n            }\n        }\n    }\n    evtSource.addEventListener(\"ping\", function(event) {\n        console.log('ping:', event.data)\n    });\n</script>\n</html>","category":"page"},{"location":"examples/#Example-client-code-(Julia)","page":"Examples","title":"Example client code (Julia)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nHTTP.open(\"GET\", \"http://127.0.0.1:8080/api/events\") do io\n    while !eof(io)\n        println(String(readavailable(io)))\n    end\nend","category":"page"},{"location":"examples/#Server-code:","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nconst ROUTER = HTTP.Router()\n\nfunction getItems(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\"\n    ]\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    return HTTP.Response(200, headers; body = JSON.json(rand(2)))\nend\n\nfunction events(stream::HTTP.Stream)\n    HTTP.setheader(stream, \"Access-Control-Allow-Origin\" => \"*\")\n    HTTP.setheader(stream, \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\")\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n\n    if HTTP.method(stream.message) == \"OPTIONS\"\n        return nothing\n    end\n\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n    HTTP.setheader(stream, \"Cache-Control\" => \"no-cache\")\n    while true\n        write(stream, \"event: ping\\ndata: $(round(Int, time()))\\n\\n\")\n        if rand(Bool)\n            write(stream, \"data: $(rand())\\n\\n\")\n        end\n        sleep(1)\n    end\n    return nothing\nend\n\nHTTP.@register(ROUTER, \"GET\", \"/api/getItems\", getItems)\nHTTP.@register(ROUTER, \"/api/events\", HTTP.Handlers.StreamHandlerFunction(events))\n\nHTTP.serve(ROUTER, \"127.0.0.1\", 8080)\n","category":"page"},{"location":"examples/#Session","page":"Examples","title":"Session","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a persistent session and logging into a web form. HTTP.jl does not have a distinct session object like requests.session() or rvest::html_session() but rather uses the cookies flag along with standard functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n#dummy site, any credentials work\nurl = \"http://quotes.toscrape.com/login\"\nsession = HTTP.get(url; cookies = true)\n\ncredentials = Dict(\n    \"Username\" => \"username\",\n    \"Password\" => \"password\")\n\nresponse = HTTP.post(url, credentials)\n","category":"page"},{"location":"examples/#Squaring-Server-Client","page":"Examples","title":"Squaring Server Client","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server in Julia and client code in JS.","category":"page"},{"location":"examples/#Example-client-code-(JS):-2","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Squaring numbers</title>\n</head>\n<body>\n    <input id=\"number\" placeholder=\"Input a number\" type=\"number\">\n    <button id=\"submit\">Square</button>\n    <h4>Outputs</h4>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    document.getElementById('submit').addEventListener('click', async function (event) {\n        const list = document.getElementById('list');\n        try {\n            const r = await fetch('http://127.0.0.1:8080/api/square', {\n                method: 'POST',\n                body: document.getElementById('number').value\n            });\n\n            if (r.ok) {\n                const body = await r.text()\n                const newElement = document.createElement('li');\n                newElement.textContent = body;\n                list.insertBefore(newElement, list.firstChild);\n            } else {\n                console.error(r)\n            };\n        } catch (err) {\n            console.error(err)\n        }\n    })\n</script>\n</html>","category":"page"},{"location":"examples/#Server-code:-2","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nconst ROUTER = HTTP.Router()\n\nfunction square(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"POST, OPTIONS\"\n    ]\n    # handle CORS requests\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    body = parse(Float64, String(HTTP.body(req)))\n    square = body^2\n    HTTP.Response(200, headers; body = string(square))\nend\n\nHTTP.@register(ROUTER, \"POST\", \"/api/square\", square)\n\nHTTP.serve(ROUTER, \"127.0.0.1\", 8080)\n","category":"page"},{"location":"examples/#Readme-Examples","page":"Examples","title":"Readme Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"#CLIENT\n\n#HTTP.request sends a HTTP Request Message and returns a Response Message.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\"; verbose=3)\nprintln(r.status) \nprintln(String(r.body)) \n\n#HTTP.open sends a HTTP Request Message and opens an IO stream from which the Response can be read.\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n#SERVERS\n\n#Using HTTP.Servers.listen:\n#The server will start listening on 127.0.0.1:8081 by default.\n\nusing HTTP\n\nHTTP.listen() do http::HTTP.Stream\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    HTTP.startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\n#Using HTTP.Handlers.serve:\n\nusing HTTP\n\nHTTP.serve() do request::HTTP.Request\n   @show request\n   @show request.method\n   @show HTTP.header(request, \"Content-Type\")\n   @show HTTP.payload(request)\n   try\n       return HTTP.Response(\"Hello\")\n   catch e\n       return HTTP.Response(404, \"Error: $e\")\n   end\nend\n\n#WebSocket Examples\n@async HTTP.WebSockets.listen(\"127.0.0.1\", UInt16(8081)) do ws\n    while !eof(ws)\n        data = readavailable(ws)\n        write(ws, data)\n    end\nend\n\nHTTP.WebSockets.open(\"ws://127.0.0.1:8081\") do ws\n    write(ws, \"Hello\")\n    x = readavailable(ws)\n    @show x\n    println(String(x))\nend;\nx = UInt8[0x48, 0x65, 0x6c, 0x6c, 0x6f]\n#Output: Hello\n\n#=Custom HTTP Layer Examples\nNotes:\nThere is no enforcement of a \"well-defined\" stack, you can insert a layer anywhere in the stack even if it logically does not make sense\nWhen creating a custom layer, you need to create a request(), see below for an example\nCustom layers is only implemented with the \"low-level\" request() calls, not the \"convenience\" functions such as HTTP.get(), HTTP.put(), etc.\nmodule TestRequest=#\n        import HTTP: Layer, request, Response\n\n        abstract type TestLayer{Next <: Layer} <: Layer{Next} end\n        export TestLayer, request\n\n        function request(::Type{TestLayer{Next}}, io::IO, req, body; kw...)::Response where Next\n                println(\"Insert your custom layer logic here!\")\n                return request(Next, io, req, body; kw...)\n        end\nend\n\nusing HTTP\nusing ..TestRequest\n\ncustom_stack = insert(stack(), StreamLayer, TestLayer)\n\nresult = request(custom_stack, \"GET\", \"https://httpbin.org/ip\")\n\n# Insert your custom layer logic here!\n\n# HTTP.Messages.Response:\n# \"\"\"\n# HTTP/1.1 200 OK\n# Access-Control-Allow-Credentials: true\n# Access-Control-Allow-Origin: *\n# Content-Type: application/json\n# Date: Fri, 30 Aug 2019 14:13:17 GMT\n# Referrer-Policy: no-referrer-when-downgrade\n# Server: nginx\n# X-Content-Type-Options: nosniff\n# X-Frame-Options: DENY\n# X-XSS-Protection: 1; mode=block\n# Content-Length: 45\n# Connection: keep-alive\n\n# {\n#   \"origin\": \"--Redacted--\"\n# }\n# \"\"\"\n\n ","category":"page"},{"location":"internal_architecture/#Internal-Architecture","page":"Internal Architecture","title":"Internal Architecture","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Layer\nHTTP.stack","category":"page"},{"location":"internal_architecture/#HTTP.Layer","page":"Internal Architecture","title":"HTTP.Layer","text":"Layer\n\nAbstract type to represent a client-side middleware that exists for documentation purposes. A layer is any function of the form f(::Handler) -> Handler, where Handler is a function of the form f(::Request) -> Response. Note that the Handler definition is from the server-side documentation, and is \"hard-coded\" on the client side. It may also be apparent that a Layer is the same as the Middleware interface from server-side, which is true, but we define Layer to clarify the client-side distinction and its unique usage. Custom layers can be deployed in one of two ways:\n\nHTTP.@client: Create a custom \"client\" with shorthand verb definitions, but which include custom layers; only these new verb methods will use the custom layers.\nHTTP.pushlayer!/HTTP.poplayer!: Allows globally adding and removing layers from the default HTTP.jl layer stack; all http requests will then use the custom layers\n\nQuick Examples\n\nmodule Auth\n\nusing HTTP\n\nfunction auth_layer(handler)\n    # returns a `Handler` function; check for a custom keyword arg `authcreds` that\n    # a user would pass like `HTTP.get(...; authcreds=creds)`.\n    # We also accept trailing keyword args `kw...` and pass them along later.\n    return function(req; authcreds=nothing, kw...)\n        # only apply the auth layer if the user passed `authcreds`\n        if authcreds !== nothing\n            # we add a custom header with stringified auth creds\n            HTTP.setheader(req, \"X-Auth-Creds\" => string(authcreds))\n        end\n        # pass the request along to the next layer by calling `auth_layer` arg `handler`\n        # also pass along the trailing keyword args `kw...`\n        return handler(req; kw...)\n    end\nend\n\n# Create a new client with the auth layer added\nHTTP.@client [auth_layer]\n\nend # module\n\n# Can now use custom client like:\nAuth.get(url; authcreds=creds) # performs GET request with auth_layer layer included\n\n# Or can include layer globally in all HTTP.jl requests\nHTTP.pushlayer!(Auth.auth_layer)\n\n# Now can use normal HTTP.jl methods and auth_layer will be included\nHTTP.get(url; authcreds=creds)\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#Request-Execution-Layers","page":"Internal Architecture","title":"Request Execution Layers","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.RedirectLayer\nHTTP.BasicAuthLayer\nHTTP.CookieLayer\nHTTP.CanonicalizeLayer\nHTTP.MessageLayer\nHTTP.RetryLayer\nHTTP.ExceptionLayer\nHTTP.ConnectionPoolLayer\nHTTP.TimeoutLayer\nHTTP.StreamLayer","category":"page"},{"location":"internal_architecture/#Parser","page":"Internal Architecture","title":"Parser","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Parsers.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Parsers","category":"page"},{"location":"internal_architecture/#HTTP.Parsers","page":"Internal Architecture","title":"HTTP.Parsers","text":"The parser separates a raw HTTP Message into its component parts.\n\nIf the input data is invalid the Parser throws a HTTP.ParseError.\n\nThe parse_* functions processes a single element of a HTTP Message at a time and return a SubString containing the unused portion of the input.\n\nThe Parser does not interpret the Message Headers. It is beyond the scope of the Parser to deal with repeated header fields, multi-line values, cookies or case normalization.\n\nThe Parser has no knowledge of the high-level Request and Response structs defined in Messages.jl. However, the Request and Response structs must have field names compatible with those expected by the parse_status_line! and parse_request_line! functions.\n\n\n\n\n\n","category":"module"},{"location":"internal_architecture/#Messages","page":"Internal Architecture","title":"Messages","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Messages.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Messages","category":"page"},{"location":"internal_architecture/#HTTP.Messages","page":"Internal Architecture","title":"HTTP.Messages","text":"The Messages module defines structs that represent HTTP.Request and HTTP.Response Messages.\n\nThe Response struct has a request field that points to the corresponding Request; and the Request struct has a response field. The Request struct also has a parent field that points to a Response in the case of HTTP redirects that occur and are followed.\n\nThe Messages module defines IO read and write methods for Messages but it does not deal with URIs, creating connections, or executing requests.\n\nThe read methods throw EOFError exceptions if input data is incomplete. and call parser functions that may throw HTTP.ParsingError exceptions. The read and write methods may also result in low level IO exceptions.\n\nSending Messages\n\nMessages are formatted and written to an IO stream by Base.write(::IO,::HTTP.Messages.Message) and/or HTTP.Messages.writeheaders.\n\nReceiving Messages\n\nMessages are parsed from IO stream data by HTTP.Messages.readheaders. This function calls HTTP.Parsers.parse_header_field and passes each header-field to HTTP.Messages.appendheader.\n\nHeaders\n\nHeaders are represented by Vector{Pair{String,String}}. As compared to Dict{String,String} this allows repeated header fields and preservation of order.\n\nHeader values can be accessed by name using HTTP.header and HTTP.setheader (case-insensitive).\n\nThe HTTP.appendheader function handles combining multi-line values, repeated header fields and special handling of multiple Set-Cookie headers.\n\nBodies\n\nThe HTTP.Message structs represent the message body by default as Vector{UInt8}. If IO or iterator objects are passed as the body, they will be stored as is in the Request/Response body field.\n\n\n\n\n\n","category":"module"},{"location":"internal_architecture/#Streams","page":"Internal Architecture","title":"Streams","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Streams.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Streams.Stream","category":"page"},{"location":"internal_architecture/#HTTP.Streams.Stream","page":"Internal Architecture","title":"HTTP.Streams.Stream","text":"Stream(::Request, ::IO)\n\nCreates a HTTP.Stream that wraps an existing IO stream.\n\nstartwrite(::Stream) sends the Request headers to the IO stream.\nwrite(::Stream, body) sends the body (or a chunk of the body).\nclosewrite(::Stream) sends the final 0 chunk (if needed) and calls closewrite on the IO stream.\nstartread(::Stream) calls startread on the IO stream then  reads and parses the Response headers.\neof(::Stream) and readavailable(::Stream) parse the body from the IO  stream.\ncloseread(::Stream) reads the trailers and calls closeread on the IO  stream.  When the IO stream is a HTTP.ConnectionPool.Connection,  calling closeread releases the connection back to the connection pool  for reuse. If a complete response has not been received, closeread throws  EOFError.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#Connections","page":"Internal Architecture","title":"Connections","text":"","category":"section"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"Source: ConnectionPool.jl","category":"page"},{"location":"internal_architecture/","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.ConnectionPool","category":"page"},{"location":"internal_architecture/#HTTP.ConnectionPool","page":"Internal Architecture","title":"HTTP.ConnectionPool","text":"This module provides the newconnection function with support for:\n\nOpening TCP and SSL connections.\nReusing connections for multiple Request/Response Messages\n\nThis module defines a Connection struct to manage the lifetime of a connection and its reuse. Methods are provided for eof, readavailable, unsafe_write and close. This allows the Connection object to act as a proxy for the TCPSocket or SSLContext that it wraps.\n\nThe POOL is used to manage connection pooling. Connections are identified by their host, port, whether they require ssl verification, and whether they are a client or server connection. If a subsequent request matches these properties of a previous connection and limits are respected (reuse limit, idle timeout), and it wasn't otherwise remotely closed, a connection will be reused.\n\n\n\n\n\n","category":"module"},{"location":"#HTTP.jl-Documentation","page":"Home","title":"HTTP.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using \"\"\" syntax","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.jl provides both client and server functionality for the http protocol. As a client, it provides the ability to make a wide range of request, including GET, POST, websocket upgrades, form data, multipart, chunking, and cookie handling. On the server side, it provides the ability to listen, accept, and route http requests, with middleware and handler interfaces to provide flexibility in processing responses.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#Making-requests-(client)","page":"Home","title":"Making requests (client)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.request sends an http request and returns a response.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# make a GET request, both forms are equivalent\nresp = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nresp = HTTP.get(\"http://httpbin.org/ip\")\nprintln(resp.status)\nprintln(String(resp.body))\n\n# make a POST request, sending data via `body` keyword argument\nresp = HTTP.post(\"http://httpbin.org/body\"; body=\"body\")","category":"page"},{"location":"#Handling-requests-(server)","page":"Home","title":"Handling requests (server)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.serve(@ref) allows specifying middleware + handlers for how incoming requests should be processed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# authentication middleware to ensure property security\nfunction auth(handler)\n    return function(req)\n        ident = parse_auth(req)\n        if ident === nothing\n            # failed to security authentication\n            return HTTP.Response(401, \"unauthorized\")\n        else\n            # store parsed identity in request context for handler usage\n            req.context[:auth] = ident\n            # pass request on to handler function for further processing\n            return handler(req)\n        end\n    end\nend\n\n# handler function to return specific user's data\nfunction handler(req)\n    ident = req.context[:auth]\n    return HTTP.Response(200, get_user_data(ident))\nend\n\n# start a server listening on port 8081 (default port) for localhost (default host)\n# requests will first be handled by teh auth middleware before being passed to the `handler`\n# request handler function\nHTTP.serve(auth(handler))","category":"page"},{"location":"#Further-Documentation","page":"Home","title":"Further Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the client and server-specific documentation pages for more in-depth discussions and examples for the many configurations available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"public_interface.md\", \"internal_architecture.md\", \"internal_interface.md\"]","category":"page"},{"location":"#quick-start","page":"Home","title":"quick start","text":"","category":"section"},{"location":"#manual","page":"Home","title":"manual","text":"","category":"section"},{"location":"#client","page":"Home","title":"client","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# making requests\n# sections for keyword args + links to examples\n# utilities","category":"page"},{"location":"#server","page":"Home","title":"server","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# running basic server\n# middleware/handlers framework\n# logfmt\"...\"","category":"page"},{"location":"#examples","page":"Home","title":"examples","text":"","category":"section"},{"location":"#reference","page":"Home","title":"reference","text":"","category":"section"},{"location":"public_interface/#Public-Interface","page":"Public Interface","title":"Public Interface","text":"","category":"section"},{"location":"public_interface/#Requests","page":"Public Interface","title":"Requests","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.request\nHTTP.open\nHTTP.get\nHTTP.put\nHTTP.post\nHTTP.head","category":"page"},{"location":"public_interface/#HTTP.request","page":"Public Interface","title":"HTTP.request","text":"HTTP.request(method, url [, headers [, body]]; <keyword arguments>]) -> HTTP.Response\n\nSend a HTTP Request Message and receive a HTTP Response Message.\n\ne.g.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nr = HTTP.get(\"http://httpbin.org/ip\") # equivalent shortcut\nprintln(r.status)\nprintln(String(r.body))\n\nheaders can be any collection where [string(k) => string(v) for (k,v) in headers] yields Vector{Pair}. e.g. a Dict(), a Vector{Tuple}, a Vector{Pair} or an iterator. By convention, if a header value is an empty string, it will not be written when sending a request (following the curl convention).\n\nbody can be a variety of objects:\n\na String, a Vector{UInt8} or any T accepted by write(::IO, ::T)\na collection of String or AbstractVector{UInt8} or IO streams or items of any type T accepted by write(::IO, ::T...)\na readable IO stream or any IO-like type T for which eof(T) and readavailable(T) are defined.\n\nThe HTTP.Response struct contains:\n\nstatus::Int16 e.g. 200\nheaders::Vector{Pair{String,String}}  e.g. [\"Server\" => \"Apache\", \"Content-Type\" => \"text/html\"]\nbody::Vector{UInt8} or ::IO, the Response Body bytes or the io argument  provided via the response_stream keyword argument\n\nFunctions HTTP.get, HTTP.put, HTTP.post and HTTP.head are defined as shorthand for HTTP.request(\"GET\", ...), etc.\n\nSupported optional keyword arguments:\n\nquery = nothing, a Pair or Dict of key => values to be included in the url\nresponse_stream = nothing, a writeable IO stream or any IO-like  type T for which write(T, AbstractVector{UInt8}) is defined. The response body  will be written to this stream instead of returned as a Vector{UInt8}.\nverbose = 0, set to 1 or 2 for increasingly verbose logging of the  request and response process\nconnect_timeout = 0, close the connection after this many seconds if it is still attempting to connect. Use connect_timeout = 0 to disable.\nconnection_limit = 8, number of concurrent connections allowed to each host:port.\nreadtimeout = 0, close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable.\nstatus_exception = true, throw HTTP.StatusError for response status >= 300.\nBasic authentication is detected automatically from the provided url's userinfo (in the form scheme://user:password@host) and adds the Authorization: Basic header; this can be disabled by passing basicauth=false\ncanonicalize_headers = false, rewrite request and response headers in Canonical-Camel-Dash-Format.\nproxy = proxyurl, pass request through a proxy given as a url; alternatively, the http_proxy, HTTP_PROXY, https_proxy, HTTPS_PROXY, and no_proxy environment variables are also detected/used; if set, they will be used automatically when making requests.\ndetect_content_type = false: if true and the request body is not a form or IO, it will be  inspected and the \"Content-Type\" header will be set to the detected content type.\ndecompress = true, if true, decompress the response body if the response has a  \"Content-Encoding\" header set to \"gzip\".\n\nRetry arguments:\n\nretry = true, retry idempotent requests in case of error.\nretries = 4, number of times to retry.\nretry_non_idempotent = false, retry non-idempotent requests too. e.g. POST.\n\nRedirect arguments:\n\nredirect = true, follow 3xx redirect responses; i.e. additional requests will be made to the redirected location\nredirect_limit = 3, maximum number of times a redirect will be followed\nredirect_method = nothing, the method to use for the redirected request; by default,  GET will be used, only responses with 307/308 will use the same original request method.  Pass redirect_method=:same to pass the same method as the orginal request though note that some servers  may not respond/accept the same method. It's also valid to pass the exact method to use  as a string, like redirect_method=\"PUT\".\nforwardheaders = true, forward original headers on redirect.\n\nSSL arguments:\n\nrequire_ssl_verification = NetworkOptions.verify_host(host), pass MBEDTLS_SSL_VERIFY_REQUIRED to the mbed TLS library. \"... peer must present a valid certificate, handshake is aborted if   verification failed.\"\nsslconfig = SSLConfig(require_ssl_verification)\n\nCookie arguments:\n\ncookies::Union{Bool, Dict{<:AbstractString, <:AbstractString}} = true, enable cookies, or alternatively,      pass a Dict{AbstractString, AbstractString} of name-value pairs to manually pass cookies in the request \"Cookie\" header\ncookiejar::HTTP.CookieJar=HTTP.COOKIEJAR: threadsafe cookie jar struct for keeping track of cookies per host;  a global cookie jar is used by default.\n\nRequest Body Examples\n\nString body:\n\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], \"post body data\")\n\nStream body from file:\n\nio = open(\"post_data.txt\", \"r\")\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], io)\n\nGenerator body:\n\nchunks = (\"chunk$i\" for i in 1:1000)\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nCollection body:\n\nchunks = [preamble_chunk, data_chunk, checksum(data_chunk)]\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nopen() do io body:\n\nHTTP.open(\"POST\", \"http://httpbin.org/post\") do io\n    write(io, preamble_chunk)\n    write(io, data_chunk)\n    write(io, checksum(data_chunk))\nend\n\nResponse Body Examples\n\nString body:\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\")\nprintln(String(r.body))\n\nStream body to file:\n\nio = open(\"get_data.txt\", \"w\")\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\nprintln(read(\"get_data.txt\"))\n\nStream body through buffer:\n\nr = HTTP.get(\"http://httpbin.org/get\", response_stream=IOBuffer())\nprintln(String(take!(r.body)))\n\nStream body through open() do io:\n\nr = HTTP.open(\"GET\", \"http://httpbin.org/stream/10\") do io\n   while !eof(io)\n       println(String(readavailable(io)))\n   end\nend\n\nHTTP.open(\"GET\", \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    n = 0\n    r = startread(http)\n    l = parse(Int, HTTP.header(r, \"Content-Length\"))\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        while !eof(http)\n            bytes = readavailable(http)\n            write(vlc, bytes)\n            n += length(bytes)\n            println(\"streamed $n-bytes $((100*n)Ã·l)%\\u1b[1A\")\n        end\n    end\nend\n\nInterfacing with RESTful JSON APIs:\n\nusing JSON\nparams = Dict(\"user\"=>\"RAO...tjN\", \"token\"=>\"NzU...Wnp\", \"message\"=>\"Hello!\")\nurl = \"http://api.domain.com/1/messages.json\"\nr = HTTP.post(url, body=JSON.json(params))\nprintln(JSON.parse(String(r.body)))\n\nStream bodies from and to files:\n\nin = open(\"foo.png\", \"r\")\nout = open(\"foo.jpg\", \"w\")\nHTTP.request(\"POST\", \"http://convert.com/png2jpg\", [], in, response_stream=out)\n\nStream bodies through: open() do io:\n\nHTTP.open(\"POST\", \"http://music.com/play\") do io\n    write(io, JSON.json([\n        \"auth\" => \"12345XXXX\",\n        \"song_id\" => 7,\n    ]))\n    r = startread(io)\n    @show r.status\n    while !eof(io)\n        bytes = readavailable(io)\n        play_audio(bytes)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.open","page":"Public Interface","title":"HTTP.open","text":"WebSockets.open(handler, url; verbose=false, kw...)\n\nInitiate a websocket connection to url (which should have schema like ws:// or wss://), and call handler(ws) with the websocket connection. Passing verbose=true or verbose=2 will enable debug logging for the life of the websocket connection. handler should be a function of the form f(ws) -> nothing, where ws is a WebSocket. Supported keyword arguments are the same as supported by HTTP.request. Typical websocket usage is:\n\nWebSockets.open(url) do ws\n    # iterate incoming websocket messages\n    for msg in ws\n        # send message back to server or do other logic here\n        send(ws, msg)\n    end\n    # iteration ends when the websocket connection is closed by server or error\nend\n\n\n\n\n\nHTTP.open(method, url, [,headers]) do io\n    write(io, body)\n    [startread(io) -> HTTP.Response]\n    while !eof(io)\n        readavailable(io) -> AbstractVector{UInt8}\n    end\nend -> HTTP.Response\n\nThe HTTP.open API allows the request body to be written to (and/or the response body to be read from) an IO stream.\n\ne.g. Streaming an audio file to the vlc player:\n\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.get","page":"Public Interface","title":"HTTP.get","text":"HTTP.get(url [, headers]; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"GET\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.put","page":"Public Interface","title":"HTTP.put","text":"HTTP.put(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"PUT\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.post","page":"Public Interface","title":"HTTP.post","text":"HTTP.post(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"POST\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.head","page":"Public Interface","title":"HTTP.head","text":"HTTP.head(url; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"HEAD\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Request-body-types","page":"Public Interface","title":"Request body types","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.Form\nHTTP.Multipart","category":"page"},{"location":"public_interface/#HTTP.Forms.Form","page":"Public Interface","title":"HTTP.Forms.Form","text":"HTTP.Form(data; boundary=string(rand(UInt128), base=16))\n\nConstruct a request body for multipart/form-data encoding from data.\n\ndata must iterate key-value pairs (e.g. Dict or Vector{Pair}) where the key/value of the iterator is the key/value of each mutipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an IOStream such as returned via open(file), or an IOBuffer for in-memory data.\n\nFor complete control over a multipart chunk's details, an HTTP.Multipart type is provided to support setting the filename, Content-Type, and Content-Transfer-Encoding.\n\nExamples\n\ndata = Dict(\n    \"text\" => \"text data\",\n    # filename (cat.png) and content-type (image/png) inferred from the IOStream\n    \"file1\" => open(\"cat.png\"),\n    # manully controlled chunk\n    \"file2\" => HTTP.Multipart(\"dog.jpeg\", open(\"mydog.jpg\"), \"image/jpeg\"),\n)\nbody = HTTP.Form(data)\nheaders = []\nHTTP.post(url, headers, body)\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Forms.Multipart","page":"Public Interface","title":"HTTP.Forms.Multipart","text":"HTTP.Multipart(filename::String, data::IO, content_type=HTTP.sniff(data), content_transfer_encoding=\"\")\n\nA type to represent a single multipart upload chunk for a file. This type would be used as the value in a key-value pair when constructing a HTTP.Form for a request body (see example below). The data argument must be an IO type such as IOStream, or IOBuffer. The content_type and content_transfer_encoding arguments allow manual setting of these multipart headers. Content-Type will default to the result of the HTTP.sniff(data) mimetype detection algorithm, whereas Content-Transfer-Encoding will be left out if not specified.\n\nExamples\n\nbody = HTTP.Form(Dict(\n    \"key\" => HTTP.Multipart(\"File.txt\", open(\"MyFile.txt\"), \"text/plain\"),\n))\nheaders = []\nHTTP.post(url, headers, body)\n\nExtended help\n\nFilename SHOULD be included when the Multipart represents the contents of a file RFC7578 4.2\n\nContent-Disposition set to \"form-data\" MUST be included with each Multipart. An additional \"name\" parameter MUST be included An optional \"filename\" parameter SHOULD be included if the contents of a file are sent This will be formatted such as:   Content-Disposition: form-data; name=\"user\"; filename=\"myfile.txt\" RFC7578 4.2\n\nContent-Type for each Multipart is optional, but SHOULD be included if the contents of a file are sent. RFC7578 4.4\n\nContent-Transfer-Encoding for each Multipart is deprecated RFC7578 4.7\n\nOther Content- header fields MUST be ignored RFC7578 4.8\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#Request-exceptions","page":"Public Interface","title":"Request exceptions","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"Request functions may throw the following exceptions:","category":"page"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.ConnectError\nHTTP.TimeoutError\nHTTP.StatusError\nHTTP.RequestError","category":"page"},{"location":"public_interface/#HTTP.Exceptions.ConnectError","page":"Public Interface","title":"HTTP.Exceptions.ConnectError","text":"HTTP.ConnectError\n\nRaised when an error occurs while trying to establish a request connection to the remote server. To see the underlying error, see the error field.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Exceptions.TimeoutError","page":"Public Interface","title":"HTTP.Exceptions.TimeoutError","text":"HTTP.TimeoutError\n\nRaised when a request times out according to readtimeout keyword argument provided.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Exceptions.StatusError","page":"Public Interface","title":"HTTP.Exceptions.StatusError","text":"HTTP.StatusError\n\nRaised when an HTTP.Response has a 4xx, 5xx or unrecognised status code.\n\nFields:\n\nstatus::Int16, the response status code.\nmethod::String, the request method.\ntarget::String, the request target.\nresponse, the HTTP.Response\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Exceptions.RequestError","page":"Public Interface","title":"HTTP.Exceptions.RequestError","text":"HTTP.RequestError\n\nRaised when an error occurs while physically sending a request to the remote server or reading the response back. To see the underlying error, see the error field.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#URIs","page":"Public Interface","title":"URIs","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.jl uses the URIs.jl package for handling URIs. Some functionality from URIs.jl, relevant to HTTP.jl, are listed below:","category":"page"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"URI\nURIs.escapeuri\nURIs.unescapeuri\nURIs.splitpath\nBase.isvalid(::URIs.URI)","category":"page"},{"location":"public_interface/#URIs.URI","page":"Public Interface","title":"URIs.URI","text":"URI(; scheme=\"\", host=\"\", port=\"\", etc...)\nURI(str) = parse(URI, str::String)\n\nA type representing a URI (e.g. a URL). Can be constructed from distinct parts using the various supported keyword arguments, or from a string. The URI constructors will automatically escape any provided query arguments, typically provided as \"key\"=>\"value\"::Pair or Dict(\"key\"=>\"value\"). Note that multiple values for a single query key can provided like Dict(\"key\"=>[\"value1\", \"value2\"]).\n\nWhen constructing a URI from a String, you need to first unescape that string: URI( URIs.unescapeuri(str) ).\n\nThe URI struct stores the complete URI in the uri::String field and the component parts in the following SubString fields:\n\nscheme, e.g. \"http\" or \"https\"\nuserinfo, e.g. \"username:password\"\nhost e.g. \"julialang.org\"\nport e.g. \"80\" or \"\"\npath e.g \"/\"\nquery e.g. \"Foo=1&Bar=2\"\nfragment\n\nThe queryparams(::URI) function returns a Dict containing the query.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#URIs.escapeuri","page":"Public Interface","title":"URIs.escapeuri","text":"escapeuri(x)\n\nApply URI percent-encoding to escape special characters in x.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#URIs.unescapeuri","page":"Public Interface","title":"URIs.unescapeuri","text":"unescapeuri(str)\n\nPercent-decode a string according to the URI escaping rules.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#URIs.splitpath","page":"Public Interface","title":"URIs.splitpath","text":"URIs.splitpath(path|uri; rstrip_empty_segment=true)\n\nSplits the path into component segments based on /, according to http://tools.ietf.org/html/rfc3986#section-3.3. Any fragment and query parts of the string are ignored if present.\n\nA final empty path segment (trailing '/') is removed, if present. This is technically incompatible with the segment grammar of RFC3986, but it seems to be a common recommendation to make paths with and without a trailing slash equivalent. To preserve any final empty path segment, set rstrip_empty_segment=false.\n\nExamples\n\njulia> URIs.splitpath(URI(\"http://example.com/foo/bar?a=b&c=d\"))\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\njulia> URIs.splitpath(\"/foo/bar/\")\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Base.isvalid-Tuple{URI}","page":"Public Interface","title":"Base.isvalid","text":"checks if a URI is valid\n\n\n\n\n\n","category":"method"},{"location":"public_interface/#Cookies","page":"Public Interface","title":"Cookies","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.Cookie","category":"page"},{"location":"public_interface/#HTTP.Cookies.Cookie","page":"Public Interface","title":"HTTP.Cookies.Cookie","text":"Cookie()\nCookie(; kwargs...)\nCookie(name, value; kwargs...)\n\nA Cookie represents an HTTP cookie as sent in the \"Set-Cookie\" header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:\n\nname::String: name of the cookie\nvalue::String: value of the cookie\npath::String: applicable path for the cookie\ndomain::String: applicable domain for the cookie\nexpires::Dates.DateTime: when the cookie should expire\nmaxage::Int: maxage == 0 means no max age, maxage < 0 means delete cookie now, maxage > 0 means the # of seconds until expiration\nsecure::Bool: secure cookie attribute\nhttponly::Bool: httponly cookie attribute\nhostonly::Bool: hostonly cookie attribute\nsamesite::Bool: SameSite cookie attribute\n\nSee IETF RFC 6265 for details.\n\nThe string representation of a cookie is generated by calling String(cookie; isrequest=true), where isrequest=true will only include the name=value pair for requests, and if false, will generate the \"Set-Cookie\" representation for a response header.\n\nA Vector{Cookie} can be retrieved from a Request/Response object by calling Cookies.cookies(r).\n\nA Cookie can be added to a Request/Response object by calling Cookies.addcookie!(r, cookie).\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#Utilities","page":"Public Interface","title":"Utilities","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.sniff\nHTTP.Strings.escapehtml\nHTTP.statustext","category":"page"},{"location":"public_interface/#HTTP.Sniff.sniff","page":"Public Interface","title":"HTTP.Sniff.sniff","text":"`HTTP.sniff(content::Union{Vector{UInt8}, String, IO})` => `String` (mimetype)\n\nHTTP.sniff will look at the first 512 bytes of content to try and determine a valid mimetype. If a mimetype can't be determined appropriately, \"application/octet-stream\" is returned.\n\nSupports JSON detection through the HTTP.isjson(content) function.\n\nExamples\n\njulia> HTTP.sniff(\"Hello world!!\")\n\"text/plain; charset=utf-8\"\n\njulia> HTTP.sniff(\"<html><body>Hello world!!</body></html>\")\n\"text/html; charset=utf-8\"\n\njulia> HTTP.sniff(\"{\"a\": -1.0}\")\n\"application/json; charset=utf-8\"\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Strings.escapehtml","page":"Public Interface","title":"HTTP.Strings.escapehtml","text":"escapehtml(i::String)\n\nReturns a string with special HTML characters escaped: &, <, >, \", '\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.statustext","page":"Public Interface","title":"HTTP.Messages.statustext","text":"statustext(::Int) -> String\n\nString representation of a HTTP status code.\n\nExamples\n\njulia> statustext(200)\n\"OK\"\n\njulia> statustext(404)\n\"Not Found\"\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Server-/-Handlers","page":"Public Interface","title":"Server / Handlers","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.listen\nHTTP.serve\nHTTP.Handlers\nHTTP.handle\nHTTP.RequestHandlerFunction\nHTTP.StreamHandlerFunction\nHTTP.Router\nHTTP.@register\nHTTP.@logfmt_str","category":"page"},{"location":"public_interface/#HTTP.Servers.listen","page":"Public Interface","title":"HTTP.Servers.listen","text":"HTTP.listen([host=Sockets.localhost[, port=8081]]; kw...) do http::HTTP.Stream\n    ...\nend\n\nListen for HTTP connections and execute the do function for each request.\n\nThe do function should be of the form f(::HTTP.Stream)::Nothing, and should at the minimum set a status via setstatus() and call startwrite() either explicitly or implicitly by writing out a response via write().  Failure to do this will result in an HTTP 500 error being transmitted to the client.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl  connections. Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl  verification (useful for testing).\nreuse_limit = nolimit, number of times a connection is allowed to be reused after the first request.\ntcpisvalid = tcp->true, function f(::TCPSocket)::Bool to, check accepted  connection before processing requests. e.g. to do source IP filtering.\nreadtimeout::Int=0, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple servers to listen on the same port.\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows closing the server.\nconnection_count::Ref{Int}, reference to track the number of currently  open connections.\nrate_limit::Rational{Int}=nothing\", number of connections//second  allowed per client IP address; excess connections are immediately closed.  e.g. 5//1.\nverbose::Bool=false, log connection information to stdout.\naccess_log::Function, function for formatting access log messages. The  function should accept two arguments, io::IO to which the messages should  be written, and http::HTTP.Stream which can be used to query information  from. See also @logfmt_str.\non_shutdown::Union{Function, Vector{<:Function}, Nothing}=nothing, one or  more functions to be run if the server is closed (for example by an  InterruptException). Note, shutdown function(s) will not run if an  IOServer object is supplied to the server keyword argument and closed  by close(server).\n\ne.g.\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    HTTP.setheader(http, \"Content-Type\" => \"text/html\")\n    write(http, \"target uri: $(http.message.target)<BR>\")\n    write(http, \"request body:<BR><PRE>\")\n    write(http, read(http))\n    write(http, \"</PRE>\")\n    return\nend\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\nThe server= option can be used to pass an already listening socket to HTTP.listen. This allows manual control of server shutdown.\n\ne.g.\n\nusing Sockets\nserver = Sockets.listen(Sockets.InetAddr(parse(IPAddr, host), port))\n@async HTTP.listen(f, host, port; server=server)\n\n# Closing server will stop HTTP.listen.\nclose(server)\n\nTo run the following HTTP chat example, open two Julia REPL windows and paste the example code into both of them. Then in one window run chat_server() and in the other run chat_client(), then type hello and press return. Whatever you type on the client will be displayed on the server and vis-versa.\n\nusing HTTP\n\nfunction chat(io::HTTP.Stream)\n    @async while !eof(io)\n        write(stdout, readavailable(io), \"\\n\")\n    end\n    while isopen(io)\n        write(io, readline(stdin))\n    end\nend\n\nchat_server() = HTTP.listen(\"127.0.0.1\", 8087) do io\n    write(io, \"HTTP.jl Chat Server. Welcome!\")\n    chat(io)\nend\n\nchat_client() = HTTP.open(\"POST\", \"http://127.0.0.1:8087\") do io\n    chat(io)\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers.serve","page":"Public Interface","title":"HTTP.Handlers.serve","text":"HTTP.serve(f, host, port; stream::Bool=false, kw...)\n\nStart a server on the given host and port; for each incoming request, call the given handler function f, which should be of the form f(req::HTTP.Request) -> HTTP.Response. If stream is true, the handler function should be of the form f(stream::HTTP.Stream) -> Nothing. Accepts all the same keyword arguments (and passes them along) to HTTP.listen, including:\n\nsslconfig: custom SSLConfig to support ssl connections\ntcpisvalid: custom function to validate tcp connections\nserver: a server Socket that a user can manage (closing listening, etc.)\nreuseaddr: whether another server can listen on the same host/port (unix only)\nmax_connections: max number of simultaneous connections allowed\nconnection_count: a Ref{Int} to keep track of currently open connections\nreadtimeout: time in seconds (integer) that the server should wait for a request to be sent\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers.Router","page":"Public Interface","title":"HTTP.Handlers.Router","text":"HTTP.Router(_404, _405)\n\nDefine a router object that maps incoming requests by path to registered routes and associated handlers. Paths can be registered using HTTP.register!. The router object itself is a \"request handler\" that can be called like:\n\nr = HTTP.Router()\nresp = r(reqest)\n\nWhich will inspect the request, find the matching, registered handler from the url, and pass the request on to be handled further.\n\nSee HTTP.register! for additional information on registering handlers based on routes.\n\nIf a request doesn't have a matching, registered handler, the _404 handler is called which, by default, returns a HTTP.Response(404). If a route matches the path, but not the method/verb (e.g. there's a registerd route for \"GET /api\", but the request is \"POST /api\"), then the _405 handler is called, which by default returns HTTP.Response(405) (method not allowed).\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.@logfmt_str","page":"Public Interface","title":"HTTP.@logfmt_str","text":"logfmt\"...\"\n\nParse an NGINX-style log format string and return a function mapping (io::IO, http::HTTP.Stream) -> body suitable for passing to HTTP.listen using the access_log keyword argument.\n\nThe following variables are currently supported:\n\n$http_name: arbitrary request header (with - replaced with _, e.g. http_user_agent)\n$sent_http_name: arbitrary response header (with - replaced with _)\n$request: the request line, e.g. GET /index.html HTTP/1.1\n$request_method: the request method\n$request_uri: the request URI\n$remote_addr: client address\n$remote_port: client port\n$remote_user: user name supplied with the Basic authentication\n$server_protocol: server protocol\n$time_iso8601: local time in ISO8601 format\n$time_local: local time in Common Log Format\n$status: response status code\n$body_bytes_sent: number of bytes in response body\n\nExamples\n\nlogfmt\"[$time_iso8601] \\\"$request\\\" $status\" # [2021-05-01T12:34:40+0100] \"GET /index.html HTTP/1.1\" 200\n\nlogfmt\"$remote_addr \\\"$http_user_agent\\\"\" # 127.0.0.1 \"curl/7.47.0\"\n\n\n\n\n\n","category":"macro"},{"location":"public_interface/#Messages-Interface","page":"Public Interface","title":"Messages Interface","text":"","category":"section"},{"location":"public_interface/","page":"Public Interface","title":"Public Interface","text":"HTTP.Request\nHTTP.Response\nHTTP.status\nHTTP.headers\nHTTP.body\nHTTP.method\nHTTP.uri","category":"page"},{"location":"public_interface/#HTTP.Messages.Request","page":"Public Interface","title":"HTTP.Messages.Request","text":"HTTP.Request(method, target, headers=[], body=nobody;\n    version=v\"1.1\", url::URI=URI(), responsebody=nothing, parent=nothing, context=HTTP.Context())\n\nRepresents a HTTP Request Message.\n\nmethod::String  RFC7230 3.1.1\ntarget::String  RFC7230 5.3\nversion::VersionNumber  RFC7230 2.6\nheaders::HTTP.Headers  RFC7230 3.2\nbody::Union{Vector{UInt8}, IO}  RFC7230 3.3\nresponse, the Response to this Request\nparent, the Response (if any) that led to this request (e.g. in the case of a redirect).  RFC7230 6.4\ncontext, a Dict{Symbol, Any} store used by middleware to share state\n\nYou can get each data with HTTP.method, HTTP.headers, HTTP.uri, and HTTP.body.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Messages.Response","page":"Public Interface","title":"HTTP.Messages.Response","text":"HTTP.Response(status, headers::HTTP.Headers; body=nothing, request=nothing)\nHTTP.Response(status, body)\nHTTP.Response(body)\n\nRepresents an HTTP response message with field:\n\nversion::VersionNumber  RFC7230 2.6\nstatus::Int16  RFC7230 3.1.2  RFC7231 6\nheaders::Vector{Pair{String,String}}  RFC7230 3.2\nbody::Vector{UInt8} or body::IO  RFC7230 3.3\nrequest, the Request that yielded this Response.\n\nAccessors are provided in HTTP.status, HTTP.headers, and HTTP.body.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Messages.status","page":"Public Interface","title":"HTTP.Messages.status","text":"HTTP.status(r::Response) -> Int16\n\nGet status from a response.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.headers","page":"Public Interface","title":"HTTP.Messages.headers","text":"HTTP.headers(r::Response) -> HTTP.Headers\n\nGet headers from a response.\n\n\n\n\n\nHTTP.headers(r::Request)\n\nGet headers from a request.\n\n\n\n\n\nHTTP.headers(m::Message, key) -> Vector{String}\n\nGet all headers with key k or empty if none\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.body","page":"Public Interface","title":"HTTP.Messages.body","text":"HTTP.body(r::Response{T}) -> T\n\nGet body from a response. Typically will be Vector{UInt8}. If a request was made response_stream=io::IO then the body will be io::IO.\n\n\n\n\n\nHTTP.body(r::Request)\n\nGet body from a request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Messages.method","page":"Public Interface","title":"HTTP.Messages.method","text":"HTTP.method(r::Request)\n\nGet method from a request.\n\n\n\n\n\n","category":"function"}]
}
