var documenterSearchIndex = {"docs":
[{"location":"examples/","page":"Examples","title":"Examples","text":"    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using \"\"\" syntax","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples that may prove potentially useful for those using  HTTP.jl. The code for these examples can also be found on Github  in the docs/examples folder.","category":"page"},{"location":"examples/#Simple-Server","page":"Examples","title":"Simple Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a server with HTTP.jl. It handles creating, deleting,  updating, and retrieving Animals from a dictionary through 4 different routes","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON3, StructTypes, Sockets\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\n    Animal() = new()\nend\n\nStructTypes.StructType(::Type{Animal}) = StructTypes.Mutable()\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# \"service\" functions to actually do the work\nfunction createAnimal(req::HTTP.Request)\n    animal = JSON3.read(req.body, Animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.getparams(req)[\"id\"]\n    animal = ANIMALS[parse(Int, animalId)]\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = JSON3.read(req.body, Animal)\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.getparams(req)[\"id\"]\n    delete!(ANIMALS, animalId)\n    return HTTP.Response(200)\nend\n\n# define REST endpoints to dispatch to \"service\" functions\nconst ANIMAL_ROUTER = HTTP.Router()\nHTTP.register!(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/animals\", createAnimal)\n# note the use of `*` to capture the path segment \"variable\" animal id\nHTTP.register!(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/animals/{id}\", getAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"PUT\", \"/api/zoo/v1/animals\", updateAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/animals/{id}\", deleteAnimal)\n\nsocket = Sockets.listen(Sockets.localhost, 8080)\nservertask = @async HTTP.serve(ANIMAL_ROUTER, Sockets.localhost, 8080; server=socket)\n\n# using our server\nx = Animal()\nx.type = \"cat\"\nx.name = \"pete\"\n# create 1st animal\nresp = HTTP.post(\"http://localhost:8080/api/zoo/v1/animals\", [], JSON3.write(x))\nx2 = JSON3.read(resp.body, Animal)\n# retrieve it back\nresp = HTTP.get(\"http://localhost:8080/api/zoo/v1/animals/$(x2.id)\")\nx3 = JSON3.read(resp.body, Animal)\n\n# close the server socket which will stop the HTTP server\nclose(socket)\n@assert istaskdone(servertask)\n","category":"page"},{"location":"examples/#Cors-Server","page":"Examples","title":"Cors Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Server example that takes after the simple server, however, handles dealing with CORS preflight headers when dealing with more than just a simple request","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON3, StructTypes, Sockets, UUIDs\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::UUID\n    type::String\n    name::String\n    Animal() = new()\nend\n\nStructTypes.StructType(::Type{Animal}) = StructTypes.Mutable()\n\n# use a plain `Dict` as a \"data store\", outer Dict maps userId to user-specific Animals\nconst ANIMALS = Dict{UUID, Dict{Int, Animal}}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# CORS headers that show what kinds of complex requests are allowed to API\nconst CORS_HEADERS = [\n    \"Access-Control-Allow-Origin\" => \"*\",\n    \"Access-Control-Allow-Headers\" => \"*\",\n    \"Access-Control-Allow-Methods\" => \"POST, GET, OPTIONS\"\n]\n\n#= \nJSONMiddleware minimizes code by automatically converting the request body\nto JSON to pass to the other service functions automatically. JSONMiddleware\nrecieves the body of the response from the other service funtions and sends\nback a success response code\n=#\nfunction JSONMiddleware(handler)\n    # Middleware functions return *Handler* functions\n    return function(req::HTTP.Request)\n        # first check if there's any request body\n        if isempty(req.body)\n            # we slightly change the Handler interface here because we know\n            # our handler methods will either return nothing or an Animal instance\n            ret = handler(req)\n        else\n            # replace request body with parsed Animal instance\n            req.body = JSON3.read(req.body, Animal)\n            ret = handler(req)\n        end\n        # return a Response, serializing any Animal as json string\n        return HTTP.Response(200, ret === nothing ? \"\" : JSON3.write(ret))\n    end\nend\n\n#= CorsMiddleware: handles preflight request with the OPTIONS flag\nIf a request was recieved with the correct headers, then a response will be \nsent back with a 200 code, if the correct headers were not specified in the request,\nthen a CORS error will be recieved on the client side\n\nSince each request passes throught the CORS Handler, then if the request is \nnot a preflight request, it will simply go to the JSONMiddleware to be passed to the\ncorrect service function =#\nfunction CorsMiddleware(handler)\n    return function(req::HTTP.Request)\n        if HTTP.hasheader(req, \"OPTIONS\")\n            return HTTP.Response(200, CORS_HEADERS)\n        else \n            return handler(req)\n        end\n    end\nend\n\n# **simplified** \"service\" functions\nfunction createAnimal(req::HTTP.Request)\n    animal = req.body\n    animal.id = getNextId()\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    # retrieve our matched path parameters from registered route\n    animalId = parse(Int, HTTP.getparams(req)[\"id\"])\n    userId = UUID(HTTP.getparams(req)[\"userId\"])\n    return ANIMALS[userId][animalId]\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = req.body\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    # retrieve our matched path parameters from registered route\n    animalId = parse(Int, HTTP.getparams(req)[\"id\"])\n    userId = UUID(HTTP.getparams(req)[\"userId\"])\n    delete!(ANIMALS[userId], animal.id)\n    return nothing\nend\n\nfunction createUser(req::HTTP.Request)\n    userId = uuid4()\n    ANIMALS[userId] = Dict{Int, Animal}()\n    return userId\nend\n\n# add an additional endpoint for user creation\nconst ANIMAL_ROUTER = HTTP.Router()\nHTTP.register!(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users\", createUser)\n# modify service endpoints to have user pass UUID in\nHTTP.register!(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users/{userId}/animals\", createAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/users/{userId}/animals/{id}\", getAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/users/{userId}/animals/{id}\", deleteAnimal)\n\nsocket = Sockets.listen(Sockets.localhost, 8080)\nservertask = @async HTTP.serve(ANIMAL_ROUTER |> JSONMiddleware |> CorsMiddleware, Sockets.localhost, 8080; server=socket)\n\n# using our server\nresp = HTTP.post(\"http://localhost:8080/api/zoo/v1/users\")\nuserId = JSON3.read(resp.body, UUID)\nx = Animal()\nx.userId = userId\nx.type = \"cat\"\nx.name = \"pete\"\n# create 1st animal\nresp = HTTP.post(\"http://localhost:8080/api/zoo/v1/users/$(userId)/animals\", [], JSON3.write(x))\nx2 = JSON3.read(resp.body, Animal)\n# retrieve it back\nresp = HTTP.get(\"http://localhost:8080/api/zoo/v1/users/$(userId)/animals/$(x2.id)\")\nx3 = JSON3.read(resp.body, Animal)\n\n# close the server socket which will stop the HTTP server\nclose(socket)\n@assert istaskdone(servertask)\n","category":"page"},{"location":"examples/#Server-Sent-Events","page":"Examples","title":"Server Sent Events","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server that implements server-sent events, loosely following this tutorial.","category":"page"},{"location":"examples/#Example-client-code-(JS):","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Server-sent events demo</title>\n</head>\n<body>\n    <h3>Fetched items:</h3>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    const evtSource = new EventSource(\"http://127.0.0.1:8080/api/events\")\n    evtSource.onmessage = async function (event) {\n        const newElement = document.createElement(\"li\");\n        const eventList = document.getElementById(\"list\");\n        if (parseFloat(event.data) > 0.5) {\n            const r = await fetch(\"http://127.0.0.1:8080/api/getItems\")\n            if (r.ok) {\n                const body = await r.json()\n                newElement.textContent = body;\n                eventList.appendChild(newElement);\n            }\n        }\n    }\n    evtSource.addEventListener(\"ping\", function(event) {\n        console.log('ping:', event.data)\n    });\n</script>\n</html>","category":"page"},{"location":"examples/#Example-client-code-(Julia)","page":"Examples","title":"Example client code (Julia)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nHTTP.open(\"GET\", \"http://127.0.0.1:8080/api/events\") do io\n    while !eof(io)\n        println(String(readavailable(io)))\n    end\nend","category":"page"},{"location":"examples/#Server-code:","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, Sockets, JSON\n\nconst ROUTER = HTTP.Router()\n\nfunction getItems(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\"\n    ]\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    return HTTP.Response(200, headers, JSON.json(rand(2)))\nend\n\nfunction events(stream::HTTP.Stream)\n    HTTP.setheader(stream, \"Access-Control-Allow-Origin\" => \"*\")\n    HTTP.setheader(stream, \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\")\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n\n    if HTTP.method(stream.message) == \"OPTIONS\"\n        return nothing\n    end\n\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n    HTTP.setheader(stream, \"Cache-Control\" => \"no-cache\")\n    while true\n        write(stream, \"event: ping\\ndata: $(round(Int, time()))\\n\\n\")\n        if rand(Bool)\n            write(stream, \"data: $(rand())\\n\\n\")\n        end\n        sleep(1)\n    end\n    return nothing\nend\n\nHTTP.register!(ROUTER, \"GET\", \"/api/getItems\", HTTP.streamhandler(getItems))\nHTTP.register!(ROUTER, \"/api/events\", events)\n\nsocket = Sockets.listen(Sockets.localhost, 8080)\nservertask = @async HTTP.serve(ROUTER, \"127.0.0.1\", 8080; server=socket, stream=true)\n\n# Julia usage\nresp = HTTP.get(\"http://localhost:8080/api/getItems\")\n\nclose = Ref(false)\n@async HTTP.open(\"GET\", \"http://127.0.0.1:8080/api/events\") do io\n    while !eof(io) && !close[]\n        println(String(readavailable(io)))\n    end\nend\n\n# run the following to stop the streaming client request\nclose[] = true\n\n# close the server socket which will stop the HTTP server\nclose(socket)\n@assert istaskdone(servertask)\n","category":"page"},{"location":"examples/#Session","page":"Examples","title":"Session","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a persistent session and logging into a web form. HTTP.jl does not have a distinct session object like requests.session() or rvest::html_session() but rather uses the cookies flag along with standard functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n#dummy site, any credentials work\nurl = \"http://quotes.toscrape.com/login\"\nsession = HTTP.get(url; cookies = true)\n\ncredentials = Dict(\n    \"Username\" => \"username\",\n    \"Password\" => \"password\")\n\nresponse = HTTP.post(url, credentials)\n","category":"page"},{"location":"examples/#Squaring-Server-Client","page":"Examples","title":"Squaring Server Client","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server in Julia and client code in JS.","category":"page"},{"location":"examples/#Example-client-code-(JS):-2","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Squaring numbers</title>\n</head>\n<body>\n    <input id=\"number\" placeholder=\"Input a number\" type=\"number\">\n    <button id=\"submit\">Square</button>\n    <h4>Outputs</h4>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    document.getElementById('submit').addEventListener('click', async function (event) {\n        const list = document.getElementById('list');\n        try {\n            const r = await fetch('http://127.0.0.1:8080/api/square', {\n                method: 'POST',\n                body: document.getElementById('number').value\n            });\n\n            if (r.ok) {\n                const body = await r.text()\n                const newElement = document.createElement('li');\n                newElement.textContent = body;\n                list.insertBefore(newElement, list.firstChild);\n            } else {\n                console.error(r)\n            };\n        } catch (err) {\n            console.error(err)\n        }\n    })\n</script>\n</html>","category":"page"},{"location":"examples/#Server-code:-2","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\nconst ROUTER = HTTP.Router()\n\nfunction square(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"POST, OPTIONS\"\n    ]\n    # handle CORS requests\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    body = parse(Float64, String(req.body))\n    square = body^2\n    HTTP.Response(200, headers, string(square))\nend\n\nHTTP.register!(ROUTER, \"POST\", \"/api/square\", square)\n\nsocket = Sockets.listen(Sockets.localhost, 8080)\nservertask = @async HTTP.serve(ROUTER, Sockets.localhost, 8080; server=socket)\n\n# usage\nresp = HTTP.post(\"http://localhost:8080/api/square\"; body=\"3\")\nsq = parse(Float64, String(resp.body))\n@assert sq == 9.0\n\n# close the server socket which will stop the HTTP server\nclose(socket)\n@assert istaskdone(servertask)\n","category":"page"},{"location":"examples/#Readme-Examples","page":"Examples","title":"Readme Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"#CLIENT\n\n#HTTP.request sends a HTTP Request Message and returns a Response Message.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nprintln(r.status) \nprintln(String(r.body)) \n\n#HTTP.open sends a HTTP Request Message and opens an IO stream from which the Response can be read.\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n#SERVERS\n\n#Using HTTP.Servers.listen:\n#The server will start listening on 127.0.0.1:8081 by default.\n\nusing HTTP\n\nHTTP.listen() do http::HTTP.Stream\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    HTTP.startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\n#Using HTTP.Handlers.serve:\n\nusing HTTP\n\nHTTP.serve() do request::HTTP.Request\n   @show request\n   @show request.method\n   @show HTTP.header(request, \"Content-Type\")\n   @show request.body\n   try\n       return HTTP.Response(\"Hello\")\n   catch e\n       return HTTP.Response(404, \"Error: $e\")\n   end\nend\n\n#WebSocket Examples\n@async HTTP.WebSockets.listen(\"127.0.0.1\", 8081) do ws\n    for msg in ws\n        send(ws, msg)\n    end\nend\n\nHTTP.WebSockets.open(\"ws://127.0.0.1:8081\") do ws\n    send(ws, \"Hello\")\n    x = receive(ws)\n    println(x)\nend;\n#Output: Hello\n","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Depth = 4","category":"page"},{"location":"reference/#Client-Requests","page":"API Reference","title":"Client Requests","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.request\nHTTP.get\nHTTP.put\nHTTP.post\nHTTP.head\nHTTP.patch\nHTTP.delete\nHTTP.open\nHTTP.download","category":"page"},{"location":"reference/#HTTP.request","page":"API Reference","title":"HTTP.request","text":"HTTP.request(method, url [, headers [, body]]; <keyword arguments>]) -> HTTP.Response\n\nSend a HTTP Request Message and receive a HTTP Response Message.\n\ne.g.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nr = HTTP.get(\"http://httpbin.org/ip\") # equivalent shortcut\nprintln(r.status)\nprintln(String(r.body))\n\nheaders can be any collection where [string(k) => string(v) for (k,v) in headers] yields Vector{Pair}. e.g. a Dict(), a Vector{Tuple}, a Vector{Pair} or an iterator. By convention, if a header value is an empty string, it will not be written when sending a request (following the curl convention).\n\nbody can be a variety of objects:\n\na String, a Vector{UInt8} or any T accepted by write(::IO, ::T)\na collection of String or AbstractVector{UInt8} or IO streams or items of any type T accepted by write(::IO, ::T...)\na readable IO stream or any IO-like type T for which eof(T) and readavailable(T) are defined.\n\nThe HTTP.Response struct contains:\n\nstatus::Int16 e.g. 200\nheaders::Vector{Pair{String,String}}  e.g. [\"Server\" => \"Apache\", \"Content-Type\" => \"text/html\"]\nbody::Vector{UInt8} or ::IO, the Response Body bytes or the io argument  provided via the response_stream keyword argument\n\nFunctions HTTP.get, HTTP.put, HTTP.post and HTTP.head are defined as shorthand for HTTP.request(\"GET\", ...), etc.\n\nSupported optional keyword arguments:\n\nquery = nothing, a Pair or Dict of key => values to be included in the url\nresponse_stream = nothing, a writeable IO stream or any IO-like  type T for which write(T, AbstractVector{UInt8}) is defined. The response body  will be written to this stream instead of returned as a Vector{UInt8}.\nverbose = 0, set to 1 or 2 for increasingly verbose logging of the  request and response process\nconnect_timeout = 0, close the connection after this many seconds if it is still attempting to connect. Use connect_timeout = 0 to disable.\nconnection_limit = 8, number of concurrent connections allowed to each host:port.\nreadtimeout = 0, close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable.\nstatus_exception = true, throw HTTP.StatusError for response status >= 300.\nBasic authentication is detected automatically from the provided url's userinfo (in the form scheme://user:password@host) and adds the Authorization: Basic header; this can be disabled by passing basicauth=false\ncanonicalize_headers = false, rewrite request and response headers in Canonical-Camel-Dash-Format.\nproxy = proxyurl, pass request through a proxy given as a url; alternatively, the http_proxy, HTTP_PROXY, https_proxy, HTTPS_PROXY, and no_proxy environment variables are also detected/used; if set, they will be used automatically when making requests.\ndetect_content_type = false: if true and the request body is not a form or IO, it will be  inspected and the \"Content-Type\" header will be set to the detected content type.\ndecompress = true, if true, decompress the response body if the response has a  \"Content-Encoding\" header set to \"gzip\".\n\nRetry arguments:\n\nretry = true, retry idempotent requests in case of error.\nretries = 4, number of times to retry.\nretry_non_idempotent = false, retry non-idempotent requests too. e.g. POST.\n\nRedirect arguments:\n\nredirect = true, follow 3xx redirect responses; i.e. additional requests will be made to the redirected location\nredirect_limit = 3, maximum number of times a redirect will be followed\nredirect_method = nothing, the method to use for the redirected request; by default,  GET will be used, only responses with 307/308 will use the same original request method.  Pass redirect_method=:same to pass the same method as the orginal request though note that some servers  may not respond/accept the same method. It's also valid to pass the exact method to use  as a string, like redirect_method=\"PUT\".\nforwardheaders = true, forward original headers on redirect.\n\nSSL arguments:\n\nrequire_ssl_verification = NetworkOptions.verify_host(host), pass MBEDTLS_SSL_VERIFY_REQUIRED to the mbed TLS library. \"... peer must present a valid certificate, handshake is aborted if   verification failed.\"\nsslconfig = SSLConfig(require_ssl_verification)\n\nCookie arguments:\n\ncookies::Union{Bool, Dict{<:AbstractString, <:AbstractString}} = true, enable cookies, or alternatively,      pass a Dict{AbstractString, AbstractString} of name-value pairs to manually pass cookies in the request \"Cookie\" header\ncookiejar::HTTP.CookieJar=HTTP.COOKIEJAR: threadsafe cookie jar struct for keeping track of cookies per host;  a global cookie jar is used by default.\n\nRequest Body Examples\n\nString body:\n\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], \"post body data\")\n\nStream body from file:\n\nio = open(\"post_data.txt\", \"r\")\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], io)\n\nGenerator body:\n\nchunks = (\"chunk$i\" for i in 1:1000)\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nCollection body:\n\nchunks = [preamble_chunk, data_chunk, checksum(data_chunk)]\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nopen() do io body:\n\nHTTP.open(\"POST\", \"http://httpbin.org/post\") do io\n    write(io, preamble_chunk)\n    write(io, data_chunk)\n    write(io, checksum(data_chunk))\nend\n\nResponse Body Examples\n\nString body:\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\")\nprintln(String(r.body))\n\nStream body to file:\n\nio = open(\"get_data.txt\", \"w\")\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\nprintln(read(\"get_data.txt\"))\n\nStream body through buffer:\n\nr = HTTP.get(\"http://httpbin.org/get\", response_stream=IOBuffer())\nprintln(String(take!(r.body)))\n\nStream body through open() do io:\n\nr = HTTP.open(\"GET\", \"http://httpbin.org/stream/10\") do io\n   while !eof(io)\n       println(String(readavailable(io)))\n   end\nend\n\nHTTP.open(\"GET\", \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    n = 0\n    r = startread(http)\n    l = parse(Int, HTTP.header(r, \"Content-Length\"))\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        while !eof(http)\n            bytes = readavailable(http)\n            write(vlc, bytes)\n            n += length(bytes)\n            println(\"streamed $n-bytes $((100*n)Ã·l)%\\u1b[1A\")\n        end\n    end\nend\n\nInterfacing with RESTful JSON APIs:\n\nusing JSON\nparams = Dict(\"user\"=>\"RAO...tjN\", \"token\"=>\"NzU...Wnp\", \"message\"=>\"Hello!\")\nurl = \"http://api.domain.com/1/messages.json\"\nr = HTTP.post(url, body=JSON.json(params))\nprintln(JSON.parse(String(r.body)))\n\nStream bodies from and to files:\n\nin = open(\"foo.png\", \"r\")\nout = open(\"foo.jpg\", \"w\")\nHTTP.request(\"POST\", \"http://convert.com/png2jpg\", [], in, response_stream=out)\n\nStream bodies through: open() do io:\n\nHTTP.open(\"POST\", \"http://music.com/play\") do io\n    write(io, JSON.json([\n        \"auth\" => \"12345XXXX\",\n        \"song_id\" => 7,\n    ]))\n    r = startread(io)\n    @show r.status\n    while !eof(io)\n        bytes = readavailable(io)\n        play_audio(bytes)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.get","page":"API Reference","title":"HTTP.get","text":"HTTP.get(url [, headers]; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"GET\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.put","page":"API Reference","title":"HTTP.put","text":"HTTP.put(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"PUT\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.post","page":"API Reference","title":"HTTP.post","text":"HTTP.post(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"POST\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.head","page":"API Reference","title":"HTTP.head","text":"HTTP.head(url; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"HEAD\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.patch","page":"API Reference","title":"HTTP.patch","text":"HTTP.patch(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"PATCH\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.delete","page":"API Reference","title":"HTTP.delete","text":"HTTP.delete(url [, headers]; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"DELETE\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.open","page":"API Reference","title":"HTTP.open","text":"WebSockets.open(handler, url; verbose=false, kw...)\n\nInitiate a websocket connection to url (which should have schema like ws:// or wss://), and call handler(ws) with the websocket connection. Passing verbose=true or verbose=2 will enable debug logging for the life of the websocket connection. handler should be a function of the form f(ws) -> nothing, where ws is a WebSocket. Supported keyword arguments are the same as supported by HTTP.request. Typical websocket usage is:\n\nWebSockets.open(url) do ws\n    # iterate incoming websocket messages\n    for msg in ws\n        # send message back to server or do other logic here\n        send(ws, msg)\n    end\n    # iteration ends when the websocket connection is closed by server or error\nend\n\n\n\n\n\nHTTP.open(method, url, [,headers]) do io\n    write(io, body)\n    [startread(io) -> HTTP.Response]\n    while !eof(io)\n        readavailable(io) -> AbstractVector{UInt8}\n    end\nend -> HTTP.Response\n\nThe HTTP.open API allows the request body to be written to (and/or the response body to be read from) an IO stream.\n\ne.g. Streaming an audio file to the vlc player:\n\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.download","page":"API Reference","title":"HTTP.download","text":"download(url, [local_path], [headers]; update_period=1, kw...)\n\nSimilar to Base.download this downloads a file, returning the filename. If the local_path:\n\nis not provided, then it is saved in a temporary directory\nif part to a directory is provided then it is saved into that directory\notherwise the local path is uses as the filename to save to.\n\nWhen saving into a directory, the filename is determined (where possible), from the rules of the HTTP.\n\nupdate_period controls how often (in seconds) to report the progress.\nset to Inf to disable reporting\nheaders specifies headers to be used for the HTTP GET request\nany additional keyword args (kw...) are passed on to the HTTP request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Request/Response-Objects","page":"API Reference","title":"Request/Response Objects","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Request\nHTTP.Response\nHTTP.Stream\nHTTP.WebSocket\nHTTP.Messages.header\nHTTP.Messages.headers\nHTTP.Messages.hasheader\nHTTP.Messages.headercontains\nHTTP.Messages.setheader\nHTTP.Messages.appendheader\nHTTP.Messages.decode","category":"page"},{"location":"reference/#HTTP.Messages.Request","page":"API Reference","title":"HTTP.Messages.Request","text":"HTTP.Request(method, target, headers=[], body=nobody;\n    version=v\"1.1\", url::URI=URI(), responsebody=nothing, parent=nothing, context=HTTP.Context())\n\nRepresents a HTTP Request Message with fields:\n\nmethod::String  RFC7230 3.1.1\ntarget::String  RFC7230 5.3\nversion::VersionNumber  RFC7230 2.6\nheaders::HTTP.Headers  RFC7230 3.2\nbody::Union{Vector{UInt8}, IO}  RFC7230 3.3\nresponse, the Response to this Request\nurl::URI, the full URI of the request\nparent, the Response (if any) that led to this request (e.g. in the case of a redirect).  RFC7230 6.4\ncontext, a Dict{Symbol, Any} store used by middleware to share state\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Messages.Response","page":"API Reference","title":"HTTP.Messages.Response","text":"HTTP.Response(status, headers::HTTP.Headers, body; request=nothing)\nHTTP.Response(status, body)\nHTTP.Response(body)\n\nRepresents an HTTP response message with fields:\n\nversion::VersionNumber  RFC7230 2.6\nstatus::Int16  RFC7230 3.1.2  RFC7231 6\nheaders::Vector{Pair{String,String}}  RFC7230 3.2\nbody::Vector{UInt8} or body::IO  RFC7230 3.3\nrequest, the Request that yielded this Response.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Streams.Stream","page":"API Reference","title":"HTTP.Streams.Stream","text":"Stream(::Request, ::IO)\n\nCreates a HTTP.Stream that wraps an existing IO stream.\n\nstartwrite(::Stream) sends the Request headers to the IO stream.\nwrite(::Stream, body) sends the body (or a chunk of the body).\nclosewrite(::Stream) sends the final 0 chunk (if needed) and calls closewrite on the IO stream.\nstartread(::Stream) calls startread on the IO stream then  reads and parses the Response headers.\neof(::Stream) and readavailable(::Stream) parse the body from the IO  stream.\ncloseread(::Stream) reads the trailers and calls closeread on the IO  stream.  When the IO stream is a HTTP.ConnectionPool.Connection,  calling closeread releases the connection back to the connection pool  for reuse. If a complete response has not been received, closeread throws  EOFError.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.WebSockets.WebSocket","page":"API Reference","title":"HTTP.WebSockets.WebSocket","text":"WebSocket(io::HTTP.Connection, req, resp; client=true)\n\nRepresentation of a websocket connection. Use WebSockets.open to open a websocket connection, passing a handler function f(ws) to send and receive messages. Use WebSockets.listen to listen for incoming websocket connections, passing a handler function f(ws) to send and receive messages.\n\nCall send(ws, msg) to send a message; if msg is an AbstractString, a TEXT websocket message will be sent; if msg is an AbstractVector{UInt8}, a BINARY websocket message will be sent. Otherwise, msg should be an iterable of either AbstractString or AbstractVector{UInt8}, and a fragmented message will be sent, one frame for each iterated element.\n\nControl frames can be sent by calling ping(ws[, data]), pong(ws[, data]), or close(ws[, body::WebSockets.CloseFrameBody]). Calling close will initiate the close sequence and close the underlying connection.\n\nTo receive messages, call receive(ws), which will block until a non-control, full message is received. PING messages will automatically be responded to when received. CLOSE messages will also be acknowledged and then a WebSocketError will be thrown with the WebSockets.CloseFrameBody payload, which may include a non-error CLOSE frame status code. WebSockets.isok(err) can be called to check if the CLOSE was normal or unexpected. Fragmented messages will be received until the final frame is received and the full concatenated payload can be returned. receive(ws) returns a Vector{UInt8} for BINARY messages, and a String for TEXT messages.\n\nFor convenience, WebSockets support the iteration protocol, where each iteration will receive a non-control message, with iteration terminating when the connection is closed. E.g.:\n\nWebSockets.open(url) do ws\n    for msg in ws\n        # do cool stuff with msg\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Messages.header","page":"API Reference","title":"HTTP.Messages.header","text":"HTTP.header(::Message, key [, default=\"\"]) -> String\n\nGet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.headers","page":"API Reference","title":"HTTP.Messages.headers","text":"HTTP.headers(m::Message, key) -> Vector{String}\n\nGet all headers with key k or empty if none\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.hasheader","page":"API Reference","title":"HTTP.Messages.hasheader","text":"HTTP.hasheader(::Message, key) -> Bool\n\nDoes header value for key exist (case-insensitive)?\n\n\n\n\n\nHTTP.hasheader(::Message, key, value) -> Bool\n\nDoes header for key match value (both case-insensitive)?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.headercontains","page":"API Reference","title":"HTTP.Messages.headercontains","text":"HTTP.headercontains(::Message, key, value) -> Bool\n\nDoes the header for key (interpreted as comma-separated list) contain value (both case-insensitive)?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.setheader","page":"API Reference","title":"HTTP.Messages.setheader","text":"HTTP.setheader(::Message, key => value)\n\nSet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.appendheader","page":"API Reference","title":"HTTP.Messages.appendheader","text":"HTTP.appendheader(::Message, key => value)\n\nAppend a header value to message.headers.\n\nIf key is the same as the previous header, the value is appended to the value of the previous header with a comma delimiter\n\nSet-Cookie headers are not comma-combined because cookies often contain internal commas.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.decode","page":"API Reference","title":"HTTP.Messages.decode","text":"HTTP.decode(r::Union{Request, Response}) -> Vector{UInt8}\n\nFor a gzip encoded request/response body, decompress it and return the decompressed body.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Request-body-types","page":"API Reference","title":"Request body types","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Form\nHTTP.Multipart","category":"page"},{"location":"reference/#HTTP.Forms.Form","page":"API Reference","title":"HTTP.Forms.Form","text":"HTTP.Form(data; boundary=string(rand(UInt128), base=16))\n\nConstruct a request body for multipart/form-data encoding from data.\n\ndata must iterate key-value pairs (e.g. Dict or Vector{Pair}) where the key/value of the iterator is the key/value of each mutipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an IOStream such as returned via open(file), or an IOBuffer for in-memory data.\n\nFor complete control over a multipart chunk's details, an HTTP.Multipart type is provided to support setting the filename, Content-Type, and Content-Transfer-Encoding.\n\nExamples\n\ndata = Dict(\n    \"text\" => \"text data\",\n    # filename (cat.png) and content-type (image/png) inferred from the IOStream\n    \"file1\" => open(\"cat.png\"),\n    # manully controlled chunk\n    \"file2\" => HTTP.Multipart(\"dog.jpeg\", open(\"mydog.jpg\"), \"image/jpeg\"),\n)\nbody = HTTP.Form(data)\nheaders = []\nHTTP.post(url, headers, body)\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Forms.Multipart","page":"API Reference","title":"HTTP.Forms.Multipart","text":"HTTP.Multipart(filename::String, data::IO, content_type=HTTP.sniff(data), content_transfer_encoding=\"\")\n\nA type to represent a single multipart upload chunk for a file. This type would be used as the value in a key-value pair when constructing a HTTP.Form for a request body (see example below). The data argument must be an IO type such as IOStream, or IOBuffer. The content_type and content_transfer_encoding arguments allow manual setting of these multipart headers. Content-Type will default to the result of the HTTP.sniff(data) mimetype detection algorithm, whereas Content-Transfer-Encoding will be left out if not specified.\n\nExamples\n\nbody = HTTP.Form(Dict(\n    \"key\" => HTTP.Multipart(\"File.txt\", open(\"MyFile.txt\"), \"text/plain\"),\n))\nheaders = []\nHTTP.post(url, headers, body)\n\nExtended help\n\nFilename SHOULD be included when the Multipart represents the contents of a file RFC7578 4.2\n\nContent-Disposition set to \"form-data\" MUST be included with each Multipart. An additional \"name\" parameter MUST be included An optional \"filename\" parameter SHOULD be included if the contents of a file are sent This will be formatted such as:   Content-Disposition: form-data; name=\"user\"; filename=\"myfile.txt\" RFC7578 4.2\n\nContent-Type for each Multipart is optional, but SHOULD be included if the contents of a file are sent. RFC7578 4.4\n\nContent-Transfer-Encoding for each Multipart is deprecated RFC7578 4.7\n\nOther Content- header fields MUST be ignored RFC7578 4.8\n\n\n\n\n\n","category":"type"},{"location":"reference/#Request-exceptions","page":"API Reference","title":"Request exceptions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Request functions may throw the following exceptions:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.ConnectError\nHTTP.TimeoutError\nHTTP.StatusError\nHTTP.RequestError","category":"page"},{"location":"reference/#HTTP.Exceptions.ConnectError","page":"API Reference","title":"HTTP.Exceptions.ConnectError","text":"HTTP.ConnectError\n\nRaised when an error occurs while trying to establish a request connection to the remote server. To see the underlying error, see the error field.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Exceptions.TimeoutError","page":"API Reference","title":"HTTP.Exceptions.TimeoutError","text":"HTTP.TimeoutError\n\nRaised when a request times out according to readtimeout keyword argument provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Exceptions.StatusError","page":"API Reference","title":"HTTP.Exceptions.StatusError","text":"HTTP.StatusError\n\nRaised when an HTTP.Response has a 4xx, 5xx or unrecognised status code.\n\nFields:\n\nstatus::Int16, the response status code.\nmethod::String, the request method.\ntarget::String, the request target.\nresponse, the HTTP.Response\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Exceptions.RequestError","page":"API Reference","title":"HTTP.Exceptions.RequestError","text":"HTTP.RequestError\n\nRaised when an error occurs while physically sending a request to the remote server or reading the response back. To see the underlying error, see the error field.\n\n\n\n\n\n","category":"type"},{"location":"reference/#URIs","page":"API Reference","title":"URIs","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.jl uses the URIs.jl package for handling URIs. Some functionality from URIs.jl, relevant to HTTP.jl, are listed below:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"URI\nURIs.escapeuri\nURIs.unescapeuri\nURIs.splitpath\nBase.isvalid(::URIs.URI)","category":"page"},{"location":"reference/#URIs.URI","page":"API Reference","title":"URIs.URI","text":"URI(; scheme=\"\", host=\"\", port=\"\", etc...)\nURI(str) = parse(URI, str::String)\n\nA type representing a URI (e.g. a URL). Can be constructed from distinct parts using the various supported keyword arguments, or from a string. The URI constructors will automatically escape any provided query arguments, typically provided as \"key\"=>\"value\"::Pair or Dict(\"key\"=>\"value\"). Note that multiple values for a single query key can provided like Dict(\"key\"=>[\"value1\", \"value2\"]).\n\nWhen constructing a URI from a String, you need to first unescape that string: URI( URIs.unescapeuri(str) ).\n\nThe URI struct stores the complete URI in the uri::String field and the component parts in the following SubString fields:\n\nscheme, e.g. \"http\" or \"https\"\nuserinfo, e.g. \"username:password\"\nhost e.g. \"julialang.org\"\nport e.g. \"80\" or \"\"\npath e.g \"/\"\nquery e.g. \"Foo=1&Bar=2\"\nfragment\n\nThe queryparams(::URI) function returns a Dict containing the query.\n\n\n\n\n\n","category":"type"},{"location":"reference/#URIs.escapeuri","page":"API Reference","title":"URIs.escapeuri","text":"escapeuri(x)\n\nApply URI percent-encoding to escape special characters in x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#URIs.unescapeuri","page":"API Reference","title":"URIs.unescapeuri","text":"unescapeuri(str)\n\nPercent-decode a string according to the URI escaping rules.\n\n\n\n\n\n","category":"function"},{"location":"reference/#URIs.splitpath","page":"API Reference","title":"URIs.splitpath","text":"URIs.splitpath(path|uri; rstrip_empty_segment=true)\n\nSplits the path into component segments based on /, according to http://tools.ietf.org/html/rfc3986#section-3.3. Any fragment and query parts of the string are ignored if present.\n\nA final empty path segment (trailing '/') is removed, if present. This is technically incompatible with the segment grammar of RFC3986, but it seems to be a common recommendation to make paths with and without a trailing slash equivalent. To preserve any final empty path segment, set rstrip_empty_segment=false.\n\nExamples\n\njulia> URIs.splitpath(URI(\"http://example.com/foo/bar?a=b&c=d\"))\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\njulia> URIs.splitpath(\"/foo/bar/\")\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.isvalid-Tuple{URI}","page":"API Reference","title":"Base.isvalid","text":"checks if a URI is valid\n\n\n\n\n\n","category":"method"},{"location":"reference/#Cookies","page":"API Reference","title":"Cookies","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Cookie\nHTTP.Cookies.stringify\nHTTP.Cookies.addcookie!\nHTTP.Cookies.cookies","category":"page"},{"location":"reference/#HTTP.Cookies.Cookie","page":"API Reference","title":"HTTP.Cookies.Cookie","text":"Cookie()\nCookie(; kwargs...)\nCookie(name, value; kwargs...)\n\nA Cookie represents an HTTP cookie as sent in the \"Set-Cookie\" header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:\n\nname::String: name of the cookie\nvalue::String: value of the cookie\npath::String: applicable path for the cookie\ndomain::String: applicable domain for the cookie\nexpires::Dates.DateTime: when the cookie should expire\nmaxage::Int: maxage == 0 means no max age, maxage < 0 means delete cookie now, maxage > 0 means the # of seconds until expiration\nsecure::Bool: secure cookie attribute\nhttponly::Bool: httponly cookie attribute\nhostonly::Bool: hostonly cookie attribute\nsamesite::Bool: SameSite cookie attribute\n\nSee IETF RFC 6265 for details.\n\nThe string representation of a cookie is generated by calling stringify(cookie; isrequest=true), where isrequest=true will only include the name=value pair for requests, and if false, will generate the \"Set-Cookie\" representation for a response header.\n\nA Vector{Cookie} can be retrieved from a Request/Response object by calling Cookies.cookies(r).\n\nA Cookie can be added to a Request/Response object by calling Cookies.addcookie!(r, cookie).\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Cookies.stringify","page":"API Reference","title":"HTTP.Cookies.stringify","text":"stringify(cookie::Cookie, isrequest=true)\n\nGenerate the string representation of a cookie. By default, isrequest=true, and only the name=value pair will be included in the cookie string. For isrequest=false, the other cookie attributes will be included, ;-separated, for use in a \"Set-Cookie\" header.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Cookies.addcookie!","page":"API Reference","title":"HTTP.Cookies.addcookie!","text":"Cookies.addcookie!(r::Union{HTTP.Request, HTTP.Response}, c::Cookie)\n\nConvenience function for adding a single cookie to a request or response object. For requests, the cookie will be stringified and concatenated to any existing \"Cookie\" header. For responses, an additional \"Set-Cookie\" header will be appended.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Cookies.cookies","page":"API Reference","title":"HTTP.Cookies.cookies","text":"HTTP.cookies(r::Union{Request, Response}) -> Vector{Cookie}\n\nReturn a list of cookies, if any, parsed from the request \"Cookie\" or response \"Set-Cookie\" headers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#WebSockets","page":"API Reference","title":"WebSockets","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.WebSockets.send\nHTTP.WebSockets.receive\nHTTP.WebSockets.close\nHTTP.WebSockets.ping\nHTTP.WebSockets.pong\nHTTP.WebSockets.iterate\nHTTP.WebSockets.isclosed\nHTTP.WebSockets.isok","category":"page"},{"location":"reference/#Sockets.send","page":"API Reference","title":"Sockets.send","text":"send(socket::UDPSocket, host::IPAddr, port::Integer, msg)\n\nSend msg over socket to host:port.\n\n\n\n\n\nsend(ws::WebSocket, msg)\n\nSend a message on a websocket connection. If msg is an AbstractString, a TEXT websocket message will be sent; if msg is an AbstractVector{UInt8}, a BINARY websocket message will be sent. Otherwise, msg should be an iterable of either AbstractString or AbstractVector{UInt8}, and a fragmented message will be sent, one frame for each iterated element.\n\nControl frames can be sent by calling ping(ws[, data]), pong(ws[, data]), or close(ws[, body::WebSockets.CloseFrameBody]). Calling close will initiate the close sequence and close the underlying connection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.receive","page":"API Reference","title":"HTTP.WebSockets.receive","text":"receive(ws::WebSocket) -> Union{String, Vector{UInt8}}\n\nReceive a message from a websocket connection. Returns a String if the message was TEXT, or a Vector{UInt8} if the message was BINARY. If control frames (ping or pong) are received, they are handled automatically and a non-control message is waited for. If a CLOSE message is received, it is responded to and a WebSocketError is thrown with the WebSockets.CloseFrameBody as the error value. This error can be checked with WebSockets.isok(err) to see if the closing was \"normal\" or if an actual error occurred. For fragmented messages, the incoming frames will continue to be read until the final fragment is received. The bodies of each fragment are concatenated into the final message returned by receive. Note that WebSocket objects can be iterated, where each iteration yields a message until the connection is closed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.close","page":"API Reference","title":"Base.close","text":"close(stream)\n\nClose an I/O stream. Performs a flush first.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.ping","page":"API Reference","title":"HTTP.WebSockets.ping","text":"ping(ws, data=[])\n\nSend a PING control frame on a websocket connection. data is an optional body to send with the message. PONG messages are automatically responded to when a PING message is received by a websocket connection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.pong","page":"API Reference","title":"HTTP.WebSockets.pong","text":"pong(ws, data=[])\n\nSend a PONG control frame on a websocket connection. data is an optional body to send with the message. Note that PING messages are automatically responded to internally by the websocket connection with a corresponding PONG message, but in certain cases, a unidirectional PONG message can be used as a one-way heartbeat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.iterate","page":"API Reference","title":"Base.iterate","text":"iterate(iter [, state]) -> Union{Nothing, Tuple{Any, Any}}\n\nAdvance the iterator to obtain the next element. If no elements remain, nothing should be returned. Otherwise, a 2-tuple of the next element and the new iteration state should be returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.isclosed","page":"API Reference","title":"HTTP.WebSockets.isclosed","text":"WebSockets.isclosed(ws) -> Bool\n\nCheck whether a WebSocket has sent and received CLOSE frames.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.isok","page":"API Reference","title":"HTTP.WebSockets.isok","text":"WebSockets.isok(x::WebSocketError) -> Bool\n\nReturns true if the WebSocketError has a non-error status code. When calling receive(websocket), if a CLOSE frame is received, the CLOSE frame body is parsed and thrown inside the WebSocketError, but if the CLOSE frame has a non-error status code, it's safe to ignore the error and return from the WebSockets.open or WebSockets.listen calls without throwing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"parse(::Type{<:HTTP.Message}, str::AbstractString)\nHTTP.sniff\nHTTP.Strings.escapehtml\nHTTP.Strings.tocameldash\nHTTP.Strings.iso8859_1_to_utf8\nHTTP.Strings.ascii_lc_isequal\nHTTP.statustext","category":"page"},{"location":"reference/#Base.parse-Tuple{Type{<:HTTP.Messages.Message}, AbstractString}","page":"API Reference","title":"Base.parse","text":"parse(type, str; base)\n\nParse a string as a number. For Integer types, a base can be specified (the default is 10). For floating-point types, the string is parsed as a decimal floating-point number.  Complex types are parsed from decimal strings of the form \"RÂ±Iim\" as a Complex(R,I) of the requested type; \"i\" or \"j\" can also be used instead of \"im\", and \"R\" or \"Iim\" are also permitted. If the string does not contain a valid number, an error is raised.\n\ncompat: Julia 1.1\nparse(Bool, str) requires at least Julia 1.1.\n\nExamples\n\njulia> parse(Int, \"1234\")\n1234\n\njulia> parse(Int, \"1234\", base = 5)\n194\n\njulia> parse(Int, \"afc\", base = 16)\n2812\n\njulia> parse(Float64, \"1.2e-3\")\n0.0012\n\njulia> parse(Complex{Float64}, \"3.2e-1 + 4.5im\")\n0.32 + 4.5im\n\n\n\n\n\nparse(Request, str)\nparse(Response, str)\n\nParse a string into a Request or Response object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HTTP.Sniff.sniff","page":"API Reference","title":"HTTP.Sniff.sniff","text":"`HTTP.sniff(content::Union{Vector{UInt8}, String, IO})` => `String` (mimetype)\n\nHTTP.sniff will look at the first 512 bytes of content to try and determine a valid mimetype. If a mimetype can't be determined appropriately, \"application/octet-stream\" is returned.\n\nSupports JSON detection through the HTTP.isjson(content) function.\n\nExamples\n\njulia> HTTP.sniff(\"Hello world!!\")\n\"text/plain; charset=utf-8\"\n\njulia> HTTP.sniff(\"<html><body>Hello world!!</body></html>\")\n\"text/html; charset=utf-8\"\n\njulia> HTTP.sniff(\"{\"a\": -1.0}\")\n\"application/json; charset=utf-8\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.escapehtml","page":"API Reference","title":"HTTP.Strings.escapehtml","text":"escapehtml(i::String)\n\nReturns a string with special HTML characters escaped: &, <, >, \", '\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.tocameldash","page":"API Reference","title":"HTTP.Strings.tocameldash","text":"tocameldash(s::String)\n\nEnsure the first character and characters that follow a '-' are uppercase.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.iso8859_1_to_utf8","page":"API Reference","title":"HTTP.Strings.iso8859_1_to_utf8","text":"iso8859_1_to_utf8(bytes::AbstractVector{UInt8})\n\nConvert from ISO8859_1 to UTF8.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.ascii_lc_isequal","page":"API Reference","title":"HTTP.Strings.ascii_lc_isequal","text":"Case insensitive ASCII character comparison.\n\n\n\n\n\nHTTP.ascii_lc_isequal(a::String, b::String)\n\nCase insensitive ASCII string comparison.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.statustext","page":"API Reference","title":"HTTP.Messages.statustext","text":"statustext(::Int) -> String\n\nString representation of a HTTP status code.\n\nExamples\n\njulia> statustext(200)\n\"OK\"\n\njulia> statustext(404)\n\"Not Found\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#Server-/-Handlers","page":"API Reference","title":"Server / Handlers","text":"","category":"section"},{"location":"reference/#Core-Server","page":"API Reference","title":"Core Server","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.listen\nHTTP.serve\nWebSockets.listen","category":"page"},{"location":"reference/#HTTP.Servers.listen","page":"API Reference","title":"HTTP.Servers.listen","text":"HTTP.listen([host=Sockets.localhost[, port=8081]]; kw...) do http::HTTP.Stream\n    ...\nend\n\nListen for HTTP connections and execute the do function for each request.\n\nThe do function should be of the form f(::HTTP.Stream)::Nothing, and should at the minimum set a status via setstatus() and call startwrite() either explicitly or implicitly by writing out a response via write().  Failure to do this will result in an HTTP 500 error being transmitted to the client.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl  connections. Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl  verification (useful for testing).\nreuse_limit = nolimit, number of times a connection is allowed to be reused after the first request.\ntcpisvalid = tcp->true, function f(::TCPSocket)::Bool to, check accepted  connection before processing requests. e.g. to do source IP filtering.\nreadtimeout::Int=0, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple servers to listen on the same port.\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows closing the server.\nconnection_count::Ref{Int}, reference to track the number of currently  open connections.\nrate_limit::Rational{Int}=nothing\", number of connections//second  allowed per client IP address; excess connections are immediately closed.  e.g. 5//1.\nverbose::Bool=false, log connection information to stdout.\naccess_log::Function, function for formatting access log messages. The  function should accept two arguments, io::IO to which the messages should  be written, and http::HTTP.Stream which can be used to query information  from. See also @logfmt_str.\non_shutdown::Union{Function, Vector{<:Function}, Nothing}=nothing, one or  more functions to be run if the server is closed (for example by an  InterruptException). Note, shutdown function(s) will not run if an  IOServer object is supplied to the server keyword argument and closed  by close(server).\n\ne.g.\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    HTTP.setheader(http, \"Content-Type\" => \"text/html\")\n    write(http, \"target uri: $(http.message.target)<BR>\")\n    write(http, \"request body:<BR><PRE>\")\n    write(http, read(http))\n    write(http, \"</PRE>\")\n    return\nend\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\nThe server= option can be used to pass an already listening socket to HTTP.listen. This allows manual control of server shutdown.\n\ne.g.\n\nusing Sockets\nserver = Sockets.listen(Sockets.InetAddr(parse(IPAddr, host), port))\n@async HTTP.listen(f, host, port; server=server)\n\n# Closing server will stop HTTP.listen.\nclose(server)\n\nTo run the following HTTP chat example, open two Julia REPL windows and paste the example code into both of them. Then in one window run chat_server() and in the other run chat_client(), then type hello and press return. Whatever you type on the client will be displayed on the server and vis-versa.\n\nusing HTTP\n\nfunction chat(io::HTTP.Stream)\n    @async while !eof(io)\n        write(stdout, readavailable(io), \"\\n\")\n    end\n    while isopen(io)\n        write(io, readline(stdin))\n    end\nend\n\nchat_server() = HTTP.listen(\"127.0.0.1\", 8087) do io\n    write(io, \"HTTP.jl Chat Server. Welcome!\")\n    chat(io)\nend\n\nchat_client() = HTTP.open(\"POST\", \"http://127.0.0.1:8087\") do io\n    chat(io)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.serve","page":"API Reference","title":"HTTP.Handlers.serve","text":"HTTP.serve(f, host, port; stream::Bool=false, kw...)\n\nStart a server on the given host and port; for each incoming request, call the given handler function f, which should be of the form f(req::HTTP.Request) -> HTTP.Response. If stream is true, the handler function should be of the form f(stream::HTTP.Stream) -> Nothing. Accepts all the same keyword arguments (and passes them along) to HTTP.listen, including:\n\nsslconfig: custom SSLConfig to support ssl connections\ntcpisvalid: custom function to validate tcp connections\nserver: a server Socket that a user can manage (closing listening, etc.)\nreuseaddr: whether another server can listen on the same host/port (unix only)\nmax_connections: max number of simultaneous connections allowed\nconnection_count: a Ref{Int} to keep track of currently open connections\nreadtimeout: time in seconds (integer) that the server should wait for a request to be sent\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.listen","page":"API Reference","title":"HTTP.WebSockets.listen","text":"WebSockets.listen(handler, host, port; verbose=false, kw...)\n\nListen for websocket connections on host and port, and call handler(ws), which should be a function taking a single WebSocket argument. Keyword arguments kw... are the same as supported by HTTP.listen. Typical usage is like: ```julia WebSockets.listen(host, port) do ws     # iterate incoming websocket messages     for msg in ws         # send message back to client or do other logic here         send(ws, msg)     end     # iteration ends when the websocket connection is closed by client or error end\n\n\n\n\n\n","category":"function"},{"location":"reference/#Middleware-/-Handlers","page":"API Reference","title":"Middleware / Handlers","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Handler\nHTTP.Middleware\nHTTP.streamhandler\nHTTP.Router\nHTTP.register!\nHTTP.getparams\nHTTP.Handlers.cookie_middleware\nHTTP.getcookies\nHTTP.@logfmt_str","category":"page"},{"location":"reference/#HTTP.Handlers.Handler","page":"API Reference","title":"HTTP.Handlers.Handler","text":"Handler\n\nAbstract type for the handler interface that exists for documentation purposes. A Handler is any function of the form f(req::HTTP.Request) -> HTTP.Response. There is no requirement to subtype Handler and users should not rely on or dispatch on Handler. A Handler function f can be passed to HTTP.serve wherein a server will pass each incoming request to f to be handled and a response to be returned. Handler functions are also the inputs to Middleware functions which are functions of the form f(::Handler) -> Handler, i.e. they take a Handler function as input, and return a \"modified\" or enhanced Handler function.\n\nFor advanced cases, a Handler function can also be of the form f(stream::HTTP.Stream) -> Nothing. In this case, the server would be run like HTTP.serve(f, ...; stream=true). For this use-case, the handler function reads the request and writes the response to the stream directly. Note that any middleware used with a stream handler also needs to be of the form f(stream_handler) -> stream_handler, i.e. it needs to accept a stream Handler function and return a stream Handler function.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Handlers.Middleware","page":"API Reference","title":"HTTP.Handlers.Middleware","text":"Middleware\n\nAbstract type for the middleware interface that exists for documentation purposes. A Middleware is any function of the form f(::Handler) -> Handler (ref: Handler). There is no requirement to subtype Middleware and users should not rely on or dispatch on the Middleware type. While HTTP.serve(f, ...) requires a handler function f to be passed, middleware can be \"stacked\" to create a chain of functions that are called in sequence, like HTTP.serve(base_handler |> cookie_middleware |> auth_middlware, ...), where the base_handler Handler function is passed to cookie_middleware, which takes the handler and returns a \"modified\" handler (that parses and stores cookies). This \"modified\" handler is then an input to the auth_middlware, which further enhances/modifies the handler.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Handlers.streamhandler","page":"API Reference","title":"HTTP.Handlers.streamhandler","text":"streamhandler(request_handler) -> stream handler\n\nMiddleware that takes a request handler and returns a stream handler. Used by default in HTTP.serve to take the user-provided request handler and process the Stream from HTTP.listen and pass the parsed Request to the handler.\n\nIs included by default in HTTP.serve as the base \"middleware\" when stream=false is passed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.Router","page":"API Reference","title":"HTTP.Handlers.Router","text":"HTTP.Router(_404, _405)\n\nDefine a router object that maps incoming requests by path to registered routes and associated handlers. Paths can be registered using HTTP.register!. The router object itself is a \"request handler\" that can be called like:\n\nr = HTTP.Router()\nresp = r(reqest)\n\nWhich will inspect the request, find the matching, registered handler from the url, and pass the request on to be handled further.\n\nSee HTTP.register! for additional information on registering handlers based on routes.\n\nIf a request doesn't have a matching, registered handler, the _404 handler is called which, by default, returns a HTTP.Response(404). If a route matches the path, but not the method/verb (e.g. there's a registerd route for \"GET /api\", but the request is \"POST /api\"), then the _405 handler is called, which by default returns HTTP.Response(405) (method not allowed).\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Handlers.register!","page":"API Reference","title":"HTTP.Handlers.register!","text":"HTTP.register!(r::Router, method, path, handler)\nHTTP.register!(r::Router, path, handler)\n\nRegister a handler function that should be called when an incoming request matches path and the optionally provided method (if not provided, any method is allowed). Can be used to dynamically register routes. The following path types are allowed for matching:\n\n/api/widgets: exact match of static strings\n/api/*/owner: single * to wildcard match anything for a single segment\n/api/widget/{id}: Define a path variable id that matches any valued provided for this segment; path variables are available in the request context like HTTP.getparams(req)[\"id\"]\n/api/widget/{id:[0-9]+}: Define a path variable id that does a regex match for integers for this segment\n/api/**: double wildcard matches any number of trailing segments in the request path; the double wildcard must be the last segment in the path\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.getparams","page":"API Reference","title":"HTTP.Handlers.getparams","text":"HTTP.getparams(req) -> Dict{String, String}\n\nRetrieve any matched path parameters from the request context. If a path was registered with a router via HTTP.register! like \"/api/widget/{id}\", then the path parameters are available in the request context and can be retrieved like id = HTTP.getparams(req)[\"id\"].\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.cookie_middleware","page":"API Reference","title":"HTTP.Handlers.cookie_middleware","text":"HTTP.Handlers.cookie_middleware(handler) -> handler\n\nMiddleware that parses and stores any cookies in the incoming request in the request context. Cookies can then be retrieved by calling HTTP.getcookies(req) in subsequent middlewares/handlers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.getcookies","page":"API Reference","title":"HTTP.Handlers.getcookies","text":"HTTP.getcookies(req) -> Vector{Cookie}\n\nRetrieve any parsed cookies from a request context. Cookies are expected to be stored in the req.context[:cookies] of the request context as implemented in the HTTP.Handlers.cookie_middleware middleware.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.@logfmt_str","page":"API Reference","title":"HTTP.@logfmt_str","text":"logfmt\"...\"\n\nParse an NGINX-style log format string and return a function mapping (io::IO, http::HTTP.Stream) -> body suitable for passing to HTTP.listen using the access_log keyword argument.\n\nThe following variables are currently supported:\n\n$http_name: arbitrary request header (with - replaced with _, e.g. http_user_agent)\n$sent_http_name: arbitrary response header (with - replaced with _)\n$request: the request line, e.g. GET /index.html HTTP/1.1\n$request_method: the request method\n$request_uri: the request URI\n$remote_addr: client address\n$remote_port: client port\n$remote_user: user name supplied with the Basic authentication\n$server_protocol: server protocol\n$time_iso8601: local time in ISO8601 format\n$time_local: local time in Common Log Format\n$status: response status code\n$body_bytes_sent: number of bytes in response body\n\nExamples\n\nlogfmt\"[$time_iso8601] \\\"$request\\\" $status\" # [2021-05-01T12:34:40+0100] \"GET /index.html HTTP/1.1\" 200\n\nlogfmt\"$remote_addr \\\"$http_user_agent\\\"\" # 127.0.0.1 \"curl/7.47.0\"\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Advanced-Topics","page":"API Reference","title":"Advanced Topics","text":"","category":"section"},{"location":"reference/#Messages-Interface","page":"API Reference","title":"Messages Interface","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Messages.iserror\nHTTP.Messages.isredirect\nHTTP.Messages.ischunked\nHTTP.Messages.issafe\nHTTP.Messages.isidempotent\nHTTP.Messages.retryable\nHTTP.Messages.defaultheader!\nHTTP.Messages.readheaders\nHTTP.DefaultHeadersRequest.setuseragent!\nHTTP.Messages.readchunksize\nHTTP.Messages.headerscomplete(::HTTP.Messages.Response)\nHTTP.Messages.writestartline\nHTTP.Messages.writeheaders\nBase.write(::IO,::HTTP.Messages.Message)\nHTTP.Streams.closebody\nHTTP.Streams.isaborted","category":"page"},{"location":"reference/#HTTP.Messages.iserror","page":"API Reference","title":"HTTP.Messages.iserror","text":"iserror(::Response)\n\nDoes this Response have an error status?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.isredirect","page":"API Reference","title":"HTTP.Messages.isredirect","text":"isredirect(::Response)\n\nDoes this Response have a redirect status?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.ischunked","page":"API Reference","title":"HTTP.Messages.ischunked","text":"ischunked(::Message)\n\nDoes the Message have a \"Transfer-Encoding: chunked\" header?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.issafe","page":"API Reference","title":"HTTP.Messages.issafe","text":"issafe(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.1\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.isidempotent","page":"API Reference","title":"HTTP.Messages.isidempotent","text":"isidempotent(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.2\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.retryable","page":"API Reference","title":"HTTP.Messages.retryable","text":"retryable(::Request)\n\nWhether a Request is eligible to be retried.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.defaultheader!","page":"API Reference","title":"HTTP.Messages.defaultheader!","text":"defaultheader!(::Message, key => value)\n\nSet header value in message for key if it is not already set.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.readheaders","page":"API Reference","title":"HTTP.Messages.readheaders","text":"readheaders(::IO, ::Message)\n\nRead headers (and startline) from an IO stream into a Message struct. Throw EOFError if input is incomplete.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.DefaultHeadersRequest.setuseragent!","page":"API Reference","title":"HTTP.DefaultHeadersRequest.setuseragent!","text":"setuseragent!(x::Union{String, Nothing})\n\nSet the default User-Agent string to be used in each HTTP request. Can be manually overridden by passing an explicit User-Agent header. Setting nothing will prevent the default User-Agent header from being passed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.readchunksize","page":"API Reference","title":"HTTP.Messages.readchunksize","text":"Read chunk-size from an IO stream. After the final zero size chunk, read trailers into a Message struct.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}","page":"API Reference","title":"HTTP.Messages.headerscomplete","text":"headerscomplete(::Message)\n\nHave the headers been read into this Message?\n\n\n\n\n\n","category":"method"},{"location":"reference/#HTTP.Messages.writestartline","page":"API Reference","title":"HTTP.Messages.writestartline","text":"writestartline(::IO, ::Message)\n\ne.g. \"GET /path HTTP/1.1\\r\\n\" or \"HTTP/1.1 200 OK\\r\\n\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.writeheaders","page":"API Reference","title":"HTTP.Messages.writeheaders","text":"writeheaders(::IO, ::Message)\n\nWrite Message start line and a line for each \"name: value\" pair and a trailing blank line.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.write-Tuple{IO, HTTP.Messages.Message}","page":"API Reference","title":"Base.write","text":"write(::IO, ::Message)\n\nWrite start line, headers and body of HTTP Message.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HTTP.Streams.closebody","page":"API Reference","title":"HTTP.Streams.closebody","text":"closebody(::Stream)\n\nWrite the final 0 chunk if needed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Streams.isaborted","page":"API Reference","title":"HTTP.Streams.isaborted","text":"isaborted(::Stream{<:Response})\n\nHas the server signaled that it does not wish to receive the message body?\n\n\"If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.\" RFC7230, 6.5\n\n\n\n\n\n","category":"function"},{"location":"reference/#Cookie-Persistence","page":"API Reference","title":"Cookie Persistence","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Cookies.CookieJar\nHTTP.Cookies.getcookies!\nHTTP.Cookies.setcookies!","category":"page"},{"location":"reference/#HTTP.Cookies.CookieJar","page":"API Reference","title":"HTTP.Cookies.CookieJar","text":"CookieJar()\n\nA thread-safe object for storing cookies returned in \"Set-Cookie\" response headers. Keyed by appropriate host from the original request made. Can be created manually and passed like HTTP.get(url; cookiejar=mycookiejar) to avoid using the default global CookieJar. The 2 main functions for interacting with a CookieJar are Cookies.getcookies!, which returns a Vector{Cookie} for a given url (and will remove expired cookies from the jar), and Cookies.setcookies!, which will store \"Set-Cookie\" response headers in the cookie jar.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Cookies.getcookies!","page":"API Reference","title":"HTTP.Cookies.getcookies!","text":"Cookies.getcookies!(jar::CookieJar, url::URI)\n\nRetrieve valid Cookies from the CookieJar according to the provided url. Cookies will be returned as a Vector{Cookie}. Only cookies for http or https scheme in the url will be returned. Cookies will be checked according to the canonical host of the url and any cookie max age or expiration will be accounted for. Expired cookies will not be returned and will be removed from the cookie jar.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Cookies.setcookies!","page":"API Reference","title":"HTTP.Cookies.setcookies!","text":"Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers)\n\nIdentify, \"Set-Cookie\" response headers from headers, parse the Cookies, and store valid entries in the cookie jar according to the canonical host in url. Cookies can be retrieved from the jar via Cookies.getcookies!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Client-side-Middleware-(Layers)","page":"API Reference","title":"Client-side Middleware (Layers)","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Layer\nHTTP.@client\nHTTP.pushlayer!\nHTTP.pushfirstlayer!\nHTTP.poplayer!\nHTTP.popfirstlayer!\nHTTP.MessageRequest.messagelayer\nHTTP.RedirectRequest.redirectlayer\nHTTP.DefaultHeadersRequest.defaultheaderslayer\nHTTP.BasicAuthRequest.basicauthlayer\nHTTP.CookieRequest.cookielayer\nHTTP.CanonicalizeRequest.canonicalizelayer\nHTTP.TimeoutRequest.timeoutlayer\nHTTP.ExceptionRequest.exceptionlayer\nHTTP.RetryRequest.retrylayer\nHTTP.ConnectionRequest.connectionlayer\nHTTP.DebugRequest.debuglayer\nHTTP.StreamRequest.streamlayer\nHTTP.ContentTypeDetection.contenttypedetectionlayer","category":"page"},{"location":"reference/#HTTP.Layer","page":"API Reference","title":"HTTP.Layer","text":"Layer\n\nAbstract type to represent a client-side middleware that exists for documentation purposes. A layer is any function of the form f(::Handler) -> Handler, where Handler is a function of the form f(::Request) -> Response. Note that the Handler definition is from the server-side documentation, and is \"hard-coded\" on the client side. It may also be apparent that a Layer is the same as the Middleware interface from server-side, which is true, but we define Layer to clarify the client-side distinction and its unique usage. Custom layers can be deployed in one of two ways:\n\nHTTP.@client: Create a custom \"client\" with shorthand verb definitions, but which include custom layers; only these new verb methods will use the custom layers.\nHTTP.pushlayer!/HTTP.poplayer!: Allows globally adding and removing layers from the default HTTP.jl layer stack; all http requests will then use the custom layers\n\nQuick Examples\n\nmodule Auth\n\nusing HTTP\n\nfunction auth_layer(handler)\n    # returns a `Handler` function; check for a custom keyword arg `authcreds` that\n    # a user would pass like `HTTP.get(...; authcreds=creds)`.\n    # We also accept trailing keyword args `kw...` and pass them along later.\n    return function(req; authcreds=nothing, kw...)\n        # only apply the auth layer if the user passed `authcreds`\n        if authcreds !== nothing\n            # we add a custom header with stringified auth creds\n            HTTP.setheader(req, \"X-Auth-Creds\" => string(authcreds))\n        end\n        # pass the request along to the next layer by calling `auth_layer` arg `handler`\n        # also pass along the trailing keyword args `kw...`\n        return handler(req; kw...)\n    end\nend\n\n# Create a new client with the auth layer added\nHTTP.@client [auth_layer]\n\nend # module\n\n# Can now use custom client like:\nAuth.get(url; authcreds=creds) # performs GET request with auth_layer layer included\n\n# Or can include layer globally in all HTTP.jl requests\nHTTP.pushlayer!(Auth.auth_layer)\n\n# Now can use normal HTTP.jl methods and auth_layer will be included\nHTTP.get(url; authcreds=creds)\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.@client","page":"API Reference","title":"HTTP.@client","text":"HTTP.@client [requestlayers]\nHTTP.@client [requestlayers] [streamlayers]\n\nConvenience macro for creating a custom HTTP.jl client that will include custom layers when performing requests. It's common to want to define a custom Layer to enhance a specific category of requests, such as custom authentcation for a web API. Instead of affecting the global HTTP.jl request stack via HTTP.pushlayer!, a custom wrapper client can be defined with convenient shorthand methods. See Layer for an example of defining a custom layer and creating a new client that includes the layer.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#HTTP.pushlayer!","page":"API Reference","title":"HTTP.pushlayer!","text":"HTTP.pushlayer!(layer; request=true)\n\nPush a layer onto the stack of layers that will be applied to all requests. The \"layer\" is expected to be a function that takes and returns a Handler function. See Layer for more details. If request=false, the layer is expected to take and return a \"stream\" handler function. The custom layer will be put on the top of the stack, so it will be the first layer executed. To add a layer at the bottom of the stack, see HTTP.pushfirstlayer!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.pushfirstlayer!","page":"API Reference","title":"HTTP.pushfirstlayer!","text":"HTTP.pushfirstlayer!(layer; request=true)\n\nPush a layer to the start of the stack of layers that will be applied to all requests. The \"layer\" is expected to be a function that takes and returns a Handler function. See Layer for more details. If request=false, the layer is expected to take and return a \"stream\" handler function. The custom layer will be put on the bottom of the stack, so it will be the last layer executed. To add a layer at the top of the stack, see HTTP.pushlayer!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.poplayer!","page":"API Reference","title":"HTTP.poplayer!","text":"HTTP.poplayer!(layer; request=true)\n\nInverse of HTTP.pushlayer!, removes the top layer of the global HTTP.jl layer stack. Can be used to \"cleanup\" after a custom layer has been added. If request=false, will remove the top \"stream\" layer as opposed to top \"request\" layer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.popfirstlayer!","page":"API Reference","title":"HTTP.popfirstlayer!","text":"HTTP.popfirstlayer!(layer; request=true)\n\nInverse of HTTP.pushfirstlayer!, removes the bottom layer of the global HTTP.jl layer stack. Can be used to \"cleanup\" after a custom layer has been added. If request=false, will remove the bottom \"stream\" layer as opposed to bottom \"request\" layer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.MessageRequest.messagelayer","page":"API Reference","title":"HTTP.MessageRequest.messagelayer","text":"messagelayer(handler) -> handler\n\nConstruct a Request object from method, url, headers, and body. Hard-coded as the first layer in the request pipeline.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.RedirectRequest.redirectlayer","page":"API Reference","title":"HTTP.RedirectRequest.redirectlayer","text":"redirectlayer(handler) -> handler\n\nRedirects the request in the case of 3xx response status.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.DefaultHeadersRequest.defaultheaderslayer","page":"API Reference","title":"HTTP.DefaultHeadersRequest.defaultheaderslayer","text":"defaultheaderslayer(handler) -> handler\n\nSets default expected headers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.BasicAuthRequest.basicauthlayer","page":"API Reference","title":"HTTP.BasicAuthRequest.basicauthlayer","text":"basicauthlayer(handler) -> handler\n\nAdd Authorization: Basic header using credentials from url userinfo.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.CookieRequest.cookielayer","page":"API Reference","title":"HTTP.CookieRequest.cookielayer","text":"cookielayer(handler) -> handler\n\nCheck for host-appropriate cookies to include in the outgoing request from the cookiejar keyword argument (by default, a global cookiejar is used). Store \"Set-Cookie\" cookies from the response headers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.CanonicalizeRequest.canonicalizelayer","page":"API Reference","title":"HTTP.CanonicalizeRequest.canonicalizelayer","text":"canonicalizelayer(handler) -> handler\n\nRewrite request and response headers in Canonical-Camel-Dash-Format.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.TimeoutRequest.timeoutlayer","page":"API Reference","title":"HTTP.TimeoutRequest.timeoutlayer","text":"timeoutlayer(handler) -> handler\n\nClose the HTTP.Stream if no data has been received for readtimeout seconds.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ExceptionRequest.exceptionlayer","page":"API Reference","title":"HTTP.ExceptionRequest.exceptionlayer","text":"exceptionlayer(handler) -> handler\n\nThrow a StatusError if the request returns an error response status.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.RetryRequest.retrylayer","page":"API Reference","title":"HTTP.RetryRequest.retrylayer","text":"retrylayer(handler) -> handler\n\nRetry the request if it throws a recoverable exception.\n\nBase.retry and Base.ExponentialBackOff implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.\n\nMethods of isrecoverable(e) define which exception types lead to a retry. e.g. Sockets.DNSError, Base.EOFError and HTTP.StatusError (if status is 5xx).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ConnectionRequest.connectionlayer","page":"API Reference","title":"HTTP.ConnectionRequest.connectionlayer","text":"connectionlayer(handler) -> handler\n\nRetrieve an IO connection from the ConnectionPool.\n\nClose the connection if the request throws an exception. Otherwise leave it open so that it can be reused.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.DebugRequest.debuglayer","page":"API Reference","title":"HTTP.DebugRequest.debuglayer","text":"debuglayer(handler) -> handler\n\nIf verbose keyword arg is > 0, or the HTTP.jl global DEBUG_LEVEL[] is > 0, then enabled debug logging with verbosity verbose for the lifetime of the request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.StreamRequest.streamlayer","page":"API Reference","title":"HTTP.StreamRequest.streamlayer","text":"streamlayer(stream) -> HTTP.Response\n\nCreate a Stream to send a Request and body to an IO stream and read the response.\n\nSend the Request body in a background task and begins reading the response immediately so that the transmission can be aborted if the Response status indicates that the server does not wish to receive the message body. RFC7230 6.5.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ContentTypeDetection.contenttypedetectionlayer","page":"API Reference","title":"HTTP.ContentTypeDetection.contenttypedetectionlayer","text":"contenttypedetectionlayer(handler) -> handler\n\nTry and detect the content type of the request body and add the \"Content-Type\" header.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Raw-Request-Connection","page":"API Reference","title":"Raw Request Connection","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.openraw\nHTTP.Connection","category":"page"},{"location":"reference/#HTTP.openraw","page":"API Reference","title":"HTTP.openraw","text":"HTTP.openraw(method, url, [, headers])::Tuple{Connection, Response}\n\nOpen a raw socket that is unmanaged by HTTP.jl. Useful for doing HTTP upgrades to other protocols.  Any bytes of the body read from the socket when reading headers, is returned as excess bytes in the last tuple argument.\n\nExample of a WebSocket upgrade:\n\nheaders = Dict(\n    \"Upgrade\" => \"websocket\",\n    \"Connection\" => \"Upgrade\",\n    \"Sec-WebSocket-Key\" => \"dGhlIHNhbXBsZSBub25jZQ==\",\n    \"Sec-WebSocket-Version\" => \"13\")\n\nsocket, response, excess = HTTP.openraw(\"GET\", \"ws://echo.websocket.org\", headers)\n\n# Write a WebSocket frame\nframe = UInt8[0x81, 0x85, 0x37, 0xfa, 0x21, 0x3d, 0x7f, 0x9f, 0x4d, 0x51, 0x58]\nwrite(socket, frame)\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ConnectionPool.Connection","page":"API Reference","title":"HTTP.ConnectionPool.Connection","text":"Connection\n\nA TCPSocket or SSLContext connection to a HTTP host and port.\n\nFields:\n\nhost::String\nport::String, exactly as specified in the URI (i.e. may be empty).\nidle_timeout, No. of seconds to maintain connection after last request/response.\nrequire_ssl_verification, whether ssl verification is required for an ssl connection\npeerip, remote IP adress (used for debug/log messages).\npeerport, remote TCP port number (used for debug/log messages).\nlocalport, local TCP port number (used for debug messages).\nio::T, the TCPSocket or `SSLContext.\nclientconnection::Bool, whether the Connection was created from client code (as opposed to server code)\nbuffer::IOBuffer, left over bytes read from the connection after  the end of a response header (or chunksize). These bytes are usually  part of the response body.\ntimestamp, time data was last received.\nreadable, whether the Connection object is readable\nwriteable, whether the Connection object is writable\n\n\n\n\n\n","category":"type"},{"location":"reference/#Parser-Interface","page":"API Reference","title":"Parser Interface","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Parsers.find_end_of_header\nHTTP.Parsers.find_end_of_chunk_size\nHTTP.Parsers.find_end_of_trailer\nHTTP.Parsers.parse_status_line!\nHTTP.Parsers.parse_request_line!\nHTTP.Parsers.parse_header_field\nHTTP.Parsers.parse_chunk_size","category":"page"},{"location":"reference/#HTTP.Parsers.find_end_of_header","page":"API Reference","title":"HTTP.Parsers.find_end_of_header","text":"find_end_of_header(bytes) -> length or 0\n\nFind length of header delimited by \\r\\n\\r\\n or \\n\\n.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.find_end_of_chunk_size","page":"API Reference","title":"HTTP.Parsers.find_end_of_chunk_size","text":"Find \\n after chunk size in bytes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.find_end_of_trailer","page":"API Reference","title":"HTTP.Parsers.find_end_of_trailer","text":"find_end_of_trailer(bytes) -> length or 0\n\nFind length of trailer delimited by \\r\\n\\r\\n (or starting with \\r\\n). RFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_status_line!","page":"API Reference","title":"HTTP.Parsers.parse_status_line!","text":"Parse HTTP response-line bytes and set the status and version fields of response. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_request_line!","page":"API Reference","title":"HTTP.Parsers.parse_request_line!","text":"Parse HTTP request-line bytes and set the method, target and version fields of request. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_header_field","page":"API Reference","title":"HTTP.Parsers.parse_header_field","text":"Parse HTTP header-field. Return Pair(field-name => field-value) and a SubString containing the remaining header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_chunk_size","page":"API Reference","title":"HTTP.Parsers.parse_chunk_size","text":"Parse HTTP chunk-size. Return number of bytes of chunk-data.\n\nchunk-size = 1*HEXDIG\n\nRFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"#HTTP.jl-Documentation","page":"Home","title":"HTTP.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.jl provides both client and server functionality for the http protocol. As a client, it provides the ability to make a wide range of request, including GET, POST, websocket upgrades, form data, multipart, chunking, and cookie handling. On the server side, it provides the ability to listen, accept, and route http requests, with middleware and handler interfaces to provide flexibility in processing responses.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#Making-requests-(client)","page":"Home","title":"Making requests (client)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.request sends an http request and returns a response.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# make a GET request, both forms are equivalent\nresp = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nresp = HTTP.get(\"http://httpbin.org/ip\")\nprintln(resp.status)\nprintln(String(resp.body))\n\n# make a POST request, sending data via `body` keyword argument\nresp = HTTP.post(\"http://httpbin.org/body\"; body=\"request body\")\n\n# include query parameters in a request\n# and turn on verbose logging of the request/response process\nresp = HTTP.get(\"http://httpbin.org/anything\"; query=[\"hello\" => \"world\"], verbose=2)","category":"page"},{"location":"#Handling-requests-(server)","page":"Home","title":"Handling requests (server)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.serve(@ref) allows specifying middleware + handlers for how incoming requests should be processed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# authentication middleware to ensure property security\nfunction auth(handler)\n    return function(req)\n        ident = parse_auth(req)\n        if ident === nothing\n            # failed to security authentication\n            return HTTP.Response(401, \"unauthorized\")\n        else\n            # store parsed identity in request context for handler usage\n            req.context[:auth] = ident\n            # pass request on to handler function for further processing\n            return handler(req)\n        end\n    end\nend\n\n# handler function to return specific user's data\nfunction handler(req)\n    ident = req.context[:auth]\n    return HTTP.Response(200, get_user_data(ident))\nend\n\n# start a server listening on port 8081 (default port) for localhost (default host)\n# requests will first be handled by teh auth middleware before being passed to the `handler`\n# request handler function\nHTTP.serve(auth(handler))","category":"page"},{"location":"#Further-Documentation","page":"Home","title":"Further Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the client and server-specific documentation pages for more in-depth discussions and examples for the many configurations available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"client.md\", \"server.md\", \"reference.md\"]","category":"page"},{"location":"#manual","page":"Home","title":"manual","text":"","category":"section"},{"location":"#client","page":"Home","title":"client","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# making requests\n# sections for keyword args + links to examples\n# utilities","category":"page"},{"location":"#server","page":"Home","title":"server","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"# running basic server\n# middleware/handlers framework\n# logfmt\"...\"","category":"page"}]
}
