var documenterSearchIndex = {"docs":
[{"location":"#HTTP.jl-Documentation-1","page":"Home","title":"HTTP.jl Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"HTTP.jl is a Julia library for HTTP Messages.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"HTTP.request sends a HTTP Request Message and returns a Response Message.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"r = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nprintln(r.status)\nprintln(String(r.body))","category":"page"},{"location":"#","page":"Home","title":"Home","text":"HTTP.open sends a HTTP Request Message and opens an IO stream from which the Response can be read.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"HTTP.open(\"GET\", \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\"public_interface.md\", \"internal_architecture.md\", \"internal_interface.md\"]","category":"page"},{"location":"public_interface/#Public-Interface-1","page":"Public Interface","title":"Public Interface","text":"","category":"section"},{"location":"public_interface/#Requests-1","page":"Public Interface","title":"Requests","text":"","category":"section"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"HTTP.request\nHTTP.open\nHTTP.get\nHTTP.put\nHTTP.post\nHTTP.head","category":"page"},{"location":"public_interface/#HTTP.request","page":"Public Interface","title":"HTTP.request","text":"HTTP.request(method, url [, headers [, body]]; <keyword arguments>]) -> HTTP.Response\n\nSend a HTTP Request Message and receive a HTTP Response Message.\n\ne.g.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nprintln(r.status)\nprintln(String(r.body))\n\nheaders can be any collection where [string(k) => string(v) for (k,v) in headers] yields Vector{Pair}. e.g. a Dict(), a Vector{Tuple}, a Vector{Pair} or an iterator.\n\nbody can take a number of forms:\n\na String, a Vector{UInt8} or any T accepted by write(::IO, ::T)\na collection of String or AbstractVector{UInt8} or IO streams or items of any type T accepted by write(::IO, ::T...)\na readable IO stream or any IO-like type T for which eof(T) and readavailable(T) are defined.\n\nThe HTTP.Response struct contains:\n\nstatus::Int16 e.g. 200\nheaders::Vector{Pair{String,String}}  e.g. [\"Server\" => \"Apache\", \"Content-Type\" => \"text/html\"]\nbody::Vector{UInt8}, the Response Body bytes  (empty if a response_stream was specified in the request).\n\nFunctions HTTP.get, HTTP.put, HTTP.post and HTTP.head are defined as shorthand for HTTP.request(\"GET\", ...), etc.\n\nHTTP.request and HTTP.open also accept optional keyword parameters.\n\ne.g.\n\nHTTP.request(\"GET\", \"http://httpbin.org/ip\"; retries=4, cookies=true)\n\nHTTP.get(\"http://s3.us-east-1.amazonaws.com/\"; aws_authorization=true)\n\nconf = (readtimeout = 10,\n        pipeline_limit = 4,\n        retry = false,\n        redirect = false)\n\nHTTP.get(\"http://httpbin.org/ip\"; conf..)\nHTTP.put(\"http://httpbin.org/put\", [], \"Hello\"; conf..)\n\nURL options\n\nquery = nothing, replaces the query part of url.\n\nStreaming options\n\nresponse_stream = nothing, a writeable IO stream or any IO-like  type T for which write(T, AbstractVector{UInt8}) is defined.\nverbose = 0, set to 1 or 2 for extra message logging.\n\nConnection Pool options\n\nconnection_limit = 8, number of concurrent connections to each host:port.\npipeline_limit = 16, number of concurrent requests per connection.\nreuse_limit = nolimit, number of times a connection is reused after the                          first request.\nsocket_type = TCPSocket\n\nTimeout options\n\nreadtimeout = 60, close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable.\n\nRetry options\n\nretry = true, retry idempotent requests in case of error.\nretries = 4, number of times to retry.\nretry_non_idempotent = false, retry non-idempotent requests too. e.g. POST.\n\nRedirect options\n\nredirect = true, follow 3xx redirect responses.\nredirect_limit = 3, number of times to redirect.\nforwardheaders = true, forward original headers on redirect.\n\nStatus Exception options\n\nstatus_exception = true, throw HTTP.StatusError for response status >= 300.\n\nSSLContext options\n\nrequire_ssl_verification = false, pass MBEDTLS_SSL_VERIFY_REQUIRED to the mbed TLS library. \"... peer must present a valid certificate, handshake is aborted if   verification failed.\"\nsslconfig = SSLConfig(require_ssl_verification)\n\nBasic Authentication options\n\nbasic_authorization=false, add Authorization: Basic header using credentials from url userinfo.\n\nAWS Authentication options\n\naws_authorization = false, enable AWS4 Authentication.\naws_service = split(url.host, \".\")[1]\naws_region = split(url.host, \".\")[2]\naws_access_key_id = ENV[\"AWS_ACCESS_KEY_ID\"]\naws_secret_access_key = ENV[\"AWS_SECRET_ACCESS_KEY\"]\naws_session_token = get(ENV, \"AWS_SESSION_TOKEN\", \"\")\nbody_sha256 = digest(MD_SHA256, body),\nbody_md5 = digest(MD_MD5, body),\n\nCookie options\n\ncookies::Union{Bool, Dict{String, String}} = false, enable cookies, or alternatively,      pass a Dict{String, String} of name-value pairs to manually pass cookies\ncookiejar::Dict{String, Set{Cookie}}=default_cookiejar,\n\nCanonicalization options\n\ncanonicalize_headers = false, rewrite request and response headers in Canonical-Camel-Dash-Format.\n\nRequest Body Examples\n\nString body:\n\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], \"post body data\")\n\nStream body from file:\n\nio = open(\"post_data.txt\", \"r\")\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], io)\n\nGenerator body:\n\nchunks = (\"chunk$i\" for i in 1:1000)\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nCollection body:\n\nchunks = [preamble_chunk, data_chunk, checksum(data_chunk)]\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nopen() do io body:\n\nHTTP.open(\"POST\", \"http://httpbin.org/post\") do io\n    write(io, preamble_chunk)\n    write(io, data_chunk)\n    write(io, checksum(data_chunk))\nend\n\nResponse Body Examples\n\nString body:\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\")\nprintln(String(r.body))\n\nStream body to file:\n\nio = open(\"get_data.txt\", \"w\")\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\nprintln(read(\"get_data.txt\"))\n\nStream body through buffer:\n\nio = Base.BufferStream()\n@async while !eof(io)\n    bytes = readavailable(io))\n    println(\"GET data: $bytes\")\nend\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\n\nStream body through open() do io:\n\nr = HTTP.open(\"GET\", \"http://httpbin.org/stream/10\") do io\n   while !eof(io)\n       println(String(readavailable(io)))\n   end\nend\n\nusing HTTP.IOExtras\n\nHTTP.open(\"GET\", \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    n = 0\n    r = startread(http)\n    l = parse(Int, header(r, \"Content-Length\"))\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        while !eof(http)\n            bytes = readavailable(http)\n            write(vlc, bytes)\n            n += length(bytes)\n            println(\"streamed $n-bytes $((100*n)Ã·l)%\\u1b[1A\")\n        end\n    end\nend\n\nRequest and Response Body Examples\n\nString bodies:\n\nr = HTTP.request(\"POST\", \"http://httpbin.org/post\", [], \"post body data\")\nprintln(String(r.body))\n\nInterfacing with RESTful JSON APIs:\n\nusing JSON\nparams = Dict(\"user\"=>\"RAO...tjN\", \"token\"=>\"NzU...Wnp\", \"message\"=>\"Hello!\")\nbase_url = \"http://api.domain.com\"\nendpoint = \"/1/messages.json\"\nurl = base_url * endpoint\nr = HTTP.request(\"POST\", url,\n             [\"Content-Type\" => \"application/json\"],\n             JSON.json(params))\nprintln(JSON.parse(String(r.body)))\n\nStream bodies from and to files:\n\nin = open(\"foo.png\", \"r\")\nout = open(\"foo.jpg\", \"w\")\nHTTP.request(\"POST\", \"http://convert.com/png2jpg\", [], in, response_stream=out)\n\nStream bodies through: open() do io:\n\nusing HTTP.IOExtras\n\nHTTP.open(\"POST\", \"http://music.com/play\") do io\n    write(io, JSON.json([\n        \"auth\" => \"12345XXXX\",\n        \"song_id\" => 7,\n    ]))\n    r = startread(io)\n    @show r.status\n    while !eof(io)\n        bytes = readavailable(io))\n        play_audio(bytes)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.open","page":"Public Interface","title":"HTTP.open","text":"HTTP.open(method, url, [,headers]) do io\n    write(io, body)\n    [startread(io) -> HTTP.Response]\n    while !eof(io)\n        readavailable(io) -> AbstractVector{UInt8}\n    end\nend -> HTTP.Response\n\nThe HTTP.open API allows the Request Body to be written to (and/or the Response Body to be read from) an IO stream.\n\ne.g. Streaming an audio file to the vlc player:\n\nHTTP.open(\"GET\", \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.get","page":"Public Interface","title":"HTTP.get","text":"HTTP.get(url [, headers]; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"GET\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.put","page":"Public Interface","title":"HTTP.put","text":"HTTP.put(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"PUT\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.post","page":"Public Interface","title":"HTTP.post","text":"HTTP.post(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"POST\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.head","page":"Public Interface","title":"HTTP.head","text":"HTTP.head(url; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"HEAD\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"Request functions may throw the following exceptions:","category":"page"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"HTTP.StatusError\nHTTP.ParseError\nHTTP.IOError","category":"page"},{"location":"public_interface/#HTTP.ExceptionRequest.StatusError","page":"Public Interface","title":"HTTP.ExceptionRequest.StatusError","text":"StatusError <: Exception\n\nThe Response has a 4xx, 5xx or unrecognised status code.\n\nFields:\n\nstatus::Int16, the response status code.\nresponse the HTTP.Response\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Parsers.ParseError","page":"Public Interface","title":"HTTP.Parsers.ParseError","text":"ParseError <: Exception\n\nParser input was invalid.\n\nFields:\n\ncode, error code\nbytes, the offending input.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.IOExtras.IOError","page":"Public Interface","title":"HTTP.IOExtras.IOError","text":"IOError <: Exception\n\nThe request terminated with due to an IO-related error.\n\nFields:\n\ne, the error.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"Sockets.DNSError","category":"page"},{"location":"public_interface/#URIs-1","page":"Public Interface","title":"URIs","text":"","category":"section"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"HTTP.URI\nHTTP.URIs.escapeuri\nHTTP.URIs.unescapeuri\nHTTP.URIs.splitpath\nBase.isvalid(::HTTP.URIs.URI)","category":"page"},{"location":"public_interface/#HTTP.URIs.URI","page":"Public Interface","title":"HTTP.URIs.URI","text":"HTTP.URI(; scheme=\"\", host=\"\", port=\"\", etc...)\nHTTP.URI(str) = parse(HTTP.URI, str::String)\n\nA type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use parse(HTTP.URI, str) to parse the HTTP.URI directly. The HTTP.URI constructors will automatically escape any provided query arguments, typically provided as \"key\"=>\"value\"::Pair or Dict(\"key\"=>\"value\"). Note that multiple values for a single query key can provided like Dict(\"key\"=>[\"value1\", \"value2\"]).\n\nThe URI struct stores the complete URI in the uri::String field and the component parts in the following SubString fields:\n\nscheme, e.g. \"http\" or \"https\"\nuserinfo, e.g. \"username:password\"\nhost e.g. \"julialang.org\"\nport e.g. \"80\" or \"\"\npath e.g \"/\"\nquery e.g. \"Foo=1&Bar=2\"\nfragment\n\nThe HTTP.resource(::URI) function returns a target-resource string for the URI RFC7230 5.3. e.g. \"$path?$query#$fragment\".\n\nThe HTTP.queryparams(::URI) function returns a Dict containing the query.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.URIs.escapeuri","page":"Public Interface","title":"HTTP.URIs.escapeuri","text":"percent-encode a string, dict, or pair for a uri\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.URIs.unescapeuri","page":"Public Interface","title":"HTTP.URIs.unescapeuri","text":"unescape a percent-encoded uri/url\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.URIs.splitpath","page":"Public Interface","title":"HTTP.URIs.splitpath","text":"Splits the path into components See: http://tools.ietf.org/html/rfc3986#section-3.3\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Base.isvalid-Tuple{HTTP.URIs.URI}","page":"Public Interface","title":"Base.isvalid","text":"checks if a HTTP.URI is valid\n\n\n\n\n\n","category":"method"},{"location":"public_interface/#Cookies-1","page":"Public Interface","title":"Cookies","text":"","category":"section"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"HTTP.Cookie","category":"page"},{"location":"public_interface/#HTTP.Cookies.Cookie","page":"Public Interface","title":"HTTP.Cookies.Cookie","text":"Cookie()\nCookie(; kwargs...)\nCookie(name, value; kwargs...)\n\nA Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:\n\nname: name of the cookie\nvalue: value of the cookie\npath: applicable path for the cookie\ndomain: applicable domain for the cookie\nexpires: a Dates.DateTime representing when the cookie should expire\nmaxage: maxage == 0 means no max age, maxage < 0 means delete cookie now, max age > 0 means the # of seconds until expiration\nsecure::Bool: secure cookie attribute\nhttponly::Bool: httponly cookie attribute\nhostonly::Bool: hostonly cookie attribute\n\nSee http:#tools.ietf.org/html/rfc6265 for details.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#Utilities-1","page":"Public Interface","title":"Utilities","text":"","category":"section"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"HTTP.sniff\nHTTP.Strings.escapehtml","category":"page"},{"location":"public_interface/#HTTP.sniff","page":"Public Interface","title":"HTTP.sniff","text":"HTTP.sniff(content::Union{Vector{UInt8}, String, IO}) => String (mimetype)\n\nHTTP.sniff will look at the first 512 bytes of content to try and determine a valid mimetype. If a mimetype can't be determined appropriately, \"application/octet-stream\" is returned.\n\nSupports JSON detection through the HTTP.isjson(content) function.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Strings.escapehtml","page":"Public Interface","title":"HTTP.Strings.escapehtml","text":"escapehtml(i::String)\n\nReturns a string with special HTML characters escaped: &, <, >, \", '\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#Server-/-Handlers-1","page":"Public Interface","title":"Server / Handlers","text":"","category":"section"},{"location":"public_interface/#","page":"Public Interface","title":"Public Interface","text":"HTTP.listen\nHTTP.serve\nHTTP.Handlers\nHTTP.handle\nHTTP.RequestHandlerFunction\nHTTP.StreamHandlerFunction\nHTTP.Router\nHTTP.@register","category":"page"},{"location":"public_interface/#HTTP.Servers.listen","page":"Public Interface","title":"HTTP.Servers.listen","text":"HTTP.listen([host=Sockets.localhost[, port=8081]]; kw...) do http::HTTP.Stream\n    ...\nend\n\nListen for HTTP connections and execute the do function for each request.\n\nThe do function should be of the form f(::HTTP.Stream)::Nothing.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl  connections. Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl  verification (useful for testing).\nreuse_limit = nolimit, number of times a connection is allowed to be reused after the first request.\ntcpisvalid = tcp->true, function f(::TCPSocket)::Bool to, check accepted  connection before processing requests. e.g. to do source IP filtering.\nreadtimeout::Int=60, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple servers to listen on the same port.\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows closing the server.\nconnection_count::Ref{Int}, reference to track the number of currently  open connections.\nrate_limit::Rational{Int}=nothing\", number of connections//second  allowed per client IP address; excess connections are immediately closed.  e.g. 5//1.\nverbose::Bool=false, log connection information to stdout.\n\ne.g.\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    HTTP.setheader(http, \"Content-Type\" => \"text/html\")\n    write(http, \"target uri: $(http.message.target)<BR>\")\n    write(http, \"request body:<BR><PRE>\")\n    write(http, read(http))\n    write(http, \"</PRE>\")\n    return\nend\n\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\nThe server= option can be used to pass an already listening socket to HTTP.listen. This allows manual control of server shutdown.\n\ne.g.\n\nusing Sockets\nserver = Sockets.listen(Sockets.InetAddr(parse(IPAddr, host), port))\n@async HTTP.listen(f, host, port; server=server)\n\n# Closing server will stop HTTP.listen.\nclose(server)\n\nTo run the following HTTP chat example, open two Julia REPL windows and paste the example code into both of them. Then in one window run chat_server() and in the other run chat_client(), then type hello and press return. Whatever you type on the client will be displayed on the server and vis-versa.\n\nusing HTTP\n\nfunction chat(io::HTTP.Stream)\n    @async while !eof(io)\n        write(stdout, readavailable(io), \"\\n\")\n    end\n    while isopen(io)\n        write(io, readline(stdin))\n    end\nend\n\nchat_server() = HTTP.listen(\"127.0.0.1\", 8087) do io\n    write(io, \"HTTP.jl Chat Server. Welcome!\")\n    chat(io)\nend\n\nchat_client() = HTTP.open(\"POST\", \"http://127.0.0.1:8087\") do io\n    chat(io)\nend\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers.serve","page":"Public Interface","title":"HTTP.Handlers.serve","text":"HTTP.serve([host=Sockets.localhost[, port=8081]]; kw...) do req::HTTP.Request\n    ...\nend\nHTTP.serve([host=Sockets.localhost[, port=8081]]; stream=true, kw...) do stream::HTTP.Stream\n    ...\nend\nHTTP.serve(handler, [host=Sockets.localhost[, port=8081]]; kw...)\n\nListen for HTTP connections and handle each request received. The \"handler\" can be a function that operates directly on HTTP.Stream, HTTP.Request, or any kind of HTTP.Handler instance. For functions like f(::HTTP.Stream), also pass stream=true to signal a streaming handler.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl connections.  Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl verification (useful for testing)\nreuse_limit = nolimit, number of times a connection is allowed to be reused  after the first request.\ntcpisvalid::Function (::TCPSocket) -> Bool, check accepted connection before  processing requests. e.g. to implement source IP filtering, rate-limiting, etc.\nreadtimeout::Int=60, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple server processes to listen on the same port. Only fully supported on linux; OSX will allow multiple server processes to listen, but only one will accept connections\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows manual control over closing the server.\nconnection_count::Ref{Int}, reference to track the # of currently open connections.\nrate_limit::Rational{Int}=nothing\", number of connections//second allowed  per client IP address; excess connections are immediately closed. e.g. 5//1.\nstream::Bool=false, the handler will operate on an HTTP.Stream instead of HTTP.Request\nverbose::Bool=false, log connection information to stdout.\n\nExamples\n\nHTTP.serve(; stream=true) do http::HTTP.Stream\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\n    return\nend\n\n# pass in own server socket to control shutdown\nusing Sockets\nserver = Sockets.serve(Sockets.InetAddr(parse(IPAddr, host), port))\n@async HTTP.serve(f, host, port; server=server)\n# close server which will stop HTTP.serve\nclose(server)\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers","page":"Public Interface","title":"HTTP.Handlers","text":"Examples\n\nLet's put together an example http REST server for our hypothetical \"ZooApplication\" that utilizes various parts of the Servers & Handler frameworks.\n\nOur application allows users to interact with custom \"animal\" JSON objects.\n\nFirst we have our \"model\" or data structures:\n\nmutable struct Animal\n    id::Int\n    type::String\n    name::String\nend\n\nNow we want to define our REST api, or how do we allow users to create, update, retrieve and delete animals:\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# \"service\" functions to actually do the work\nfunction createAnimal(req::HTTP.Request)\n    animal = JSON2.read(IOBuffer(HTTP.payload(req)), Animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON2.write(animal))\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    animal = ANIMALS[parse(Int, animalId)]\n    return HTTP.Response(200, JSON2.write(animal))\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = JSON2.read(IOBuffer(HTTP.payload(req)), Animal)\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON2.write(animal))\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, parse(Int, animal.id))\n    return HTTP.Response(200)\nend\n\n# define REST endpoints to dispatch to \"service\" functions\nconst ANIMAL_ROUTER = HTTP.Router()\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/animals\", createAnimal)\n# note the use of `*` to capture the path segment \"variable\" animal id\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"PUT\", \"/api/zoo/v1/animals\", updateAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/animals/*\", deleteAnimal)\n\nGreat! At this point, we could spin up our server and let users start managing their animals:\n\nHTTP.serve(ANIMAL_ROUTER, Sockets.localhost, 8081)\n\nNow, you may have noticed that there was a bit of repetition in our \"service\" functions, particularly with regards to the JSON serialization/deserialization. Perhaps we can simplify things by writing a custom \"JSONHandler\" to do some of the repetitive work for us.\n\nfunction JSONHandler(req::HTTP.Request)\n    # first check if there's any request body\n    body = IOBuffer(HTTP.payload(req))\n    if eof(body)\n        # no request body\n        response_body = handle(ANIMAL_ROUTER, req)\n    else\n        # there's a body, so pass it on to the handler we dispatch to\n        response_body = handle(ANIMAL_ROUTER, req, JSON2.read(body, Animal))\n    end\n    return HTTP.Response(200, JSON2.write(response_body))\nend\n\n# **simplified** \"service\" functions\nfunction createAnimal(req::HTTP.Request, animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    return ANIMALS[animalId]\nend\n\nfunction updateAnimal(req::HTTP.Request, animal)\n    ANIMALS[animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10\n    delete!(ANIMALS, animal.id)\n    return \"\"\nend\n\nAnd we modify slightly how we run our server, letting our new JSONHandler be the entry point instead of our router:\n\nHTTP.serve(JSONHandler, Sockets.localhost, 8081)\n\nOur JSONHandler is nice because it saves us a bunch of repetition: if a request body comes in, we automatically deserialize it and pass it on to the service function. And each service function doesn't need to worry about returning HTTP.Responses anymore, but can just focus on returning plain Julia objects/strings. The other huge advantage is it provides a clean separation of concerns between the \"service\" layer, which should really concern itself with application logic, and the \"REST API\" layer, which should take care of translating between our model and a web data format (JSON).\n\nLet's take this one step further and allow multiple users to manage users, and add in one more custom handler to provide an authentication layer to our application. We can't just let anybody be modifying another user's animals!\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\nend\n\n# modify our data store to allow for multiple users\nconst ANIMALS = Dict{Base.UUID, Dict{Int, Animal}}()\n\n# creating a user returns a new UUID key unique to the user\ncreateUser(req) = Base.UUID(rand(UInt128))\n\n# add an additional endpoint for user creation\nHTTP.@register(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users\", createUser)\n# modify service endpoints to have user pass UUID in\nHTTP.@register(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/users/*/animals/*\", getAnimal)\nHTTP.@register(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/users/*/animals/*\", deleteAnimal)\n\n# modified service functions to account for multiple users\nfunction createAnimal(req::HTTP.Request, animal)\n    animal.id = getNextId()\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    paths = HTTP.URIs.splitpath(req.target)\n    userId = path[5] # /api/zoo/v1/users/x92jf-.../animals/10, get user UUID\n    animalId = path[7] # /api/zoo/v1/users/x92jf-.../animals/10, get 10\n    return ANIMALS[userId][parse(Int, animalId)]\nend\n\nfunction updateAnimal(req::HTTP.Request, animal)\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    paths = HTTP.URIs.splitpath(req.target)\n    userId = path[5] # /api/zoo/v1/users/x92jf-.../animals/10, get user UUID\n    animalId = path[7] # /api/zoo/v1/users/x92jf-.../animals/10, get 10\n    delete!(ANIMALS[userId], parse(Int, animal.id))\n    return \"\"\nend\n\n# AuthHandler to reject any unknown users\nfunction AuthHandler(req)\n    if HTTP.hasheader(req, \"Animal-UUID\")\n        uuid = HTTP.header(req, \"Animal-UUID\")\n        if haskey(ANIMALS, uuid)\n            return JSONHandler(req)\n        end\n    end\n    return HTTP.Response(401, \"unauthorized\")\nend\n\nAnd our modified server invocation:\n\nHTTP.serve(AuthHandler, Sockets.localhost, 8081)\n\nLet's review what's going on here:\n\nEach Animal object now includes a UUID object unique to a user\nWe added a /api/zoo/v1/users endpoint for creating a new user\nEach of our service functions now account for individual users\nWe made a new AuthHandler as the very first entry point in our middleware stack, this means that every single request must first pass through this authentication layer before reaching the service layer. Our AuthHandler checks that the user provided our security request header Animal-UUID and if so, ensures the provided UUID corresponds to a valid user. If not, the AuthHandler returns a 401 HTTP response, signalling that the request is unauthorized\n\nVoila, hopefully that helps provide a slightly-more-than-trivial example of utilizing the HTTP.Handler framework in conjunction with running an HTTP server.\n\n\n\n\n\n","category":"module"},{"location":"public_interface/#HTTP.Handlers.handle","page":"Public Interface","title":"HTTP.Handlers.handle","text":"HTTP.handle(handler::HTTP.RequestHandler, ::HTTP.Request) => HTTP.Response\nHTTP.handle(handler::HTTP.StreamHandler, ::HTTP.Stream)\n\nDispatch function used to handle incoming requests to a server. Can be overloaded by custom HTTP.Handler subtypes to implement custom \"handling\" behavior.\n\n\n\n\n\n","category":"function"},{"location":"public_interface/#HTTP.Handlers.RequestHandlerFunction","page":"Public Interface","title":"HTTP.Handlers.RequestHandlerFunction","text":"RequestHandlerFunction(f)\n\nA function-wrapper type that is a subtype of RequestHandler. Takes a single function as an argument that should be of the form f(::HTTP.Request) => HTTP.Response\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Handlers.StreamHandlerFunction","page":"Public Interface","title":"HTTP.Handlers.StreamHandlerFunction","text":"StreamHandlerFunction(f)\n\nA function-wrapper type that is a subtype of StreamHandler. Takes a single function as an argument that should be of the form f(::HTTP.Stream) => Nothing, i.e. it accepts a raw HTTP.Stream, handles the incoming request, writes a response back out to the stream directly, then returns.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Handlers.Router","page":"Public Interface","title":"HTTP.Handlers.Router","text":"HTTP.Router(h::Handler)\nHTTP.Router(f::Function)\nHTTP.Router()\n\nAn HTTP.Handler type that supports pattern matching request url paths to registered HTTP.Handlers. Can accept a default Handler or Function that will be used in case no other handlers match; by default, a 404 response handler is used. Paths can be mapped to a handler via HTTP.@register(r::Router, path, handler), see ?HTTP.@register for more details.\n\n\n\n\n\n","category":"type"},{"location":"public_interface/#HTTP.Handlers.@register","page":"Public Interface","title":"HTTP.Handlers.@register","text":"HTTP.@register(r::Router, path, handler)\nHTTP.@register(r::Router, method::String, path, handler)\nHTTP.@register(r::Router, method::String, scheme::String, host::String, path, handler)\n\nFunction to map request urls matching path and optional method, scheme, host to another handler::HTTP.Handler. URL paths are registered one at a time, and multiple urls can map to the same handler. The URL can be passed as a String. Requests can be routed based on: method, scheme, hostname, or path. The following examples show how various urls will direct how a request is routed by a server:\n\n\"http://*\": match all HTTP requests, regardless of path\n\"https://*\": match all HTTPS requests, regardless of path\n\"/gmail\": regardless of scheme or host, match any request with a path starting with \"gmail\"\n\"/gmail/userId/*/inbox: match any request matching the path pattern, \"*\" is used as a wildcard that matches any value between the two \"/\"\n\nNote that due to being a macro (and the internal routing functionality), routes can only be registered statically, i.e. at the top level of a module, and not dynamically, i.e. inside a function.\n\n\n\n\n\n","category":"macro"},{"location":"internal_architecture/#Internal-Architecture-1","page":"Internal Architecture","title":"Internal Architecture","text":"","category":"section"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Layer\nHTTP.stack","category":"page"},{"location":"internal_architecture/#HTTP.Layers.Layer","page":"Internal Architecture","title":"HTTP.Layers.Layer","text":"Request Execution Stack\n\nThe Request Execution Stack is separated into composable layers.\n\nEach layer is defined by a nested type Layer{Next} where the Next parameter defines the next layer in the stack. The request method for each layer takes a Layer{Next} type as its first argument and dispatches the request to the next layer using request(Next, ...).\n\nThe example below defines three layers and three stacks each with a different combination of layers.\n\nabstract type Layer end\nabstract type Layer1{Next <: Layer} <: Layer end\nabstract type Layer2{Next <: Layer} <: Layer end\nabstract type Layer3 <: Layer end\n\nrequest(::Type{Layer1{Next}}, data) where Next = \"L1\", request(Next, data)\nrequest(::Type{Layer2{Next}}, data) where Next = \"L2\", request(Next, data)\nrequest(::Type{Layer3}, data) = \"L3\", data\n\nconst stack1 = Layer1{Layer2{Layer3}}\nconst stack2 = Layer2{Layer1{Layer3}}\nconst stack3 = Layer1{Layer3}\n\njulia> request(stack1, \"foo\")\n(\"L1\", (\"L2\", (\"L3\", \"foo\")))\n\njulia> request(stack2, \"bar\")\n(\"L2\", (\"L1\", (\"L3\", \"bar\")))\n\njulia> request(stack3, \"boo\")\n(\"L1\", (\"L3\", \"boo\"))\n\nThis stack definition pattern gives the user flexibility in how layers are combined but still allows Julia to do whole-stack compile time optimisations.\n\ne.g. the request(stack1, \"foo\") call above is optimised down to a single function:\n\njulia> code_typed(request, (Type{stack1}, String))[1].first\nCodeInfo(:(begin\n    return (Core.tuple)(\"L1\", (Core.tuple)(\"L2\", (Core.tuple)(\"L3\", data)))\nend))\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.stack","page":"Internal Architecture","title":"HTTP.stack","text":"The stack() function returns the default HTTP Layer-stack type. This type is passed as the first parameter to the HTTP.request function.\n\nstack() accepts optional keyword arguments to enable/disable specific layers in the stack: request(method, args...; kw...) request(stack(;kw...), args...; kw...)\n\nThe minimal request execution stack is:\n\nstack = MessageLayer{ConnectionPoolLayer{StreamLayer}}\n\nThe figure below illustrates the full request execution stack and its relationship with HTTP.Response, HTTP.Parsers, HTTP.Stream and the HTTP.ConnectionPool.\n\n ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ\n â                                            âââââââââââââââââââââ           â\n â  HTTP.jl Request Execution Stack           â HTTP.ParsingError â â â â â â â\n â                                            âââââââââââââââââââââ           â\n â                                            âââââââââââââââââââââ         â â\n â                                            â HTTP.IOError      â â â â     â\n â                                            âââââââââââââââââââââ      â  â â\n â                                            âââââââââââââââââââââ           â\n â                                            â HTTP.StatusError  ââ â   â  â â\n â                                            âââââââââââââââââââââ   â       â\n â                                            âââââââââââââââââââââ      â  â â\n â     request(method, url, headers, body) -> â HTTP.Response     â   â       â\n â             ââââââââââââââââââââââââââ     âââââââââââ²ââââââââââ      â  â â\n â                           â                          â             â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ      â  â â\n â   â request(RedirectLayer,     method, ::URI, ::Headers, body) â   â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\n â   â request(BasicAuthLayer,    method, ::URI, ::Headers, body) â   â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\n â   â request(CookieLayer,       method, ::URI, ::Headers, body) â   â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\n â   â request(CanonicalizeLayer, method, ::URI, ::Headers, body) â   â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\n â   â request(MessageLayer,      method, ::URI, ::Headers, body) â   â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\n â   â request(AWS4AuthLayer,             ::URI, ::Request, body) â   â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\n â   â request(RetryLayer,                ::URI, ::Request, body) â   â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\n â   â request(ExceptionLayer,            ::URI, ::Request, body) â â â       â\n â   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤      â  â â\nââ¼ââââ¤ request(ConnectionPoolLayer,       ::URI, ::Request, body) â â â â     â\nââ   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤         â â\nââ   â request(DebugLayer,                ::IO,  ::Request, body) â           â\nââ   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤         â â\nââ   â request(TimeoutLayer,              ::IO,  ::Request, body) â           â\nââ   ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ¤         â â\nââ   â request(StreamLayer,               ::IO,  ::Request, body) â           â\nââ   ââââââââââââââââ¬ââââââââââââââââââââ¬ââââââââââââââââââââââââââ         â â\nâââââââââââââââââââââ¼ââââââââââââââââââââ¼ââââââââââââââââââââââââââââââââââââââ\nâ                   â        â          â               â                   â  \nâââââââââââââââââââââ¼ââââââââââââââââ   â  ââââââââââââââââââââââââââââââââââââ\nââ HTTP.Request                     â   â  â HTTP.Response                  â â\nââ                                  â   â  â                                  â\nââ method::String                   âââââ¼âââ¶ status::Int                    â â\nââ target::String                   â   â  â headers::Vector{Pair}            â\nââ headers::Vector{Pair}            â   â  â body::Vector{UInt8}            â â\nââ body::Vector{UInt8}              â   â  â                                  â\nâââââââââââââââââââââ²ââââââââââââââââ   â  âââââââââââââââââ²âââââââââââââââââ¼ââ\nâââââââââââââââââââââ´ââââââââââââââââââââ¼âââââââââââââââââââ´âââââââââââââââââââ\nââ HTTP.Stream <:IO          â           ââââââââ       â                   â â\nââ   âââââââââââââââââââââââââââââ       â   ââââ¼ââââââââââââââââââââââââââ   â\nââ   â startwrite(::Stream)      â       â   â startread(::Stream)        â â â\nââ   â write(::Stream, body)     â       â   â read(::Stream) -> body     â   â\nââ   â ...                       â       â   â ...                        â â â\nââ   â closewrite(::Stream)      â       â   â closeread(::Stream)        â   â\nââ   âââââââââââââââââââââââââââââ       â   ââââââââââââââââââââââââââââââ â â\nâââââââââââââââââââââââââââââââââââââââ¬âââââââââââââââââââââ¬âââââââââââââââââââ\nâââââââââââââââââââââââââââââââââââââ â  â ââââââ¼âââââââââââ¼âââââââââââââââââ´ââ\nââ HTTP.Messages                    â â  â â HTTP.Parsers                     â\nââ                                  â â  â â                                  â\nââ writestartline(::IO, ::Request)  â â  â â parse_status_line(bytes, ::Req') â\nââ writeheaders(::IO, ::Request)    â â  â â parse_header_field(bytes, ::Req')â\nâââââââââââââââââââââââââââââââââââââ â  â ââââââââââââââââââââââââââââââââââââ\nâ                            â        â  â                                     \nâââââââââââââââââââââââââââââââââââââââ¼ââââââââââââââââââââââââââââââââââââââââ\nââ¶ HTTP.ConnectionPool       â        â  â                                    â\n â                     ââââââââââââââââ¼âââââââââ âââââââââââââââââââââââââ    â\n â getconnection() ->  â HTTP.Transaction <:IO â â HTTP.Transaction <:IO â    â\n â                     âââââââââââââââââââââââââ âââââââââââââââââââââââââ    â\n â                           â    â²ââ±    â                  â²ââ±               â\n â                           â     â     â                   â                â\n â                     âââââââââââââ¼ââââââââââââ âââââââââââââ¼ââââââââââââ    â\n â              pool: [â HTTP.Connection       â,â HTTP.Connection       â...]â\n â                     âââââââââââââ¬ââââââââââââ âââââââââââââ¬ââââââââââââ    â\n â                           â     â     â                   â                â\n â                     âââââââââââââ¼ââââââââââââ âââââââââââââ¼ââââââââââââ    â\n â                     â Base.TCPSocket <:IO   â âMbedTLS.SSLContext <:IOâ    â\n â                     âââââââââââââââââââââââââ âââââââââââââ¬ââââââââââââ    â\n â                           â           â                   â                â\n â                           â           â       âââââââââââââ¼ââââââââââââ    â\n â                           â           â       â Base.TCPSocket <:IO   â    â\n â                           â           â       âââââââââââââââââââââââââ    â\n ââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââââ\n                             â           â                                     \n ââââââââââââââââââââââââââââââââââââââââââââââââââââââââ  ââââââââââââââââââââ\n â HTTP Server               â¼                          â  â data flow: âââââ¶ â\n â                        Request     Response          â  â reference: âââââ¶ â\n ââââââââââââââââââââââââââââââââââââââââââââââââââââââââ  ââââââââââââââââââââ\n\nSee docs/src/layers.monopic.\n\n\n\n\n\n","category":"function"},{"location":"internal_architecture/#Request-Execution-Layers-1","page":"Internal Architecture","title":"Request Execution Layers","text":"","category":"section"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.RedirectLayer\nHTTP.BasicAuthLayer\nHTTP.CookieLayer\nHTTP.CanonicalizeLayer\nHTTP.MessageLayer\nHTTP.AWS4AuthLayer\nHTTP.RetryLayer\nHTTP.ExceptionLayer\nHTTP.ConnectionPoolLayer\nHTTP.TimeoutLayer\nHTTP.StreamLayer","category":"page"},{"location":"internal_architecture/#HTTP.RedirectRequest.RedirectLayer","page":"Internal Architecture","title":"HTTP.RedirectRequest.RedirectLayer","text":"request(RedirectLayer, method, ::URI, headers, body) -> HTTP.Response\n\nRedirects the request in the case of 3xx response status.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.BasicAuthRequest.BasicAuthLayer","page":"Internal Architecture","title":"HTTP.BasicAuthRequest.BasicAuthLayer","text":"request(BasicAuthLayer, method, ::URI, headers, body) -> HTTP.Response\n\nAdd Authorization: Basic header using credentials from url userinfo.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.CookieRequest.CookieLayer","page":"Internal Architecture","title":"HTTP.CookieRequest.CookieLayer","text":"request(CookieLayer, method, ::URI, headers, body) -> HTTP.Response\n\nAdd locally stored Cookies to the request headers. Store new Cookies found in the response headers.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.CanonicalizeRequest.CanonicalizeLayer","page":"Internal Architecture","title":"HTTP.CanonicalizeRequest.CanonicalizeLayer","text":"request(CanonicalizeLayer, method, ::URI, headers, body) -> HTTP.Response\n\nRewrite request and response headers in Canonical-Camel-Dash-Format.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.MessageRequest.MessageLayer","page":"Internal Architecture","title":"HTTP.MessageRequest.MessageLayer","text":"request(MessageLayer, method, ::URI, headers, body) -> HTTP.Response\n\nConstruct a Request object and set mandatory headers.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.AWS4AuthRequest.AWS4AuthLayer","page":"Internal Architecture","title":"HTTP.AWS4AuthRequest.AWS4AuthLayer","text":"request(AWS4AuthLayer, ::URI, ::Request, body) -> HTTP.Response\n\nAdd a AWS Signature Version 4 Authorization header to a Request.\n\nCredentials are read from environment variables AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY and AWS_SESSION_TOKEN.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.RetryRequest.RetryLayer","page":"Internal Architecture","title":"HTTP.RetryRequest.RetryLayer","text":"request(RetryLayer, ::URI, ::Request, body) -> HTTP.Response\n\nRetry the request if it throws a recoverable exception.\n\nBase.retry and Base.ExponentialBackOff implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.\n\nMethods of isrecoverable(e) define which exception types lead to a retry. e.g. HTTP.IOError, Sockets.DNSError, Base.EOFError and HTTP.StatusError (if status is `5xx).\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.ExceptionRequest.ExceptionLayer","page":"Internal Architecture","title":"HTTP.ExceptionRequest.ExceptionLayer","text":"request(ExceptionLayer, ::URI, ::Request, body) -> HTTP.Response\n\nThrow a StatusError if the request returns an error response status.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.ConnectionRequest.ConnectionPoolLayer","page":"Internal Architecture","title":"HTTP.ConnectionRequest.ConnectionPoolLayer","text":"request(ConnectionPoolLayer, ::URI, ::Request, body) -> HTTP.Response\n\nRetrieve an IO connection from the ConnectionPool.\n\nClose the connection if the request throws an exception. Otherwise leave it open so that it can be reused.\n\nIO related exceptions from Base are wrapped in HTTP.IOError. See isioerror.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.TimeoutRequest.TimeoutLayer","page":"Internal Architecture","title":"HTTP.TimeoutRequest.TimeoutLayer","text":"request(TimeoutLayer, ::IO, ::Request, body) -> HTTP.Response\n\nClose IO if no data has been received for timeout seconds.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#HTTP.StreamRequest.StreamLayer","page":"Internal Architecture","title":"HTTP.StreamRequest.StreamLayer","text":"request(StreamLayer, ::IO, ::Request, body) -> HTTP.Response\n\nCreate a Stream to send a Request and body to an IO stream and read the response.\n\nSend the Request body in a background task and begins reading the response immediately so that the transmission can be aborted if the Response status indicates that the server does not wish to receive the message body. RFC7230 6.5.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#Parser-1","page":"Internal Architecture","title":"Parser","text":"","category":"section"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Parsers.jl","category":"page"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Parsers","category":"page"},{"location":"internal_architecture/#HTTP.Parsers","page":"Internal Architecture","title":"HTTP.Parsers","text":"The parser separates a raw HTTP Message into its component parts.\n\nIf the input data is invalid the Parser throws a HTTP.ParseError.\n\nThe parse_* functions processes a single element of a HTTP Message at a time and return a SubString containing the unused portion of the input.\n\nThe Parser does not interpret the Message Headers. It is beyond the scope of the Parser to deal with repeated header fields, multi-line values, cookies or case normalization.\n\nThe Parser has no knowledge of the high-level Request and Response structs defined in Messages.jl. However, the Request and Response structs must have field names compatible with those expected by the parse_status_line! and parse_request_line! functions.\n\n\n\n\n\n","category":"module"},{"location":"internal_architecture/#Messages-1","page":"Internal Architecture","title":"Messages","text":"","category":"section"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Messages.jl","category":"page"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Messages","category":"page"},{"location":"internal_architecture/#HTTP.Messages","page":"Internal Architecture","title":"HTTP.Messages","text":"The Messages module defines structs that represent HTTP.Request and HTTP.Response Messages.\n\nThe Response struct has a request field that points to the corresponding Request; and the Request struct has a response field. The Request struct also has a parent field that points to a Response in the case of HTTP Redirect.\n\nThe Messages module defines IO read and write methods for Messages but it does not deal with URIs, creating connections, or executing requests.\n\nThe read methods throw EOFError exceptions if input data is incomplete. and call parser functions that may throw HTTP.ParsingError exceptions. The read and write methods may also result in low level IO exceptions.\n\nSending Messages\n\nMessages are formatted and written to an IO stream by Base.write(::IO,::HTTP.Messages.Message) and or HTTP.Messages.writeheaders.\n\nReceiving Messages\n\nMessages are parsed from IO stream data by HTTP.Messages.readheaders. This function calls HTTP.Parsers.parse_header_field and passes each header-field to HTTP.Messages.appendheader.\n\nHeaders\n\nHeaders are represented by Vector{Pair{String,String}}. As compared to Dict{String,String} this allows repeated header fields and preservation of order.\n\nHeader values can be accessed by name using HTTP.Messages.header and HTTP.Messages.setheader (case-insensitive).\n\nThe HTTP.Messages.appendheader function handles combining multi-line values, repeated header fields and special handling of multiple Set-Cookie headers.\n\nBodies\n\nThe HTTP.Message structs represent the Message Body as Vector{UInt8}.\n\nStreaming of request and response bodies is handled by the HTTP.StreamLayer and the HTTP.Stream <: IO stream.\n\n\n\n\n\n","category":"module"},{"location":"internal_architecture/#Streams-1","page":"Internal Architecture","title":"Streams","text":"","category":"section"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"Source: Streams.jl","category":"page"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.Streams.Stream","category":"page"},{"location":"internal_architecture/#HTTP.Streams.Stream","page":"Internal Architecture","title":"HTTP.Streams.Stream","text":"Stream(::Request, ::IO)\n\nCreates a HTTP.Stream that wraps an existing IO stream.\n\nstartwrite(::Stream) sends the Request headers to the IO stream.\nwrite(::Stream, body) sends the body (or a chunk of the body).\nclosewrite(::Stream) sends the final 0 chunk (if needed) and calls closewrite on the IO stream. When the IO stream is a HTTP.ConnectionPool.Transaction, calling closewrite releases the HTTP.ConnectionPool.Connection back into the pool for use by the next pipelined request.\nstartread(::Stream) calls startread on the IO stream then  reads and parses the Response headers.  When the IO stream is a HTTP.ConnectionPool.Transaction, calling startread waits for other pipelined responses to be read from the HTTP.ConnectionPool.Connection.\neof(::Stream) and readavailable(::Stream) parse the body from the IO  stream.\ncloseread(::Stream) reads the trailers and calls closeread on the IO  stream.  When the IO stream is a HTTP.ConnectionPool.Transaction,  calling closeread releases the readlock and allows the next pipelined  response to be read by another Stream that is waiting in startread.  If a complete response has not been received, closeread throws EOFError.\n\n\n\n\n\n","category":"type"},{"location":"internal_architecture/#Connections-1","page":"Internal Architecture","title":"Connections","text":"","category":"section"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"Source: ConnectionPool.jl","category":"page"},{"location":"internal_architecture/#","page":"Internal Architecture","title":"Internal Architecture","text":"HTTP.ConnectionPool","category":"page"},{"location":"internal_architecture/#HTTP.ConnectionPool","page":"Internal Architecture","title":"HTTP.ConnectionPool","text":"This module provides the getconnection function with support for:\n\nOpening TCP and SSL connections.\nReusing connections for multiple Request/Response Messages,\nPipelining Request/Response Messages. i.e. allowing a new Request to be sent before previous Responses have been read.\n\nThis module defines a Connection struct to manage pipelining and connection reuse and a Transaction<: IO struct to manage a single pipelined request. Methods are provided for eof, readavailable, unsafe_write and close. This allows the Transaction object to act as a proxy for the TCPSocket or SSLContext that it wraps.\n\nThe pool is a collection of open Connections.  The request function calls getconnection to retrieve a connection from the pool.  When the request function has written a Request Message it calls closewrite to signal that the Connection can be reused for writing (to send the next Request). When the request function has read the Response Message it calls closeread to signal that the Connection can be reused for reading.\n\n\n\n\n\n","category":"module"},{"location":"internal_interface/#Internal-Interfaces-1","page":"Internal Interfaces","title":"Internal Interfaces","text":"","category":"section"},{"location":"internal_interface/#Parser-Interface-1","page":"Internal Interfaces","title":"Parser Interface","text":"","category":"section"},{"location":"internal_interface/#","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Parsers.find_end_of_header\nHTTP.Parsers.find_end_of_chunk_size\nHTTP.Parsers.find_end_of_trailer\nHTTP.Parsers.parse_status_line!\nHTTP.Parsers.parse_request_line!\nHTTP.Parsers.parse_header_field\nHTTP.Parsers.parse_chunk_size","category":"page"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_header","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_header","text":"find_end_of_header(bytes) -> length or 0\n\nFind length of header delimited by \\r\\n\\r\\n or \\n\\n.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_chunk_size","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_chunk_size","text":"Find \\n after chunk size in bytes.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.find_end_of_trailer","page":"Internal Interfaces","title":"HTTP.Parsers.find_end_of_trailer","text":"find_end_of_trailer(bytes) -> length or 0\n\nFind length of trailer delimited by \\r\\n\\r\\n (or starting with \\r\\n). RFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_status_line!","page":"Internal Interfaces","title":"HTTP.Parsers.parse_status_line!","text":"Parse HTTP response-line bytes and set the status and version fields of response. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_request_line!","page":"Internal Interfaces","title":"HTTP.Parsers.parse_request_line!","text":"Parse HTTP request-line bytes and set the method, target and version fields of request. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_header_field","page":"Internal Interfaces","title":"HTTP.Parsers.parse_header_field","text":"Parse HTTP header-field. Return Pair(field-name => field-value) and a SubString containing the remaining header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Parsers.parse_chunk_size","page":"Internal Interfaces","title":"HTTP.Parsers.parse_chunk_size","text":"Parse HTTP chunk-size. Return number of bytes of chunk-data.\n\nchunk-size = 1*HEXDIG\n\nRFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Messages-Interface-1","page":"Internal Interfaces","title":"Messages Interface","text":"","category":"section"},{"location":"internal_interface/#","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Messages.Request\nHTTP.Messages.Response\nHTTP.Messages.iserror\nHTTP.Messages.isredirect\nHTTP.Messages.ischunked\nHTTP.Messages.issafe\nHTTP.Messages.isidempotent\nHTTP.Messages.header\nHTTP.Messages.hasheader\nHTTP.Messages.setheader\nHTTP.Messages.defaultheader!\nHTTP.Messages.appendheader\nHTTP.Messages.readheaders\nHTTP.MessageRequest.setuseragent!\nHTTP.Messages.readchunksize\nHTTP.Messages.headerscomplete(::HTTP.Messages.Response)\nHTTP.Messages.writestartline\nHTTP.Messages.writeheaders\nBase.write(::IO,::HTTP.Messages.Message)","category":"page"},{"location":"internal_interface/#HTTP.Messages.Request","page":"Internal Interfaces","title":"HTTP.Messages.Request","text":"Request <: Message\n\nRepresents a HTTP Request Message.\n\nmethod::String  RFC7230 3.1.1\ntarget::String  RFC7230 5.3\nversion::VersionNumber  RFC7230 2.6\nheaders::Vector{Pair{String,String}}  RFC7230 3.2\nbody::Vector{UInt8}  RFC7230 3.3\nresponse, the Response to this Request\ntxcount, number of times this Request has been sent (see RetryRequest.jl).\nparent, the Response (if any) that led to this request (e.g. in the case of a redirect).  RFC7230 6.4\n\n\n\n\n\n","category":"type"},{"location":"internal_interface/#HTTP.Messages.Response","page":"Internal Interfaces","title":"HTTP.Messages.Response","text":"Response <: Message\n\nRepresents a HTTP Response Message.\n\nversion::VersionNumber  RFC7230 2.6\nstatus::Int16  RFC7230 3.1.2  RFC7231 6\nheaders::Vector{Pair{String,String}}  RFC7230 3.2\nbody::Vector{UInt8}  RFC7230 3.3\nrequest, the Request that yielded this Response.\n\n\n\n\n\n","category":"type"},{"location":"internal_interface/#HTTP.Messages.iserror","page":"Internal Interfaces","title":"HTTP.Messages.iserror","text":"iserror(::Response)\n\nDoes this Response have an error status?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.isredirect","page":"Internal Interfaces","title":"HTTP.Messages.isredirect","text":"isredirect(::Response)\n\nDoes this Response have a redirect status?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.ischunked","page":"Internal Interfaces","title":"HTTP.Messages.ischunked","text":"ischunked(::Message)\n\nDoes the Message have a \"Transfer-Encoding: chunked\" header?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.issafe","page":"Internal Interfaces","title":"HTTP.Messages.issafe","text":"issafe(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.1\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.isidempotent","page":"Internal Interfaces","title":"HTTP.Messages.isidempotent","text":"isidempotent(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.2\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.header","page":"Internal Interfaces","title":"HTTP.Messages.header","text":"header(::Message, key [, default=\"\"]) -> String\n\nGet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.hasheader","page":"Internal Interfaces","title":"HTTP.Messages.hasheader","text":"hasheader(::Message, key) -> Bool\n\nDoes header value for key exist (case-insensitive)?\n\n\n\n\n\nhasheader(::Message, key, value) -> Bool\n\nDoes header for key match value (both case-insensitive)?\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.setheader","page":"Internal Interfaces","title":"HTTP.Messages.setheader","text":"setheader(::Message, key => value)\n\nSet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.defaultheader!","page":"Internal Interfaces","title":"HTTP.Messages.defaultheader!","text":"defaultheader!(::Message, key => value)\n\nSet header value in message for key if it is not already set.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.appendheader","page":"Internal Interfaces","title":"HTTP.Messages.appendheader","text":"appendheader(::Message, key => value)\n\nAppend a header value to message.headers.\n\nIf key is the same as the previous header, the value is appended to the value of the previous header with a comma delimiter\n\nSet-Cookie headers are not comma-combined because cookies often contain internal commas.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.readheaders","page":"Internal Interfaces","title":"HTTP.Messages.readheaders","text":"readheaders(::IO, ::Message)\n\nRead headers (and startline) from an IO stream into a Message struct. Throw EOFError if input is incomplete.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.MessageRequest.setuseragent!","page":"Internal Interfaces","title":"HTTP.MessageRequest.setuseragent!","text":"setuseragent!(x::String)\n\nSet the default User-Agent string to be used in each HTTP request. Can be manually overridden by passing an explicit User-Agent header.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.readchunksize","page":"Internal Interfaces","title":"HTTP.Messages.readchunksize","text":"Read chunk-size from an IO stream. After the final zero size chunk, read trailers into a Message struct.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}","page":"Internal Interfaces","title":"HTTP.Messages.headerscomplete","text":"headerscomplete(::Message)\n\nHave the headers been read into this Message?\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.Messages.writestartline","page":"Internal Interfaces","title":"HTTP.Messages.writestartline","text":"writestartline(::IO, ::Message)\n\ne.g. \"GET /path HTTP/1.1\\r\\n\" or \"HTTP/1.1 200 OK\\r\\n\"\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Messages.writeheaders","page":"Internal Interfaces","title":"HTTP.Messages.writeheaders","text":"writeheaders(::IO, ::Message)\n\nWrite Message start line and a line for each \"name: value\" pair and a trailing blank line.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Base.write-Tuple{IO,HTTP.Messages.Message}","page":"Internal Interfaces","title":"Base.write","text":"write(::IO, ::Message)\n\nWrite start line, headers and body of HTTP Message.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#IOExtras-Interface-1","page":"Internal Interfaces","title":"IOExtras Interface","text":"","category":"section"},{"location":"internal_interface/#","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.IOExtras\nHTTP.IOExtras.startwrite(::IO)\nHTTP.IOExtras.isioerror","category":"page"},{"location":"internal_interface/#HTTP.IOExtras","page":"Internal Interfaces","title":"HTTP.IOExtras","text":"IOExtras\n\nThis module defines extensions to the Base.IO interface to support:\n\nstartwrite, closewrite, startread and closeread for streams  with transactional semantics.\n\n\n\n\n\n","category":"module"},{"location":"internal_interface/#HTTP.IOExtras.startwrite-Tuple{IO}","page":"Internal Interfaces","title":"HTTP.IOExtras.startwrite","text":"startwrite(::IO)\nclosewrite(::IO)\nstartread(::IO)\ncloseread(::IO)\n\nSignal start/end of write or read operations.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.isioerror","page":"Internal Interfaces","title":"HTTP.IOExtras.isioerror","text":"isioerror(exception)\n\nIs exception caused by a possibly recoverable IO error.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Streams-Interface-1","page":"Internal Interfaces","title":"Streams Interface","text":"","category":"section"},{"location":"internal_interface/#","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.Streams.closebody\nHTTP.Streams.isaborted","category":"page"},{"location":"internal_interface/#HTTP.Streams.closebody","page":"Internal Interfaces","title":"HTTP.Streams.closebody","text":"closebody(::Stream)\n\nWrite the final 0 chunk if needed.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.Streams.isaborted","page":"Internal Interfaces","title":"HTTP.Streams.isaborted","text":"isaborted(::Stream{Response})\n\nHas the server signaled that it does not wish to receive the message body?\n\n\"If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.\" RFC7230, 6.5\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#Connection-Pooling-Interface-1","page":"Internal Interfaces","title":"Connection Pooling Interface","text":"","category":"section"},{"location":"internal_interface/#","page":"Internal Interfaces","title":"Internal Interfaces","text":"HTTP.ConnectionPool.Connection\nHTTP.ConnectionPool.Transaction\nHTTP.ConnectionPool.pool\nHTTP.ConnectionPool.getconnection\nHTTP.IOExtras.startwrite(::HTTP.ConnectionPool.Transaction)\nHTTP.IOExtras.closewrite(::HTTP.ConnectionPool.Transaction)\nHTTP.IOExtras.startread(::HTTP.ConnectionPool.Transaction)\nHTTP.IOExtras.closeread(::HTTP.ConnectionPool.Transaction)","category":"page"},{"location":"internal_interface/#HTTP.ConnectionPool.Connection","page":"Internal Interfaces","title":"HTTP.ConnectionPool.Connection","text":"Connection{T <: IO}\n\nA TCPSocket or SSLContext connection to a HTTP host and port.\n\nFields:\n\nhost::String\nport::String, exactly as specified in the URI (i.e. may be empty).\npipeline_limit, number of requests to send before waiting for responses.\nidle_timeout, No. of seconds to maintain connection after last transaction.\npeerport, remote TCP port number (used for debug messages).\nlocalport, local TCP port number (used for debug messages).\nio::T, the TCPSocket or `SSLContext.\nbuffer::IOBuffer, left over bytes read from the connection after  the end of a response header (or chunksize). These bytes are usually  part of the response body.\nsequence, number of most recent Transaction.\nwritecount, number of Messages that have been written.\nwritedone, signal that writecount was incremented.\nreadcount, number of Messages that have been read.\nreaddone, signal that readcount was incremented.\ntimestamp, time data was last received.\n\n\n\n\n\n","category":"type"},{"location":"internal_interface/#HTTP.ConnectionPool.Transaction","page":"Internal Interfaces","title":"HTTP.ConnectionPool.Transaction","text":"Transaction\n\nA single pipelined HTTP Request/Response transaction`.\n\nFields:\n\nc, the shared Connection used for this Transaction.\nsequence::Int, identifies this Transaction among the others that share c.\n\n\n\n\n\n","category":"type"},{"location":"internal_interface/#HTTP.ConnectionPool.pool","page":"Internal Interfaces","title":"HTTP.ConnectionPool.pool","text":"The pool is a collection of open Connections.  The request function calls getconnection to retrieve a connection from the pool.  When the request function has written a Request Message it calls closewrite to signal that the Connection can be reused for writing (to send the next Request). When the request function has read the Response Message it calls closeread to signal that the Connection can be reused for reading.\n\n\n\n\n\n","category":"constant"},{"location":"internal_interface/#HTTP.ConnectionPool.getconnection","page":"Internal Interfaces","title":"HTTP.ConnectionPool.getconnection","text":"getconnection(type, host, port) -> Connection\n\nFind a reusable Connection in the pool, or create a new Connection if required.\n\n\n\n\n\n","category":"function"},{"location":"internal_interface/#HTTP.IOExtras.startwrite-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.startwrite","text":"startwrite(::Transaction)\n\nWait for prior pending writes to complete.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.closewrite-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.closewrite","text":"closewrite(::Transaction)\n\nSignal that an entire Request Message has been written to the Transaction.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.startread-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.startread","text":"startread(::Transaction)\n\nWait for prior pending reads to complete.\n\n\n\n\n\n","category":"method"},{"location":"internal_interface/#HTTP.IOExtras.closeread-Tuple{HTTP.ConnectionPool.Transaction}","page":"Internal Interfaces","title":"HTTP.IOExtras.closeread","text":"closeread(::Transaction)\n\nSignal that an entire Response Message has been read from the Transaction.\n\nIncrement readcount and wake up tasks waiting in startread.\n\n\n\n\n\n","category":"method"}]
}
