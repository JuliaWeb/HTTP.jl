<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internal Architecture · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HTTP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../public_interface/">Public Interface</a></li><li class="current"><a class="toctext" href>Internal Architecture</a><ul class="internal"><li><a class="toctext" href="#Request-Execution-Layers-1">Request Execution Layers</a></li><li><a class="toctext" href="#Parser-1">Parser</a></li><li><a class="toctext" href="#Messages-1">Messages</a></li><li><a class="toctext" href="#Streams-1">Streams</a></li><li><a class="toctext" href="#Connections-1">Connections</a></li></ul></li><li><a class="toctext" href="../internal_interface/">Internal Interfaces</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Internal Architecture</a></li></ul><a class="edit-page" href="https://github.com/JuliaWeb/HTTP.jl/blob/master/docs/src/internal_architecture.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internal Architecture</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Internal-Architecture-1" href="#Internal-Architecture-1">Internal Architecture</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Layers.Layer" href="#HTTP.Layers.Layer"><code>HTTP.Layers.Layer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p><strong>Request Execution Stack</strong></p><p>The Request Execution Stack is separated into composable layers.</p><p>Each layer is defined by a nested type <code>Layer{Next}</code> where the <code>Next</code> parameter defines the next layer in the stack. The <code>request</code> method for each layer takes a <code>Layer{Next}</code> type as its first argument and dispatches the request to the next layer using <code>request(Next, ...)</code>.</p><p>The example below defines three layers and three stacks each with a different combination of layers.</p><pre><code class="language-julia">abstract type Layer end
abstract type Layer1{Next &lt;: Layer} &lt;: Layer end
abstract type Layer2{Next &lt;: Layer} &lt;: Layer end
abstract type Layer3 &lt;: Layer end

request(::Type{Layer1{Next}}, data) where Next = &quot;L1&quot;, request(Next, data)
request(::Type{Layer2{Next}}, data) where Next = &quot;L2&quot;, request(Next, data)
request(::Type{Layer3}, data) = &quot;L3&quot;, data

const stack1 = Layer1{Layer2{Layer3}}
const stack2 = Layer2{Layer1{Layer3}}
const stack3 = Layer1{Layer3}</code></pre><pre><code class="language-julia">julia&gt; request(stack1, &quot;foo&quot;)
(&quot;L1&quot;, (&quot;L2&quot;, (&quot;L3&quot;, &quot;foo&quot;)))

julia&gt; request(stack2, &quot;bar&quot;)
(&quot;L2&quot;, (&quot;L1&quot;, (&quot;L3&quot;, &quot;bar&quot;)))

julia&gt; request(stack3, &quot;boo&quot;)
(&quot;L1&quot;, (&quot;L3&quot;, &quot;boo&quot;))</code></pre><p>This stack definition pattern gives the user flexibility in how layers are combined but still allows Julia to do whole-stack compile time optimisations.</p><p>e.g. the <code>request(stack1, &quot;foo&quot;)</code> call above is optimised down to a single function:</p><pre><code class="language-julia">julia&gt; code_typed(request, (Type{stack1}, String))[1].first
CodeInfo(:(begin
    return (Core.tuple)(&quot;L1&quot;, (Core.tuple)(&quot;L2&quot;, (Core.tuple)(&quot;L3&quot;, data)))
end))</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/layers.jl#L6-L58">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.stack" href="#HTTP.stack"><code>HTTP.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>The <code>stack()</code> function returns the default HTTP Layer-stack type. This type is passed as the first parameter to the <a href="../public_interface/#HTTP.request"><code>HTTP.request</code></a> function.</p><p><code>stack()</code> accepts optional keyword arguments to enable/disable specific layers in the stack: <code>request(method, args...; kw...) request(stack(;kw...), args...; kw...)</code></p><p>The minimal request execution stack is:</p><pre><code class="language-julia">stack = MessageLayer{ConnectionPoolLayer{StreamLayer}}</code></pre><p>The figure below illustrates the full request execution stack and its relationship with <a href="../internal_interface/#HTTP.Messages.Response"><code>HTTP.Response</code></a>, <a href="#HTTP.Parsers"><code>HTTP.Parsers</code></a>, <a href="#HTTP.Streams.Stream"><code>HTTP.Stream</code></a> and the <a href="#HTTP.ConnectionPool"><code>HTTP.ConnectionPool</code></a>.</p><pre><code class="language-none"> ┌────────────────────────────────────────────────────────────────────────────┐
 │                                            ┌───────────────────┐           │
 │  HTTP.jl Request Execution Stack           │ HTTP.ParsingError ├ ─ ─ ─ ─ ┐ │
 │                                            └───────────────────┘           │
 │                                            ┌───────────────────┐         │ │
 │                                            │ HTTP.IOError      ├ ─ ─ ─     │
 │                                            └───────────────────┘      │  │ │
 │                                            ┌───────────────────┐           │
 │                                            │ HTTP.StatusError  │─ ─   │  │ │
 │                                            └───────────────────┘   │       │
 │                                            ┌───────────────────┐      │  │ │
 │     request(method, url, headers, body) -&gt; │ HTTP.Response     │   │       │
 │             ──────────────────────────     └─────────▲─────────┘      │  │ │
 │                           ║                          ║             │       │
 │   ┌────────────────────────────────────────────────────────────┐      │  │ │
 │   │ request(RedirectLayer,     method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(BasicAuthLayer,    method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(CookieLayer,       method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(CanonicalizeLayer, method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(MessageLayer,      method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(AWS4AuthLayer,             ::URI, ::Request, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(RetryLayer,                ::URI, ::Request, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(ExceptionLayer,            ::URI, ::Request, body) ├ ─ ┘       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
┌┼───┤ request(ConnectionPoolLayer,       ::URI, ::Request, body) ├ ─ ─ ─     │
││   ├────────────────────────────────────────────────────────────┤         │ │
││   │ request(DebugLayer,                ::IO,  ::Request, body) │           │
││   ├────────────────────────────────────────────────────────────┤         │ │
││   │ request(TimeoutLayer,              ::IO,  ::Request, body) │           │
││   ├────────────────────────────────────────────────────────────┤         │ │
││   │ request(StreamLayer,               ::IO,  ::Request, body) │           │
││   └──────────────┬───────────────────┬─────────────────────────┘         │ │
│└──────────────────┼────────║──────────┼───────────────║─────────────────────┘
│                   │        ║          │               ║                   │  
│┌──────────────────▼───────────────┐   │  ┌──────────────────────────────────┐
││ HTTP.Request                     │   │  │ HTTP.Response                  │ │
││                                  │   │  │                                  │
││ method::String                   ◀───┼──▶ status::Int                    │ │
││ target::String                   │   │  │ headers::Vector{Pair}            │
││ headers::Vector{Pair}            │   │  │ body::Vector{UInt8}            │ │
││ body::Vector{UInt8}              │   │  │                                  │
│└──────────────────▲───────────────┘   │  └───────────────▲────────────────┼─┘
│┌──────────────────┴────────║──────────▼───────────────║──┴──────────────────┐
││ HTTP.Stream &lt;:IO          ║           ╔══════╗       ║                   │ │
││   ┌───────────────────────────┐       ║   ┌──▼─────────────────────────┐   │
││   │ startwrite(::Stream)      │       ║   │ startread(::Stream)        │ │ │
││   │ write(::Stream, body)     │       ║   │ read(::Stream) -&gt; body     │   │
││   │ ...                       │       ║   │ ...                        │ │ │
││   │ closewrite(::Stream)      │       ║   │ closeread(::Stream)        │   │
││   └───────────────────────────┘       ║   └────────────────────────────┘ │ │
│└───────────────────────────║────────┬──║──────║───────║──┬──────────────────┘
│┌──────────────────────────────────┐ │  ║ ┌────▼───────║──▼────────────────┴─┐
││ HTTP.Messages                    │ │  ║ │ HTTP.Parsers                     │
││                                  │ │  ║ │                                  │
││ writestartline(::IO, ::Request)  │ │  ║ │ parse_status_line(bytes, ::Req&#39;) │
││ writeheaders(::IO, ::Request)    │ │  ║ │ parse_header_field(bytes, ::Req&#39;)│
│└──────────────────────────────────┘ │  ║ └──────────────────────────────────┘
│                            ║        │  ║                                     
│┌───────────────────────────║────────┼──║────────────────────────────────────┐
└▶ HTTP.ConnectionPool       ║        │  ║                                    │
 │                     ┌──────────────▼────────┐ ┌───────────────────────┐    │
 │ getconnection() -&gt;  │ HTTP.Transaction &lt;:IO │ │ HTTP.Transaction &lt;:IO │    │
 │                     └───────────────────────┘ └───────────────────────┘    │
 │                           ║    ╲│╱    ║                  ╲│╱               │
 │                           ║     │     ║                   │                │
 │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │
 │              pool: [│ HTTP.Connection       │,│ HTTP.Connection       │...]│
 │                     └───────────┬───────────┘ └───────────┬───────────┘    │
 │                           ║     │     ║                   │                │
 │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │
 │                     │ Base.TCPSocket &lt;:IO   │ │MbedTLS.SSLContext &lt;:IO│    │
 │                     └───────────────────────┘ └───────────┬───────────┘    │
 │                           ║           ║                   │                │
 │                           ║           ║       ┌───────────▼───────────┐    │
 │                           ║           ║       │ Base.TCPSocket &lt;:IO   │    │
 │                           ║           ║       └───────────────────────┘    │
 └───────────────────────────║───────────║────────────────────────────────────┘
                             ║           ║                                     
 ┌───────────────────────────║───────────║──────────────┐  ┏━━━━━━━━━━━━━━━━━━┓
 │ HTTP Server               ▼                          │  ┃ data flow: ════▶ ┃
 │                        Request     Response          │  ┃ reference: ────▶ ┃
 └──────────────────────────────────────────────────────┘  ┗━━━━━━━━━━━━━━━━━━┛</code></pre><p><em>See <code>docs/src/layers</code><a href="http://monodraw.helftone.com"><code>.monopic</code></a>.</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/HTTP.jl#L436-L547">source</a></section><h2><a class="nav-anchor" id="Request-Execution-Layers-1" href="#Request-Execution-Layers-1">Request Execution Layers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RedirectRequest.RedirectLayer" href="#HTTP.RedirectRequest.RedirectLayer"><code>HTTP.RedirectRequest.RedirectLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(RedirectLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Redirects the request in the case of 3xx response status.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/RedirectRequest.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.BasicAuthRequest.BasicAuthLayer" href="#HTTP.BasicAuthRequest.BasicAuthLayer"><code>HTTP.BasicAuthRequest.BasicAuthLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(BasicAuthLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Add <code>Authorization: Basic</code> header using credentials from url userinfo.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/BasicAuthRequest.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.CookieRequest.CookieLayer" href="#HTTP.CookieRequest.CookieLayer"><code>HTTP.CookieRequest.CookieLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(CookieLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Add locally stored Cookies to the request headers. Store new Cookies found in the response headers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/CookieRequest.jl#L12-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.CanonicalizeRequest.CanonicalizeLayer" href="#HTTP.CanonicalizeRequest.CanonicalizeLayer"><code>HTTP.CanonicalizeRequest.CanonicalizeLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(CanonicalizeLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Rewrite request and response headers in Canonical-Camel-Dash-Format.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/CanonicalizeRequest.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.MessageRequest.MessageLayer" href="#HTTP.MessageRequest.MessageLayer"><code>HTTP.MessageRequest.MessageLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(MessageLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Construct a <a href="../internal_interface/#HTTP.Messages.Request"><code>Request</code></a> object and set mandatory headers.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/MessageRequest.jl#L14-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.AWS4AuthRequest.AWS4AuthLayer" href="#HTTP.AWS4AuthRequest.AWS4AuthLayer"><code>HTTP.AWS4AuthRequest.AWS4AuthLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(AWS4AuthLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Add a <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">AWS Signature Version 4</a> <code>Authorization</code> header to a <code>Request</code>.</p><p>Credentials are read from environment variables <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code> and <code>AWS_SESSION_TOKEN</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/AWS4AuthRequest.jl#L11-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RetryRequest.RetryLayer" href="#HTTP.RetryRequest.RetryLayer"><code>HTTP.RetryRequest.RetryLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(RetryLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Retry the request if it throws a recoverable exception.</p><p><code>Base.retry</code> and <code>Base.ExponentialBackOff</code> implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.</p><p>Methods of <code>isrecoverable(e)</code> define which exception types lead to a retry. e.g. <code>HTTP.IOError</code>, <code>Sockets.DNSError</code>, <code>Base.EOFError</code> and <code>HTTP.StatusError</code> (if status is `<code>5xx</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/RetryRequest.jl#L11-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ExceptionRequest.ExceptionLayer" href="#HTTP.ExceptionRequest.ExceptionLayer"><code>HTTP.ExceptionRequest.ExceptionLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(ExceptionLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Throw a <code>StatusError</code> if the request returns an error response status.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/ExceptionRequest.jl#L9-L13">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionRequest.ConnectionPoolLayer" href="#HTTP.ConnectionRequest.ConnectionPoolLayer"><code>HTTP.ConnectionRequest.ConnectionPoolLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(ConnectionPoolLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Retrieve an <code>IO</code> connection from the <a href="#HTTP.ConnectionPool"><code>ConnectionPool</code></a>.</p><p>Close the connection if the request throws an exception. Otherwise leave it open so that it can be reused.</p><p><code>IO</code> related exceptions from <code>Base</code> are wrapped in <code>HTTP.IOError</code>. See <a href="../internal_interface/#HTTP.IOExtras.isioerror"><code>isioerror</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/ConnectionRequest.jl#L11-L21">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.TimeoutRequest.TimeoutLayer" href="#HTTP.TimeoutRequest.TimeoutLayer"><code>HTTP.TimeoutRequest.TimeoutLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(TimeoutLayer, ::IO, ::Request, body) -&gt; HTTP.Response</code></pre><p>Close <code>IO</code> if no data has been received for <code>timeout</code> seconds.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/TimeoutRequest.jl#L7-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.StreamRequest.StreamLayer" href="#HTTP.StreamRequest.StreamLayer"><code>HTTP.StreamRequest.StreamLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">request(StreamLayer, ::IO, ::Request, body) -&gt; HTTP.Response</code></pre><p>Create a <a href="#HTTP.Streams.Stream"><code>Stream</code></a> to send a <code>Request</code> and <code>body</code> to an <code>IO</code> stream and read the response.</p><p>Send the <code>Request</code> body in a background task and begins reading the response immediately so that the transmission can be aborted if the <code>Response</code> status indicates that the server does not wish to receive the message body. <a href="https://tools.ietf.org/html/rfc7230#section-6.5">RFC7230 6.5</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/StreamRequest.jl#L11-L21">source</a></section><h2><a class="nav-anchor" id="Parser-1" href="#Parser-1">Parser</a></h2><p><em>Source: <code>Parsers.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers" href="#HTTP.Parsers"><code>HTTP.Parsers</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>The parser separates a raw HTTP Message into its component parts.</p><p>If the input data is invalid the Parser throws a <code>HTTP.ParseError</code>.</p><p>The <code>parse_*</code> functions processes a single element of a HTTP Message at a time and return a <code>SubString</code> containing the unused portion of the input.</p><p>The Parser does not interpret the Message Headers. It is beyond the scope of the Parser to deal with repeated header fields, multi-line values, cookies or case normalization.</p><p>The Parser has no knowledge of the high-level <code>Request</code> and <code>Response</code> structs defined in <code>Messages.jl</code>. However, the <code>Request</code> and <code>Response</code> structs must have field names compatible with those expected by the <code>parse_status_line!</code> and <code>parse_request_line!</code> functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/Parsers.jl#L1-L17">source</a></section><h2><a class="nav-anchor" id="Messages-1" href="#Messages-1">Messages</a></h2><p><em>Source: <code>Messages.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages" href="#HTTP.Messages"><code>HTTP.Messages</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>The <code>Messages</code> module defines structs that represent <a href="../internal_interface/#HTTP.Messages.Request"><code>HTTP.Request</code></a> and <a href="../internal_interface/#HTTP.Messages.Response"><code>HTTP.Response</code></a> Messages.</p><p>The <code>Response</code> struct has a <code>request</code> field that points to the corresponding <code>Request</code>; and the <code>Request</code> struct has a <code>response</code> field. The <code>Request</code> struct also has a <code>parent</code> field that points to a <code>Response</code> in the case of HTTP Redirect.</p><p>The Messages module defines <code>IO</code> <code>read</code> and <code>write</code> methods for Messages but it does not deal with URIs, creating connections, or executing requests.</p><p>The <code>read</code> methods throw <code>EOFError</code> exceptions if input data is incomplete. and call parser functions that may throw <code>HTTP.ParsingError</code> exceptions. The <code>read</code> and <code>write</code> methods may also result in low level <code>IO</code> exceptions.</p><p><strong>Sending Messages</strong></p><p>Messages are formatted and written to an <code>IO</code> stream by <a href="../internal_interface/#Base.write-Tuple{IO,HTTP.Messages.Message}"><code>Base.write(::IO,::HTTP.Messages.Message)</code></a> and or <a href="../internal_interface/#HTTP.Messages.writeheaders"><code>HTTP.Messages.writeheaders</code></a>.</p><p><strong>Receiving Messages</strong></p><p>Messages are parsed from <code>IO</code> stream data by <a href="../internal_interface/#HTTP.Messages.readheaders"><code>HTTP.Messages.readheaders</code></a>. This function calls <a href="../internal_interface/#HTTP.Parsers.parse_header_field"><code>HTTP.Parsers.parse_header_field</code></a> and passes each header-field to <a href="../internal_interface/#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a>.</p><p><strong>Headers</strong></p><p>Headers are represented by <code>Vector{Pair{String,String}}</code>. As compared to <code>Dict{String,String}</code> this allows <a href="https://tools.ietf.org/html/rfc7230#section-3.2.2">repeated header fields and preservation of order</a>.</p><p>Header values can be accessed by name using <a href="../internal_interface/#HTTP.Messages.header"><code>HTTP.Messages.header</code></a> and <a href="../internal_interface/#HTTP.Messages.setheader"><code>HTTP.Messages.setheader</code></a> (case-insensitive).</p><p>The <a href="../internal_interface/#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a> function handles combining multi-line values, repeated header fields and special handling of multiple <code>Set-Cookie</code> headers.</p><p><strong>Bodies</strong></p><p>The <code>HTTP.Message</code> structs represent the Message Body as <code>Vector{UInt8}</code>.</p><p>Streaming of request and response bodies is handled by the <a href="#HTTP.StreamRequest.StreamLayer"><code>HTTP.StreamLayer</code></a> and the <a href="#HTTP.Streams.Stream"><code>HTTP.Stream</code></a> <code>&lt;: IO</code> stream.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/Messages.jl#L1-L54">source</a></section><h2><a class="nav-anchor" id="Streams-1" href="#Streams-1">Streams</a></h2><p><em>Source: <code>Streams.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Streams.Stream" href="#HTTP.Streams.Stream"><code>HTTP.Streams.Stream</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Stream(::Request, ::IO)</code></pre><p>Creates a <code>HTTP.Stream</code> that wraps an existing <code>IO</code> stream.</p><ul><li><p><code>startwrite(::Stream)</code> sends the <code>Request</code> headers to the <code>IO</code> stream.</p></li><li><p><code>write(::Stream, body)</code> sends the <code>body</code> (or a chunk of the body).</p></li><li><p><code>closewrite(::Stream)</code> sends the final <code>0</code> chunk (if needed) and calls <code>closewrite</code> on the <code>IO</code> stream. When the <code>IO</code> stream is a <a href="../internal_interface/#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>, calling <code>closewrite</code> releases the <a href="../internal_interface/#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a> back into the pool for use by the next pipelined request.</p></li><li><p><code>startread(::Stream)</code> calls <code>startread</code> on the <code>IO</code> stream then  reads and parses the <code>Response</code> headers.  When the <code>IO</code> stream is a <a href="../internal_interface/#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>, calling <code>startread</code> waits for other pipelined responses to be read from the <a href="../internal_interface/#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a>.</p></li><li><p><code>eof(::Stream)</code> and <code>readavailable(::Stream)</code> parse the body from the <code>IO</code>  stream.</p></li><li><p><code>closeread(::Stream)</code> reads the trailers and calls <code>closeread</code> on the <code>IO</code>  stream.  When the <code>IO</code> stream is a <a href="../internal_interface/#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>,  calling <code>closeread</code> releases the readlock and allows the next pipelined  response to be read by another <code>Stream</code> that is waiting in <code>startread</code>.  If a complete response has not been received, <code>closeread</code> throws <code>EOFError</code>.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/Streams.jl#L27-L51">source</a></section><h2><a class="nav-anchor" id="Connections-1" href="#Connections-1">Connections</a></h2><p><em>Source: <code>ConnectionPool.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool" href="#HTTP.ConnectionPool"><code>HTTP.ConnectionPool</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>This module provides the <a href="../internal_interface/#HTTP.ConnectionPool.getconnection"><code>getconnection</code></a> function with support for:</p><ul><li>Opening TCP and SSL connections.</li><li>Reusing connections for multiple Request/Response Messages,</li><li>Pipelining Request/Response Messages. i.e. allowing a new Request to be sent before previous Responses have been read.</li></ul><p>This module defines a <a href="../internal_interface/#HTTP.ConnectionPool.Connection"><code>Connection</code></a> struct to manage pipelining and connection reuse and a <a href="../internal_interface/#HTTP.ConnectionPool.Transaction"><code>Transaction</code></a><code>&lt;: IO</code> struct to manage a single pipelined request. Methods are provided for <code>eof</code>, <code>readavailable</code>, <code>unsafe_write</code> and <code>close</code>. This allows the <code>Transaction</code> object to act as a proxy for the <code>TCPSocket</code> or <code>SSLContext</code> that it wraps.</p><p>The <a href="../internal_interface/#HTTP.ConnectionPool.pool"><code>pool</code></a> is a collection of open <code>Connection</code>s.  The <code>request</code> function calls <code>getconnection</code> to retrieve a connection from the <code>pool</code>.  When the <code>request</code> function has written a Request Message it calls <code>closewrite</code> to signal that the <code>Connection</code> can be reused for writing (to send the next Request). When the <code>request</code> function has read the Response Message it calls <code>closeread</code> to signal that the <code>Connection</code> can be reused for reading.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/5089010c05f33ad680e2ed28ea18b4eef774051a/src/ConnectionPool.jl#L1-L24">source</a></section><footer><hr/><a class="previous" href="../public_interface/"><span class="direction">Previous</span><span class="title">Public Interface</span></a><a class="next" href="../internal_interface/"><span class="direction">Next</span><span class="title">Internal Interfaces</span></a></footer></article></body></html>
