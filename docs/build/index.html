<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · HTTP.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>HTTP.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Requests-1">Requests</a></li><li><a class="toctext" href="#Server-/-Handlers-1">Server / Handlers</a></li><li><a class="toctext" href="#URIs-1">URIs</a></li><li><a class="toctext" href="#Cookies-1">Cookies</a></li><li><a class="toctext" href="#Utilities-1">Utilities</a></li><li class="toplevel"><a class="toctext" href="#HTTP.jl-Internal-Architecture-1">HTTP.jl Internal Architecture</a></li><li><a class="toctext" href="#Request-Execution-Layers-1">Request Execution Layers</a></li><li><a class="toctext" href="#Parser-1">Parser</a></li><li><a class="toctext" href="#Messages-1">Messages</a></li><li><a class="toctext" href="#Streams-1">Streams</a></li><li><a class="toctext" href="#Connections-1">Connections</a></li><li class="toplevel"><a class="toctext" href="#Internal-Interfaces-1">Internal Interfaces</a></li><li><a class="toctext" href="#Parser-Interface-1">Parser Interface</a></li><li><a class="toctext" href="#Messages-Interface-1">Messages Interface</a></li><li><a class="toctext" href="#IOExtras-Interface-1">IOExtras Interface</a></li><li><a class="toctext" href="#Streams-Interface-1">Streams Interface</a></li><li><a class="toctext" href="#Connection-Pooling-Interface-1">Connection Pooling Interface</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaWeb/HTTP.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HTTP.jl-Documentation-1" href="#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></h1><p><code>HTTP.jl</code> is a Julia library for HTTP Messages.</p><p><a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}"><code>HTTP.request</code></a> sends a HTTP Request Message and returns a Response Message.</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;)
println(r.status)
println(String(r.body))</code></pre><p><a href="index.html#HTTP.open"><code>HTTP.open</code></a> sends a HTTP Request Message and opens an <code>IO</code> stream from which the Response can be read.</p><pre><code class="language-julia">HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        write(vlc, http)
    end
end</code></pre><ul><li><a href="index.html#HTTP.jl-Documentation-1">HTTP.jl Documentation</a></li><ul><li><a href="index.html#Requests-1">Requests</a></li><li><a href="index.html#Server-/-Handlers-1">Server / Handlers</a></li><li><a href="index.html#URIs-1">URIs</a></li><li><a href="index.html#Cookies-1">Cookies</a></li><li><a href="index.html#Utilities-1">Utilities</a></li></ul><li><a href="index.html#HTTP.jl-Internal-Architecture-1">HTTP.jl Internal Architecture</a></li><ul><li><a href="index.html#Request-Execution-Layers-1">Request Execution Layers</a></li><li><a href="index.html#Parser-1">Parser</a></li><li><a href="index.html#Messages-1">Messages</a></li><li><a href="index.html#Streams-1">Streams</a></li><li><a href="index.html#Connections-1">Connections</a></li></ul><li><a href="index.html#Internal-Interfaces-1">Internal Interfaces</a></li><ul><li><a href="index.html#Parser-Interface-1">Parser Interface</a></li><li><a href="index.html#Messages-Interface-1">Messages Interface</a></li><li><a href="index.html#IOExtras-Interface-1">IOExtras Interface</a></li><li><a href="index.html#Streams-Interface-1">Streams Interface</a></li><li><a href="index.html#Connection-Pooling-Interface-1">Connection Pooling Interface</a></li></ul></ul><h2><a class="nav-anchor" id="Requests-1" href="#Requests-1">Requests</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}" href="#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}"><code>HTTP.request</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">HTTP.request(method, url [, headers [, body]]; &lt;keyword arguments&gt;]) -&gt; HTTP.Response</code></pre><p>Send a HTTP Request Message and recieve a HTTP Response Message.</p><p>e.g.</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;)
println(r.status)
println(String(r.body))</code></pre><p><code>headers</code> can be any collection where <code>[string(k) =&gt; string(v) for (k,v) in headers]</code> yields <code>Vector{Pair}</code>. e.g. a <code>Dict()</code>, a <code>Vector{Tuple}</code>, a <code>Vector{Pair}</code> or an iterator.</p><p><code>body</code> can take a number of forms:</p><ul><li><p>a <code>String</code>, a <code>Vector{UInt8}</code> or any <code>T</code> accepted by <code>write(::IO, ::T)</code></p></li><li><p>a collection of <code>String</code> or <code>AbstractVector{UInt8}</code> or <code>IO</code> streams or items of any type <code>T</code> accepted by <code>write(::IO, ::T...)</code></p></li><li><p>a readable <code>IO</code> stream or any <code>IO</code>-like type <code>T</code> for which <code>eof(T)</code> and <code>readavailable(T)</code> are defined.</p></li></ul><p>The <code>HTTP.Response</code> struct contains:</p><ul><li><p><code>status::Int16</code> e.g. <code>200</code></p></li><li><p><code>headers::Vector{Pair{String,String}}</code>  e.g. [&quot;Server&quot; =&gt; &quot;Apache&quot;, &quot;Content-Type&quot; =&gt; &quot;text/html&quot;]</p></li><li><p><code>body::Vector{UInt8}</code>, the Response Body bytes  (empty if a <code>response_stream</code> was specified in the <code>request</code>).</p></li></ul><p>Functions <code>HTTP.get</code>, <code>HTTP.put</code>, <code>HTTP.post</code> and <code>HTTP.head</code> are defined as shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>, etc.</p><p><code>HTTP.request</code> and <code>HTTP.open</code> also accept optional keyword parameters.</p><p>e.g.</p><pre><code class="language-julia">HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;; retries=4, cookies=true)

HTTP.get(&quot;http://s3.us-east-1.amazonaws.com/&quot;; aws_authorization=true)

conf = (readtimeout = 10,
        pipeline_limit = 4,
        retry = false,
        redirect = false)

HTTP.get(&quot;http://httpbin.org/ip&quot;; conf..)
HTTP.put(&quot;http://httpbin.org/put&quot;, [], &quot;Hello&quot;; conf..)</code></pre><p>Streaming options</p><ul><li><p><code>response_stream = nothing</code>, a writeable <code>IO</code> stream or any <code>IO</code>-like  type <code>T</code> for which <code>write(T, AbstractVector{UInt8})</code> is defined.</p></li><li><p><code>verbose = 0</code>, set to <code>1</code> or <code>2</code> for extra message logging.</p></li></ul><p>Connection Pool options</p><ul><li><p><code>connection_limit = 8</code>, number of concurrent connections to each host:port.</p></li><li><p><code>pipeline_limit = 16</code>, number of concurrent requests per connection.</p></li><li><p><code>reuse_limit = nolimit</code>, number of times a connection is reused after the                          first request.</p></li><li><p><code>socket_type = TCPSocket</code></p></li></ul><p>Timeout options</p><ul><li><p><code>readtimeout = 60</code>, close the connection if no data is recieved for this many seconds. Use <code>readtimeout = 0</code> to disable.</p></li></ul><p>Retry options</p><ul><li><p><code>retry = true</code>, retry idempotent requests in case of error.</p></li><li><p><code>retries = 4</code>, number of times to retry.</p></li><li><p><code>retry_non_idempotent = false</code>, retry non-idempotent requests too. e.g. POST.</p></li></ul><p>Redirect options</p><ul><li><p><code>redirect = true</code>, follow 3xx redirect responses.</p></li><li><p><code>redirect_limit = 3</code>, number of times to redirect.</p></li><li><p><code>forwardheaders = false</code>, forward original headers on redirect.</p></li></ul><p>Status Exception options</p><ul><li><p><code>statusexception = true</code>, throw <code>HTTP.StatusError</code> for response status &gt;= 300.</p></li></ul><p>SSLContext options</p><ul><li><p><code>require_ssl_verification = false</code>, pass <code>MBEDTLS_SSL_VERIFY_REQUIRED</code> to the mbed TLS library. <a href="https://tls.mbed.org/api/ssl_8h.html#a5695285c9dbfefec295012b566290f37">&quot;... peer must present a valid certificate, handshake is aborted if   verification failed.&quot;</a></p></li><li><p>sslconfig = SSLConfig(require_ssl_verification)`</p></li></ul><p>Basic Authenticaiton options</p><ul><li><p>basicauthorization=false, add <code>Authorization: Basic</code> header using credentials from url userinfo.</p></li></ul><p>AWS Authenticaiton options</p><ul><li><p><code>awsauthorization = false</code>, enable AWS4 Authentication.</p></li><li><p><code>aws_service = split(uri.host, &quot;.&quot;)[1]</code></p></li><li><p><code>aws_region = split(uri.host, &quot;.&quot;)[2]</code></p></li><li><p><code>aws_access_key_id = ENV[&quot;AWS_ACCESS_KEY_ID&quot;]</code></p></li><li><p><code>aws_secret_access_key = ENV[&quot;AWS_SECRET_ACCESS_KEY&quot;]</code></p></li><li><p><code>aws_session_token = get(ENV, &quot;AWS_SESSION_TOKEN&quot;, &quot;&quot;)</code></p></li><li><p><code>body_sha256 = digest(MD_SHA256, body)</code>,</p></li><li><p><code>body_md5 = digest(MD_MD5, body)</code>,</p></li></ul><p>Cookie options</p><ul><li><p><code>cookies = false</code>, enable cookies.</p></li><li><p><code>cookiejar::Dict{String, Set{Cookie}}=default_cookiejar</code></p></li></ul><p>Cananoincalization options</p><ul><li><p><code>canonicalizeheaders = false</code>, rewrite request and response headers in Canonical-Camel-Dash-Format.</p></li></ul><p><strong>Request Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)</code></pre><p>Stream body from file:</p><pre><code class="language-julia">io = open(&quot;post_data.txt&quot;, &quot;r&quot;)
request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], io)</code></pre><p>Generator body:</p><pre><code class="language-julia">chunks = (&quot;chunk$i&quot; for i in 1:1000)
request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p>Collection body:</p><pre><code class="language-julia">chunks = [preamble_chunk, data_chunk, checksum(data_chunk)]
request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p><code>open() do io</code> body:</p><pre><code class="language-julia">HTTP.open(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;) do io
    write(io, preamble_chunk)
    write(io, data_chunk)
    write(io, checksum(data_chunk))
end</code></pre><p><strong>Response Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">r = request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;)
println(String(r.body))</code></pre><p>Stream body to file:</p><pre><code class="language-julia">io = open(&quot;get_data.txt&quot;, &quot;w&quot;)
r = request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)
println(read(&quot;get_data.txt&quot;))</code></pre><p>Stream body through buffer:</p><pre><code class="language-julia">io = BufferStream()
@async while !eof(io)
    bytes = readavailable(io))
    println(&quot;GET data: $bytes&quot;)
end
r = request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)</code></pre><p>Stream body through <code>open() do io</code>:</p><pre><code class="language-julia">r = HTTP.open(&quot;GET&quot;, &quot;http://httpbin.org/stream/10&quot;) do io
   while !eof(io)
       println(String(readavailable(io)))
   end
end

HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    n = 0
    r = startread(http)
    l = parse(Int, header(r, &quot;Content-Length&quot;))
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        while !eof(http)
            bytes = readavailable(http)
            write(vlc, bytes)
            n += length(bytes)
            println(&quot;streamed $n-bytes $((100*n)÷l)%\u1b[1A&quot;)
        end
    end
end</code></pre><p><strong>Request and Response Body Examples</strong></p><p>String bodies:</p><pre><code class="language-julia">r = request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)
println(String(r.body))</code></pre><p>Stream bodies from and to files:</p><pre><code class="language-julia">in = open(&quot;foo.png&quot;, &quot;r&quot;)
out = open(&quot;foo.jpg&quot;, &quot;w&quot;)
request(&quot;POST&quot;, &quot;http://convert.com/png2jpg&quot;, [], in, response_stream=out)</code></pre><p>Stream bodies through: <code>open() do io</code>:</p><pre><code class="language-julia">HTTP.open(&quot;POST&quot;, &quot;http://music.com/play&quot;) do io
    write(io, JSON.json([
        &quot;auth&quot; =&gt; &quot;12345XXXX&quot;,
        &quot;song_id&quot; =&gt; 7,
    ]))
    r = readresponse(io)
    @show r.status
    while !eof(io)
        bytes = readavailable(io))
        play_audio(bytes)
    end
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L33-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.open" href="#HTTP.open"><code>HTTP.open</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.open(method, url, [,headers]) do io
    write(io, body)
    [startread(io) -&gt; HTTP.Response]
    while !eof(io)
        readavailable(io) -&gt; AbstractVector{UInt8}
    end
end -&gt; HTTP.Response</code></pre><p>The <code>HTTP.open</code> API allows the Request Body to be written to (and/or the Response Body to be read from) an <code>IO</code> stream.</p><p>e.g. Streaming an audio file to the <code>vlc</code> player:</p><pre><code class="language-julia">HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        write(vlc, http)
    end
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L294-L315">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.get" href="#HTTP.get"><code>HTTP.get</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.get(url [, headers]; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L321-L326">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.put" href="#HTTP.put"><code>HTTP.put</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.put(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;PUT&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L331-L335">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.post" href="#HTTP.post"><code>HTTP.post</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.post(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;POST&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L340-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.head" href="#HTTP.head"><code>HTTP.head</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.head(url; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;HEAD&quot;, ...)</code>. See <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}"><code>HTTP.request</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L349-L353">source</a></section><p>Request functions may throw the following exceptions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ExceptionRequest.StatusError" href="#HTTP.ExceptionRequest.StatusError"><code>HTTP.ExceptionRequest.StatusError</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The <code>Response</code> has a <code>4xx</code>, <code>5xx</code> or unrecognised status code.</p><p>Fields:</p><ul><li><p><code>status::Int16</code>, the response status code.</p></li><li><p><code>response</code> the <a href="index.html#HTTP.Messages.Response"><code>HTTP.Response</code></a></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ExceptionRequest.jl#L31-L37">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.ParsingError" href="#HTTP.Parsers.ParsingError"><code>HTTP.Parsers.ParsingError</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The [<code>Parser</code>] input was invalid.</p><p>Fields:</p><ul><li><p><code>code</code>, internal <code>@enum ParsingErrorCode</code>.</p></li><li><p><code>state</code>, internal parsing state.</p></li><li><p><code>status::Int32</code>, HTTP response status.</p></li><li><p><code>msg::String</code>, error message.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L244-L252">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.IOError" href="#HTTP.IOExtras.IOError"><code>HTTP.IOExtras.IOError</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The request terminated with due to an IO-related error.</p><p>Fields:</p><ul><li><p><code>e</code>, the error.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/IOExtras.jl#L27-L32">source</a></section><pre><code class="language-none">Base.DNSError</code></pre><h2><a class="nav-anchor" id="Server-/-Handlers-1" href="#Server-/-Handlers-1">Server / Handlers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Nitrogen.serve" href="#HTTP.Nitrogen.serve"><code>HTTP.Nitrogen.serve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">HTTP.serve([server,] host::IPAddr, port::Int; verbose::Bool=true, kwargs...)</code></pre><p>Start a server listening on the provided <code>host</code> and <code>port</code>. <code>verbose</code> indicates whether server activity should be logged. Optional keyword arguments allow construction of <code>Server</code> on the fly if the <code>server</code> argument isn&#39;t provided directly. See <code>?HTTP.Server</code> for more details on server construction and supported keyword arguments. By default, <code>HTTP.serve</code> aims to &quot;never die&quot;, catching and recovering from all internal errors. Two methods for stopping <code>HTTP.serve</code> include interrupting (ctrl/cmd+c) if blocking on the main task, or sending the kill signal via the server&#39;s in channel (<code>put!(server.in, HTTP.KILL)</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/server.jl#L335-L344">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Nitrogen.Server" href="#HTTP.Nitrogen.Server"><code>HTTP.Nitrogen.Server</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Server(handler, logger::IO=STDOUT; kwargs...)</code></pre><p>An http/https server. Supports listening on a <code>host</code> and <code>port</code> via the <code>HTTP.serve(server, host, port)</code> function. <code>handler</code> is a function of the form <code>f(::Request, ::Response) -&gt; HTTP.Response</code>, i.e. it takes both a <code>Request</code> and pre-built <code>Response</code> objects as inputs and returns the, potentially modified, <code>Response</code>. <code>logger</code> indicates where logging output should be directed. When <code>HTTP.serve</code> is called, it aims to &quot;never die&quot;, catching and recovering from all internal errors. To forcefully stop, one can obviously kill the julia process, interrupt (ctrl/cmd+c) if main task, or send the kill signal over a server in channel like: <code>put!(server.in, HTTP.KILL)</code>.</p><p>Supported keyword arguments include:</p><ul><li><p><code>cert</code>: if https, the cert file to use, as passed to <code>HTTP.MbedTLS.SSLConfig(cert, key)</code></p></li><li><p><code>key</code>: if https, the key file to use, as passed to <code>HTTP.MbedTLS.SSLConfig(cert, key)</code></p></li><li><p><code>tlsconfig</code>: pass in an already-constructed <code>HTTP.MbedTLS.SSLConfig</code> instance</p></li><li><p><code>readtimeout</code>: how long a client connection will be left open without receiving any bytes</p></li><li><p><code>ratelimit</code>: a <code>Rational{Int}</code> of the form <code>5//1</code> indicating how many <code>messages//second</code> should be allowed per client IP address; requests exceeding the rate limit will be dropped</p></li><li><p><code>support100continue</code>: a <code>Bool</code> indicating whether <code>Expect: 100-continue</code> headers should be supported for delayed request body sending; default = <code>true</code></p></li><li><p><code>logbody</code>: whether the Response body should be logged when <code>verbose=true</code> logging is enabled; default = <code>true</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/server.jl#L68-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.Handler" href="#HTTP.Handlers.Handler"><code>HTTP.Handlers.Handler</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Abstract type representing an object that knows how to &quot;handle&quot; a server request.</p><p>Types of handlers include <code>HandlerFunction</code> (a julia function of the form <code>f(request, response</code>) and <code>Router</code> (which pattern matches request url paths to other specific <code>Handler</code> types).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/handlers.jl#L29-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.HandlerFunction" href="#HTTP.Handlers.HandlerFunction"><code>HTTP.Handlers.HandlerFunction</code></a> — <span class="docstring-category">Type</span>.</div><div><p>HandlerFunction(f::Function)</p><p>A Function-wrapper type that is a subtype of <code>Handler</code>. Takes a single Function as an argument. The provided argument should be of the form <code>f(request, response) =&gt; Response</code>, i.e. it accepts both a <code>Request</code> and <code>Response</code> and returns a <code>Response</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/handlers.jl#L37-L43">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.Router" href="#HTTP.Handlers.Router"><code>HTTP.Handlers.Router</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Router(h::Handler) Router(f::Function) Router()</p><p>An <code>HTTP.Handler</code> type that supports mapping request url paths to other <code>HTTP.Handler</code> types. Can accept a default <code>Handler</code> or <code>Function</code> that will be used in case no other handlers match; by default, a 404 response handler is used. Paths can be mapped to a handler via <code>HTTP.register!(r::Router, path, handler)</code>, see <code>?HTTP.register!</code> for more details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/handlers.jl#L53-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Handlers.register!" href="#HTTP.Handlers.register!"><code>HTTP.Handlers.register!</code></a> — <span class="docstring-category">Function</span>.</div><div><p>HTTP.register!(r::Router, url, handler) HTTP.register!(r::Router, m::Union{HTTP.Method, String}, url, handler)</p><p>Function to map request urls matching <code>url</code> and an optional method <code>m</code> to another <code>handler::HTTP.Handler</code>. URLs are registered one at a time, and multiple urls can map to the same handler. Methods can be passed as a string <code>&quot;GET&quot;</code> or enum object directly <code>HTTP.GET</code>. The URL can be passed as a String or <code>HTTP.URI</code> object directly. Requests can be routed based on: method, scheme, hostname, or path. The following examples show how various urls will direct how a request is routed by a server:</p><ul><li><p><code>&quot;http://*&quot;</code>: match all HTTP requests, regardless of path</p></li><li><p><code>&quot;https://*&quot;</code>: match all HTTPS requests, regardless of path</p></li><li><p><code>&quot;google&quot;</code>: regardless of scheme, match requests to the hostname &quot;google&quot;</p></li><li><p><code>&quot;google/gmail&quot;</code>: match requests to hostname &quot;google&quot;, and path starting with &quot;gmail&quot;</p></li><li><p><code>&quot;/gmail&quot;</code>: regardless of scheme or host, match any request with a path starting with &quot;gmail&quot;</p></li><li><p><code>&quot;/gmail/userId/*/inbox</code>: match any request matching the path pattern, &quot;*&quot; is used as a wildcard that matches any value between the two &quot;/&quot;</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/handlers.jl#L86-L103">source</a></section><h2><a class="nav-anchor" id="URIs-1" href="#URIs-1">URIs</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.URI" href="#HTTP.URIs.URI"><code>HTTP.URIs.URI</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">HTTP.URL(host; userinfo=&quot;&quot;, path=&quot;&quot;, query=&quot;&quot;, fragment=&quot;&quot;, isconnect=false)
HTTP.URI(; scheme=&quot;&quot;, host=&quot;&quot;, port=&quot;&quot;, ...)
HTTP.URI(str; isconnect=false)
parse(HTTP.URI, str::String; isconnect=false)</code></pre><p>A type representing a valid uri. Can be constructed from distinct parts using the various supported keyword arguments. With a raw, already-encoded uri string, use <code>parse(HTTP.URI, str)</code> to parse the <code>HTTP.URI</code> directly. The <code>HTTP.URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>For efficiency, the internal representation is stored as a set of offsets and lengths to the various uri components. To access and return these components as strings, use the various accessor methods:</p><ul><li><p><code>HTTP.scheme</code>: returns the scheme (if any) associated with the uri</p></li><li><p><code>HTTP.userinfo</code>: returns the userinfo (if any) associated with the uri</p></li><li><p><code>HTTP.host</code>: returns the host only of the uri</p></li><li><p><code>HTTP.port</code>: returns the port of the uri; will return &quot;80&quot; or &quot;443&quot; by default if the scheme is &quot;http&quot; or &quot;https&quot;, respectively</p></li><li><p><code>HTTP.hostport</code>: returns the &quot;host:port&quot; combination; if the port is not provided or is the default port for the uri scheme, it will be omitted</p></li><li><p><code>HTTP.path</code>: returns the path for a uri</p></li><li><p><code>HTTP.query</code>: returns the query for a uri</p></li><li><p><code>HTTP.fragment</code>: returns the fragment for a uri</p></li><li><p><code>HTTP.resource</code>: returns the path-query-fragment combination</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/uri.jl#L13-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.escapeuri" href="#HTTP.URIs.escapeuri"><code>HTTP.URIs.escapeuri</code></a> — <span class="docstring-category">Function</span>.</div><div><p>percent-encode a string, dict, or pair for a uri</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/uri.jl#L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.unescapeuri" href="#HTTP.URIs.unescapeuri"><code>HTTP.URIs.unescapeuri</code></a> — <span class="docstring-category">Function</span>.</div><div><p>unescape a percent-encoded uri/url</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/uri.jl#L205">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.URIs.splitpath" href="#HTTP.URIs.splitpath"><code>HTTP.URIs.splitpath</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Splits the path into components See: http://tools.ietf.org/html/rfc3986#section-3.3</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/uri.jl#L223-L226">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isvalid-Tuple{HTTP.URIs.URI}" href="#Base.isvalid-Tuple{HTTP.URIs.URI}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span>.</div><div><p>checks if a <code>HTTP.URI</code> is valid</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/uri.jl#L165">source</a></section><h2><a class="nav-anchor" id="Cookies-1" href="#Cookies-1">Cookies</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><p><code>name</code>: name of the cookie</p></li><li><p><code>value</code>: value of the cookie</p></li><li><p><code>path</code>: applicable path for the cookie</p></li><li><p><code>domain</code>: applicable domain for the cookie</p></li><li><p><code>expires</code>: a <code>Dates.DateTime</code> representing when the cookie should expire</p></li><li><p><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</p></li><li><p><code>secure::Bool</code>: secure cookie attribute</p></li><li><p><code>httponly::Bool</code>: httponly cookie attribute</p></li><li><p><code>hostonly::Bool</code>: hostonly cookie attribute</p></li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/cookies.jl#L53-L73">source</a></section><h2><a class="nav-anchor" id="Utilities-1" href="#Utilities-1">Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.sniff" href="#HTTP.sniff"><code>HTTP.sniff</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>HTTP.sniff(content::Union{Vector{UInt8}, String, IO})</code> =&gt; <code>String</code> (mimetype)</p><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/sniff.jl#L21-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Strings.escapehtml" href="#HTTP.Strings.escapehtml"><code>HTTP.Strings.escapehtml</code></a> — <span class="docstring-category">Function</span>.</div><div><p>escapeHTML(i::String)</p><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Strings.jl#L5-L9">source</a></section><h1><a class="nav-anchor" id="HTTP.jl-Internal-Architecture-1" href="#HTTP.jl-Internal-Architecture-1">HTTP.jl Internal Architecture</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Layer" href="#HTTP.Layer"><code>HTTP.Layer</code></a> — <span class="docstring-category">Type</span>.</div><div><p><strong>Request Execution Stack</strong></p><p>The Request Execution Stack is separated into composable layers.</p><p>Each layer is defined by a nested type <code>Layer{Next}</code> where the <code>Next</code> parameter defines the next layer in the stack. The <code>request</code> method for each layer takes a <code>Layer{Next}</code> type as its first argument and dispatches the request to the next layer using <code>request(Next, ...)</code>.</p><p>The example below defines three layers and three stacks each with a different combination of layers.</p><pre><code class="language-julia">abstract type Layer end
abstract type Layer1{Next &lt;: Layer} &lt;: Layer end
abstract type Layer2{Next &lt;: Layer} &lt;: Layer end
abstract type Layer3 &lt;: Layer end

request(::Type{Layer1{Next}}, data) where Next = &quot;L1&quot;, request(Next, data)
request(::Type{Layer2{Next}}, data) where Next = &quot;L2&quot;, request(Next, data)
request(::Type{Layer3}, data) = &quot;L3&quot;, data

const stack1 = Layer1{Layer2{Layer3}}
const stack2 = Layer2{Layer1{Layer3}}
const stack3 = Layer1{Layer3}</code></pre><pre><code class="language-julia">julia&gt; request(stack1, &quot;foo&quot;)
(&quot;L1&quot;, (&quot;L2&quot;, (&quot;L3&quot;, &quot;foo&quot;)))

julia&gt; request(stack2, &quot;bar&quot;)
(&quot;L2&quot;, (&quot;L1&quot;, (&quot;L3&quot;, &quot;bar&quot;)))

julia&gt; request(stack3, &quot;boo&quot;)
(&quot;L1&quot;, (&quot;L3&quot;, &quot;boo&quot;))</code></pre><p>This stack definition pattern gives the user flexibility in how layers are combined but still allows Julia to do whole-stack comiple time optimistations.</p><p>e.g. the <code>request(stack1, &quot;foo&quot;)</code> call above is optimised down to a single function:</p><pre><code class="language-julia">julia&gt; code_typed(request, (Type{stack1}, String))[1].first
CodeInfo(:(begin
    return (Core.tuple)(&quot;L1&quot;, (Core.tuple)(&quot;L2&quot;, (Core.tuple)(&quot;L3&quot;, data)))
end))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L359-L412">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.stack" href="#HTTP.stack"><code>HTTP.stack</code></a> — <span class="docstring-category">Function</span>.</div><div><p>The <code>stack()</code> function returns the default HTTP Layer-stack type. This type is passed as the first parameter to the <a href="index.html#HTTP.request-Tuple{String,HTTP.URIs.URI,Array{Pair{String,String},1},Any}"><code>HTTP.request</code></a> function.</p><p><code>stack()</code> accepts optional keyword arguments to enable/disable specific layers in the stack: <code>request(method, args...; kw...) request(stack(;kw...), args...; kw...)</code></p><p>The minimal request execution stack is:</p><pre><code class="language-julia">stack = MessageLayer{ConnectionPoolLayer{StreamLayer}}</code></pre><p>The figure below illustrates the full request exection stack and its relationship with <a href="index.html#HTTP.Messages.Response"><code>HTTP.Response</code></a>, <a href="index.html#HTTP.Parsers.Parser"><code>HTTP.Parser</code></a>, <a href="index.html#HTTP.Streams.Stream"><code>HTTP.Stream</code></a> and the <a href="index.html#HTTP.ConnectionPool"><code>HTTP.ConnectionPool</code></a>.</p><pre><code class="language-none"> ┌────────────────────────────────────────────────────────────────────────────┐
 │                                            ┌───────────────────┐           │
 │  HTTP.jl Request Execution Stack           │ HTTP.ParsingError ├ ─ ─ ─ ─ ┐ │
 │                                            └───────────────────┘           │
 │                                            ┌───────────────────┐         │ │
 │                                            │ HTTP.IOError      ├ ─ ─ ─     │
 │                                            └───────────────────┘      │  │ │
 │                                            ┌───────────────────┐           │
 │                                            │ HTTP.StatusError  │─ ─   │  │ │
 │                                            └───────────────────┘   │       │
 │                                            ┌───────────────────┐      │  │ │
 │     request(method, uri, headers, body) -&gt; │ HTTP.Response     │   │       │
 │             ──────────────────────────     └─────────▲─────────┘      │  │ │
 │                           ║                          ║             │       │
 │   ┌────────────────────────────────────────────────────────────┐      │  │ │
 │   │ request(RedirectLayer,     method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(BasicAuthLayer,    method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(CookieLayer,       method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(CanonicalizeLayer, method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(MessageLayer,      method, ::URI, ::Headers, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(AWS4AuthLayer,             ::URI, ::Request, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(RetryLayer,                ::URI, ::Request, body) │   │       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
 │   │ request(ExceptionLayer,            ::URI, ::Request, body) ├ ─ ┘       │
 │   ├────────────────────────────────────────────────────────────┤      │  │ │
┌┼───┤ request(ConnectionPoolLayer,       ::URI, ::Request, body) ├ ─ ─ ─     │
││   ├────────────────────────────────────────────────────────────┤         │ │
││   │ request(TimeoutLayer,              ::IO,  ::Request, body) │           │
││   ├────────────────────────────────────────────────────────────┤         │ │
││   │ request(StreamLayer,               ::IO,  ::Request, body) │           │
││   └──────────────┬───────────────────┬─────────────────────────┘         │ │
│└──────────────────┼────────║──────────┼───────────────║─────────────────────┘
│                   │        ║          │               ║                   │  
│┌──────────────────▼───────────────┐   │  ┌──────────────────────────────────┐
││ HTTP.Request                     │   │  │ HTTP.Response                  │ │
││                                  │   │  │                                  │
││ method::String                   ◀───┼──▶ status::Int                    │ │
││ uri::String                      │   │  │ headers::Vector{Pair}            │
││ headers::Vector{Pair}            │   │  │ body::Vector{UInt8}            │ │
││ body::Vector{UInt8}              │   │  │                                  │
│└──────────────────▲───────────────┘   │  └───────────────▲────────────────┼─┘
│┌──────────────────┴────────║──────────▼───────────────║──┴──────────────────┐
││ HTTP.Stream &lt;:IO          ║           ╔══════╗       ║                   │ │
││   ┌───────────────────────────┐       ║   ┌──▼─────────────────────────┐   │
││   │ startwrite(::Stream)      │       ║   │ startread(::Stream)        │ │ │
││   │ write(::Stream, body)     │       ║   │ read(::Stream) -&gt; body     │   │
││   │ ...                       │       ║   │ ...                        │ │ │
││   │ closewrite(::Stream)      │       ║   │ closeread(::Stream)        │   │
││   └───────────────────────────┘       ║   └────────────────────────────┘ │ │
│└───────────────────────────║────────┬──║──────║───────║──┬──────────────────┘
│┌──────────────────────────────────┐ │  ║ ┌────▼───────║──▼────────────────┴─┐
││ HTTP.Messages                    │ │  ║ │ HTTP.Parser                      │
││                                  │ │  ║ │                                  │
││ writestartline(::IO, ::Request)  │ │  ║ │ parseheaders(bytes) do h::Pair   │
││ writeheaders(::IO, ::Request)    │ │  ║ │ parsebody(bytes) -&gt; bytes        │
│└──────────────────────────────────┘ │  ║ └──────────────────────────────────┘
│                            ║        │  ║                                     
│┌───────────────────────────║────────┼──║────────────────────────────────────┐
└▶ HTTP.ConnectionPool       ║        │  ║                                    │
 │                     ┌──────────────▼────────┐ ┌───────────────────────┐    │
 │ getconnection() -&gt;  │ HTTP.Transaction &lt;:IO │ │ HTTP.Transaction &lt;:IO │    │
 │                     └───────────────────────┘ └───────────────────────┘    │
 │                           ║    ╲│╱    ║                  ╲│╱               │
 │                           ║     │     ║                   │                │
 │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │
 │              pool: [│ HTTP.Connection       │,│ HTTP.Connection       │...]│
 │                     └───────────┬───────────┘ └───────────┬───────────┘    │
 │                           ║     │     ║                   │                │
 │                     ┌───────────▼───────────┐ ┌───────────▼───────────┐    │
 │                     │ Base.TCPSocket &lt;:IO   │ │MbedTLS.SSLContext &lt;:IO│    │
 │                     └───────────────────────┘ └───────────┬───────────┘    │
 │                           ║           ║                   │                │
 │                           ║           ║       ┌───────────▼───────────┐    │
 │                           ║           ║       │ Base.TCPSocket &lt;:IO   │    │
 │                           ║           ║       └───────────────────────┘    │
 └───────────────────────────║───────────║────────────────────────────────────┘
                             ║           ║                                     
 ┌───────────────────────────║───────────║──────────────┐  ┏━━━━━━━━━━━━━━━━━━┓
 │ HTTP Server               ▼                          │  ┃ data flow: ════▶ ┃
 │                        Request     Response          │  ┃ reference: ────▶ ┃
 └──────────────────────────────────────────────────────┘  ┗━━━━━━━━━━━━━━━━━━┛</code></pre><p><em>See <code>docs/src/layers</code><a href="http://monodraw.helftone.com"><code>.monopic</code></a>.</em></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/HTTP.jl#L430-L539">source</a></section><h2><a class="nav-anchor" id="Request-Execution-Layers-1" href="#Request-Execution-Layers-1">Request Execution Layers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RedirectRequest.RedirectLayer" href="#HTTP.RedirectRequest.RedirectLayer"><code>HTTP.RedirectRequest.RedirectLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(RedirectLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Redirects the request in the case of 3xx response status.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/RedirectRequest.jl#L11-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.BasicAuthRequest.BasicAuthLayer" href="#HTTP.BasicAuthRequest.BasicAuthLayer"><code>HTTP.BasicAuthRequest.BasicAuthLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(BasicAuthLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Add <code>Authorization: Basic</code> header using credentials from url userinfo.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/BasicAuthRequest.jl#L13-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.CookieRequest.CookieLayer" href="#HTTP.CookieRequest.CookieLayer"><code>HTTP.CookieRequest.CookieLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(CookieLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Add locally stored Cookies to the request headers. Store new Cookies found in the response headers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/CookieRequest.jl#L13-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.CanonicalizeRequest.CanonicalizeLayer" href="#HTTP.CanonicalizeRequest.CanonicalizeLayer"><code>HTTP.CanonicalizeRequest.CanonicalizeLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(CanonicalizeLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Rewrite request and response headers in Canonical-Camel-Dash-Format.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/CanonicalizeRequest.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.MessageRequest.MessageLayer" href="#HTTP.MessageRequest.MessageLayer"><code>HTTP.MessageRequest.MessageLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(MessageLayer, method, ::URI, headers, body) -&gt; HTTP.Response</code></pre><p>Construct a <a href="index.html#HTTP.Messages.Request"><code>Request</code></a> object and set mandatory headers.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/MessageRequest.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.AWS4AuthRequest.AWS4AuthLayer" href="#HTTP.AWS4AuthRequest.AWS4AuthLayer"><code>HTTP.AWS4AuthRequest.AWS4AuthLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(AWS4AuthLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Add a <a href="http://docs.aws.amazon.com/general/latest/gr/signature-version-4.html">AWS Signature Version 4</a> <code>Authorization</code> header to a <code>Request</code>.</p><p>Credentials are read from environment variables <code>AWS_ACCESS_KEY_ID</code>, <code>AWS_SECRET_ACCESS_KEY</code> and <code>AWS_SESSION_TOKEN</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/AWS4AuthRequest.jl#L16-L25">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.RetryRequest.RetryLayer" href="#HTTP.RetryRequest.RetryLayer"><code>HTTP.RetryRequest.RetryLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(RetryLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Retry the request if it throws a recoverable exception.</p><p><code>Base.retry</code> and <code>Base.ExponentialBackOff</code> implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.</p><p>Methods of <code>isrecoverable(e)</code> define which exception types lead to a retry. e.g. <code>HTTP.IOError</code>, <code>Base.DNSError</code>, <code>Base.EOFError</code> and <code>HTTP.StatusError</code> (if status is `<code>5xx</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/RetryRequest.jl#L11-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ExceptionRequest.ExceptionLayer" href="#HTTP.ExceptionRequest.ExceptionLayer"><code>HTTP.ExceptionRequest.ExceptionLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(ExceptionLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Throw a <code>StatusError</code> if the request returns an error response status.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ExceptionRequest.jl#L10-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionRequest.ConnectionPoolLayer" href="#HTTP.ConnectionRequest.ConnectionPoolLayer"><code>HTTP.ConnectionRequest.ConnectionPoolLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(ConnectionPoolLayer, ::URI, ::Request, body) -&gt; HTTP.Response</code></pre><p>Retrieve an <code>IO</code> connection from the <a href="index.html#HTTP.ConnectionPool"><code>ConnectionPool</code></a>.</p><p>Close the connection if the request throws an exception. Otherwise leave it open so that it can be reused.</p><p><code>IO</code> related exceptions from <code>Base</code> are wrapped in <code>HTTP.IOError</code>. See <a href="index.html#HTTP.IOExtras.isioerror"><code>isioerror</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionRequest.jl#L12-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.TimeoutRequest.TimeoutLayer" href="#HTTP.TimeoutRequest.TimeoutLayer"><code>HTTP.TimeoutRequest.TimeoutLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(TimeoutLayer, ::IO, ::Request, body) -&gt; HTTP.Response</code></pre><p>Close <code>IO</code> if no data has been received for <code>timeout</code> seconds.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/TimeoutRequest.jl#L8-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.StreamRequest.StreamLayer" href="#HTTP.StreamRequest.StreamLayer"><code>HTTP.StreamRequest.StreamLayer</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">request(StreamLayer, ::IO, ::Request, body) -&gt; HTTP.Response</code></pre><p>Create a <a href="index.html#HTTP.Streams.Stream"><code>Stream</code></a> to send a <code>Request</code> and <code>body</code> to an <code>IO</code> stream and read the response.</p><p>Sens the <code>Request</code> body in a background task and begins reading the response immediately so that the transmission can be aborted if the <code>Response</code> status indicates that the server does not wish to receive the message body. <a href="https://tools.ietf.org/html/rfc7230#section-6.5">RFC7230 6.5</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/StreamRequest.jl#L13-L23">source</a></section><h2><a class="nav-anchor" id="Parser-1" href="#Parser-1">Parser</a></h2><p><em>Source: <code>Parsers.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.Parser" href="#HTTP.Parsers.Parser"><code>HTTP.Parsers.Parser</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The parser separates a raw HTTP Message into its component parts.</p><p>If the input data is invalid the Parser throws a <code>ParsingError</code>.</p><p>The parser processes a single HTTP Message. If the input stream contains multiple Messages the Parser stops at the end of the first Message. The <code>parseheaders</code> and <code>parsebody</code> functions return a <code>SubArray</code> containing the unuses portion of the input.</p><p>The Parser does not interpret the Message Headers except as needed to parse the Message Body. It is beyond the scope of the Parser to deal with repeated header fields, multi-line values, cookies or case normalization.</p><p>The Parser has no knowledge of the high-level <code>Request</code> and <code>Response</code> structs defined in <code>Messages.jl</code>. The Parser has it&#39;s own low level <a href="index.html#HTTP.Parsers.Message"><code>Message</code></a> struct that represents both Request and Response Messages.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L76-L94">source</a></section><h2><a class="nav-anchor" id="Messages-1" href="#Messages-1">Messages</a></h2><p><em>Source: <code>Messages.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages" href="#HTTP.Messages"><code>HTTP.Messages</code></a> — <span class="docstring-category">Module</span>.</div><div><p>The <code>Messages</code> module defines structs that represent <a href="index.html#HTTP.Messages.Request"><code>HTTP.Request</code></a> and <a href="index.html#HTTP.Messages.Response"><code>HTTP.Response</code></a> Messages.</p><p>The <code>Response</code> struct has a <code>request</code> field that points to the corresponding <code>Request</code>; and the <code>Request</code> struct has a <code>response</code> field. The <code>Request</code> struct also has a <code>parent</code> field that points to a <code>Response</code> in the case of HTTP Redirect.</p><p>The Messages module defines <code>IO</code> <code>read</code> and <code>write</code> methods for Messages but it does not deal with URIs, creating connections, or executing requests. The </p><p>The <code>read</code> methods throw <code>EOFError</code> exceptions if input data is incomplete. and call parser functions that may throw <code>HTTP.ParsingError</code> exceptions. The <code>read</code> and <code>write</code> methods may also result in low level <code>IO</code> exceptions.</p><p><strong>Sending Messages</strong></p><p>Messages are formatted and written to an <code>IO</code> stream by <a href="index.html#Base.write-Tuple{IO,HTTP.Messages.Message}"><code>Base.write(::IO,::HTTP.Messages.Message)</code></a> and or <a href="index.html#HTTP.Messages.writeheaders"><code>HTTP.Messages.writeheaders</code></a>.</p><p><strong>Receiving Messages</strong></p><p>Messages are parsed from <code>IO</code> stream data by <a href="index.html#HTTP.Messages.readheaders"><code>HTTP.Messages.readheaders</code></a>. This function calls <a href="index.html#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a> and <a href="index.html#HTTP.Messages.readstartline!"><code>HTTP.Messages.readstartline!</code></a>.</p><p>The <code>read</code> methods rely on <a href="index.html#HTTP.IOExtras.unread!"><code>HTTP.IOExtras.unread!</code></a> to push excess data back to the input stream.</p><p><strong>Headers</strong></p><p>Headers are represented by <code>Vector{Pair{String,String}}</code>. As compared to <code>Dict{String,String}</code> this allows <a href="https://tools.ietf.org/html/rfc7230#section-3.2.2">repeated header fields and preservation of order</a>.</p><p>Header values can be accessed by name using  <a href="index.html#HTTP.Messages.header"><code>HTTP.Messages.header</code></a> and <a href="index.html#HTTP.Messages.setheader"><code>HTTP.Messages.setheader</code></a> (case-insensitive).</p><p>The <a href="index.html#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a> function handles combining multi-line values, repeated header fields and special handling of multiple <code>Set-Cookie</code> headers.</p><p><strong>Bodies</strong></p><p>The <code>HTTP.Message</code> structs represent the Message Body as <code>Vector{UInt8}</code>.</p><p>Streaming of request and response bodies is handled by the <a href="index.html#HTTP.StreamRequest.StreamLayer"><code>HTTP.StreamLayer</code></a> and the <a href="index.html#HTTP.Streams.Stream"><code>HTTP.Stream</code></a> <code>&lt;: IO</code> stream.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L1-L58">source</a></section><h2><a class="nav-anchor" id="Streams-1" href="#Streams-1">Streams</a></h2><p><em>Source: <code>Streams.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Streams.Stream" href="#HTTP.Streams.Stream"><code>HTTP.Streams.Stream</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Stream(::IO, ::Request, ::Parser)</code></pre><p>Creates a <code>HTTP.Stream</code> that wraps an existing <code>IO</code> stream.</p><ul><li><p><code>startwrite(::Stream)</code> sends the <code>Request</code> headers to the <code>IO</code> stream.</p></li><li><p><code>write(::Stream, body)</code> sends the <code>body</code> (or a chunk of the bocdy).</p></li><li><p><code>closewrite(::Stream)</code> sends the final <code>0</code> chunk (if needed) and calls <code>closewrite</code> on the <code>IO</code> stream. When the <code>IO</code> stream is a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>, calling <code>closewrite</code> releases the <a href="index.html#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a> back into the pool for use by the next pipelined request.</p></li><li><p><code>startread(::Stream)</code> calls <code>startread</code> on the <code>IO</code> stream then  reads and parses the <code>Response</code> headers.  When the <code>IO</code> stream is a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>, calling <code>startread</code> waits for other pipelined responses to be read from the <a href="index.html#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a>.</p></li><li><p><code>eof(::Stream)</code> and <code>readavailable(::Stream)</code> parse the body from the <code>IO</code>  stream.</p></li><li><p><code>closeread(::Stream)</code> reads the trailers and calls <code>closeread</code> on the <code>IO</code>  stream.  When the <code>IO</code> stream is a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a>,  calling <code>closeread</code> releases the readlock and allows the next pipelined  response to be read by another <code>Stream</code> that is waiting in <code>startread</code>.  If the <code>Parser</code> has not recieved a complete response, <code>closeread</code> throws  an <code>EOFError</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Streams.jl#L23-L48">source</a></section><h2><a class="nav-anchor" id="Connections-1" href="#Connections-1">Connections</a></h2><p><em>Source: <code>ConnectionPool.jl</code></em></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool" href="#HTTP.ConnectionPool"><code>HTTP.ConnectionPool</code></a> — <span class="docstring-category">Module</span>.</div><div><p>This module provides the <a href="index.html#HTTP.ConnectionPool.getconnection"><code>getconnection</code></a> function with support for:</p><ul><li><p>Opening TCP and SSL connections.</p></li><li><p>Reusing connections for multiple Request/Response Messages,</p></li><li><p>Pipelining Request/Response Messages. i.e. allowing a new Request to be sent before previous Responses have been read.</p></li></ul><p>This module defines a <a href="index.html#HTTP.ConnectionPool.Connection"><code>Connection</code></a> struct to manage pipelining and connection reuse and a <a href="index.html#HTTP.ConnectionPool.Transaction"><code>Transaction</code></a><code>&lt;: IO</code> struct to manage a single pipelined request. Methods are provided for <code>eof</code>, <code>readavailable</code>, <code>unsafe_write</code> and <code>close</code>. This allows the <code>Transaction</code> object to act as a proxy for the <code>TCPSocket</code> or <code>SSLContext</code> that it wraps.</p><p>The <a href="index.html#HTTP.ConnectionPool.pool"><code>pool</code></a> is a collection of open <code>Connection</code>s.  The <code>request</code> function calls <code>getconnection</code> to retrieve a connection from the <code>pool</code>.  When the <code>request</code> function has written a Request Message it calls <code>closewrite</code> to signal that the <code>Connection</code> can be reused for writing (to send the next Request). When the <code>request</code> function has read the Response Message it calls <code>closeread</code> to signal that the <code>Connection</code> can be reused for reading.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L1-L24">source</a></section><h1><a class="nav-anchor" id="Internal-Interfaces-1" href="#Internal-Interfaces-1">Internal Interfaces</a></h1><h2><a class="nav-anchor" id="Parser-Interface-1" href="#Parser-Interface-1">Parser Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.Message" href="#HTTP.Parsers.Message"><code>HTTP.Parsers.Message</code></a> — <span class="docstring-category">Type</span>.</div><div><ul><li><p><code>method::Method</code>: internal parser <code>@enum</code> for HTTP method.</p></li><li><p><code>major</code> and <code>minor</code>: HTTP version</p></li><li><p><code>url::String</code>: request URL</p></li><li><p><code>status::Int</code>: response status</p></li><li><p><code>upgrade::Bool</code>: Connection should be upgraded to a different protocol.                  e.g. <code>CONNECT</code> or <code>Connection: upgrade</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L55-L62">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.Parser-Tuple{}" href="#HTTP.Parsers.Parser-Tuple{}"><code>HTTP.Parsers.Parser</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">Parser()</code></pre><p>Create an unconfigured <code>Parser</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L115-L119">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.parseheaders" href="#HTTP.Parsers.parseheaders"><code>HTTP.Parsers.parseheaders</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">parseheaders(::Parser, bytes) do h::Pair{String,String} ... -&gt; excess</code></pre><p>Read headers from <code>bytes</code>, passing each field/value pair to <code>f</code>. Returns a <code>SubArray</code> containing bytes not parsed.</p><p>e.g.</p><pre><code class="language-none">excess = parseheaders(p, bytes) do (k,v)
    println(&quot;$k: $v&quot;)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L296-L308">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.parsebody" href="#HTTP.Parsers.parsebody"><code>HTTP.Parsers.parsebody</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">parsebody(::Parser, bytes) -&gt; data, excess</code></pre><p>Parse body data from <code>bytes</code>. Returns decoded <code>data</code> and <code>excess</code> bytes not parsed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L1136-L1141">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.reset!" href="#HTTP.Parsers.reset!"><code>HTTP.Parsers.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">reset!(::Parser)</code></pre><p>Revert <code>Parser</code> to unconfigured state.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L126-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.messagestarted" href="#HTTP.Parsers.messagestarted"><code>HTTP.Parsers.messagestarted</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">messagestarted(::Parser)</code></pre><p>Has the <code>Parser</code> begun processng a Message?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L166-L170">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.headerscomplete" href="#HTTP.Parsers.headerscomplete"><code>HTTP.Parsers.headerscomplete</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">headerscomplete(::Parser)</code></pre><p>Has the <code>Parser</code> processed the entire Message Header?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L175-L179">source</a><div><pre><code class="language-none">headerscomplete(::Message)</code></pre><p>Have the headers been read into this <code>Message</code>?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L395-L399">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.bodycomplete" href="#HTTP.Parsers.bodycomplete"><code>HTTP.Parsers.bodycomplete</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bodycomplete(::Parser)</code></pre><p>Has the <code>Parser</code> processed the Message Body?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L184-L188">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.messagecomplete" href="#HTTP.Parsers.messagecomplete"><code>HTTP.Parsers.messagecomplete</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">messagecomplete(::Parser)</code></pre><p>Has the <code>Parser</code> processed the entire Message?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L194-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.messagehastrailing" href="#HTTP.Parsers.messagehastrailing"><code>HTTP.Parsers.messagehastrailing</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">messagehastrailing(::Parser)</code></pre><p>Is the <code>Parser</code> ready to process trailing headers?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L224-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.waitingforeof" href="#HTTP.Parsers.waitingforeof"><code>HTTP.Parsers.waitingforeof</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">waitingforeof(::Parser)</code></pre><p>Is the <code>Parser</code> waiting for the peer to close the connection to signal the end of the Message Body?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L203-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.seteof" href="#HTTP.Parsers.seteof"><code>HTTP.Parsers.seteof</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">seteof(::Parser)</code></pre><p>Signal that the peer has closed the connection.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L212-L216">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.connectionclosed" href="#HTTP.Parsers.connectionclosed"><code>HTTP.Parsers.connectionclosed</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">connectionclosed(::Parser)</code></pre><p>Was &quot;Connection: close&quot; parsed?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L232-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.setnobody" href="#HTTP.Parsers.setnobody"><code>HTTP.Parsers.setnobody</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setnobody(::Parser)</code></pre><p>Tell the <code>Parser</code> not to look for a Message Body. e.g. for the Response to a HEAD Request.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/parser.jl#L156-L161">source</a></section><h2><a class="nav-anchor" id="Messages-Interface-1" href="#Messages-Interface-1">Messages Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.Request" href="#HTTP.Messages.Request"><code>HTTP.Messages.Request</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Request &lt;: Message</code></pre><p>Represents a HTTP Request Message.</p><ul><li><p><code>method::String</code></p></li><li><p><code>uri::String</code></p></li><li><p><code>version::VersionNumber</code></p></li><li><p><code>headers::Vector{Pair{String,String}}</code></p></li><li><p><code>body::Vector{UInt8}</code></p></li><li><p><code>response</code>, the <code>Response</code> to this <code>Request</code></p></li><li><p><code>parent</code>, the <code>Response</code> (if any) that led to this request (e.g. in the case of a redirect).</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L121-L134">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.Response" href="#HTTP.Messages.Response"><code>HTTP.Messages.Response</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Response &lt;: Message</code></pre><p>Represents a HTTP Response Message.</p><ul><li><p><code>version::VersionNumber</code></p></li><li><p><code>status::Int16</code></p></li><li><p><code>headers::Vector{Pair{String,String}}</code></p></li><li><p><code>body::Vector{UInt8}</code></p></li><li><p><code>request</code>, the <code>Request</code> that yielded this <code>Response</code>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L84-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.iserror" href="#HTTP.Messages.iserror"><code>HTTP.Messages.iserror</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">iserror(::Response)</code></pre><p>Does this <code>Response</code> have an error status?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L183-L187">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.isredirect" href="#HTTP.Messages.isredirect"><code>HTTP.Messages.isredirect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isredirect(::Response)</code></pre><p>Does this <code>Response</code> have a redirect status?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L193-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.ischunked" href="#HTTP.Messages.ischunked"><code>HTTP.Messages.ischunked</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ischunked(::Message)</code></pre><p>Does the <code>Message</code> have a &quot;Transfer-Encoding: chunked&quot; header?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L251-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.issafe" href="#HTTP.Messages.issafe"><code>HTTP.Messages.issafe</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">issafe(::Request)</code></pre><p>https://tools.ietf.org/html/rfc7231#section-4.2.1</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L165-L169">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.isidempotent" href="#HTTP.Messages.isidempotent"><code>HTTP.Messages.isidempotent</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isidempotent(::Request)</code></pre><p>https://tools.ietf.org/html/rfc7231#section-4.2.2</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L174-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.header" href="#HTTP.Messages.header"><code>HTTP.Messages.header</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">header(::Message, key [, default=&quot;&quot;]) -&gt; String</code></pre><p>Get header value for <code>key</code> (case-insensitive).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L210-L214">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.hasheader" href="#HTTP.Messages.hasheader"><code>HTTP.Messages.hasheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hasheader(::Message, key) -&gt; Bool</code></pre><p>Does header value for <code>key</code> exist (case-insensitive)?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L220-L224">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.setheader" href="#HTTP.Messages.setheader"><code>HTTP.Messages.setheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">setheader(::Message, key =&gt; value)</code></pre><p>Set header <code>value</code> for <code>key</code> (case-insensitive).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L228-L232">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.defaultheader" href="#HTTP.Messages.defaultheader"><code>HTTP.Messages.defaultheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">defaultheader(::Message, key =&gt; value)</code></pre><p>Set header <code>value</code> for <code>key</code> if it is not already set.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L237-L241">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.appendheader" href="#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">appendheader(::Message, key =&gt; value)</code></pre><p>Append a header value to <code>message.headers</code>.</p><p>If <code>key</code> is <code>&quot;&quot;</code> the <code>value</code> is appended to the value of the previous header.</p><p>If <code>key</code> is the same as the previous header, the <code>vale</code> is <a href="https://stackoverflow.com/a/24502264">appended to the value of the previous header with a comma delimiter</a></p><p><code>Set-Cookie</code> headers are not comma-combined because <a href="https://tools.ietf.org/html/rfc6265#section-3">cookies often contain internal commas</a>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L260-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.readheaders" href="#HTTP.Messages.readheaders"><code>HTTP.Messages.readheaders</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readheaders(::IO, ::Parser, ::Message)</code></pre><p>Read headers (and startline) from an <code>IO</code> stream into a <code>Message</code> struct. Throw <code>EOFError</code> if input is incomplete.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L372-L377">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.readstartline!" href="#HTTP.Messages.readstartline!"><code>HTTP.Messages.readstartline!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readstartline!(::Parsers.Message, ::Message)</code></pre><p>Read the start-line metadata from Parser into a <code>::Message</code> struct.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L352-L356">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Parsers.headerscomplete-Tuple{HTTP.Messages.Response}" href="#HTTP.Parsers.headerscomplete-Tuple{HTTP.Messages.Response}"><code>HTTP.Parsers.headerscomplete</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">headerscomplete(::Message)</code></pre><p>Have the headers been read into this <code>Message</code>?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L395-L399">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.readtrailers" href="#HTTP.Messages.readtrailers"><code>HTTP.Messages.readtrailers</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">readtrailers(::IO, ::Parser, ::Message)</code></pre><p>Read trailers from an <code>IO</code> stream into a <code>Message</code> struct.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L405-L409">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.writestartline" href="#HTTP.Messages.writestartline"><code>HTTP.Messages.writestartline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writestartline(::IO, ::Message)</code></pre><p>e.g. <code>&quot;GET /path HTTP/1.1\r\n&quot;</code> or <code>&quot;HTTP/1.1 200 OK\r\n&quot;</code></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L298-L302">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Messages.writeheaders" href="#HTTP.Messages.writeheaders"><code>HTTP.Messages.writeheaders</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">writeheaders(::IO, ::Message)</code></pre><p>Write <code>Message</code> start line and a line for each &quot;name: value&quot; pair and a trailing blank line.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L315-L320">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.write-Tuple{IO,HTTP.Messages.Message}" href="#Base.write-Tuple{IO,HTTP.Messages.Message}"><code>Base.write</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">write(::IO, ::Message)</code></pre><p>Write start line, headers and body of HTTP Message.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Messages.jl#L332-L336">source</a></section><h2><a class="nav-anchor" id="IOExtras-Interface-1" href="#IOExtras-Interface-1">IOExtras Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras" href="#HTTP.IOExtras"><code>HTTP.IOExtras</code></a> — <span class="docstring-category">Module</span>.</div><div><p>This module defines extensions to the <code>Base.IO</code> interface to support:</p><ul><li><p>an <code>unread!</code> function for pushing excess bytes back into a stream,</p></li><li><p><code>startwrite</code>, <code>closewrite</code>, <code>startread</code> and <code>closeread</code> for streams  with transactional semantics.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/IOExtras.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.unread!" href="#HTTP.IOExtras.unread!"><code>HTTP.IOExtras.unread!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">unread!(::IO, bytes)</code></pre><p>Push bytes back into a connection (to be returned by the next read).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/IOExtras.jl#L41-L45">source</a><div><pre><code class="language-none">unread!(::Transaction, bytes)</code></pre><p>Push bytes back into a connection&#39;s <code>excess</code> buffer (to be returned by the next read).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L177-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.startwrite-Tuple{IO}" href="#HTTP.IOExtras.startwrite-Tuple{IO}"><code>HTTP.IOExtras.startwrite</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">startwrite(::IO)
closewrite(::IO)
startread(::IO)
closeread(::IO)</code></pre><p>Signal start/end of write or read operations.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/IOExtras.jl#L58-L65">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.isioerror" href="#HTTP.IOExtras.isioerror"><code>HTTP.IOExtras.isioerror</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isioerror(exception)</code></pre><p>Is <code>exception</code> caused by a possibly recoverable IO error.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/IOExtras.jl#L15-L19">source</a></section><h2><a class="nav-anchor" id="Streams-Interface-1" href="#Streams-Interface-1">Streams Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Streams.closebody" href="#HTTP.Streams.closebody"><code>HTTP.Streams.closebody</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">closebody(::Stream)</code></pre><p>Write the final <code>0</code> chunk if needed.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Streams.jl#L80-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.Streams.isaborted" href="#HTTP.Streams.isaborted"><code>HTTP.Streams.isaborted</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">isaborted(::Stream{Response})</code></pre><p>Has the server signalled that it does not wish to receive the message body?</p><p>&quot;If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.&quot; <a href="https://tools.ietf.org/html/rfc7230#section-6.5">RFC7230, 6.5</a></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/Streams.jl#L174-L183">source</a></section><h2><a class="nav-anchor" id="Connection-Pooling-Interface-1" href="#Connection-Pooling-Interface-1">Connection Pooling Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.Connection" href="#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Connection{T &lt;: IO}</code></pre><p>A <code>TCPSocket</code> or <code>SSLContext</code> connection to a HTTP <code>host</code> and <code>port</code>.</p><p>Fields:</p><ul><li><p><code>host::String</code></p></li><li><p><code>port::String</code>, exactly as specified in the URI (i.e. may be empty).</p></li><li><p><code>pipeline_linit</code>, number of requests to send before waiting for responses.</p></li><li><p><code>peerport</code>, remote TCP port number (used for debug messages).</p></li><li><p><code>localport</code>, local TCP port number (used for debug messages). </p></li><li><p><code>io::T</code>, the <code>TCPSocket</code> or `SSLContext.</p></li><li><p><code>excess::ByteView</code>, left over bytes read from the connection after  the end of a response message. These bytes are probably the start of the  next response message.</p></li><li><p><code>writebusy</code>, is a <code>Transaction</code> busy writing to this <code>Connection</code> ?</p></li><li><p><code>writecount</code>, number of Request Messages that have been written.</p></li><li><p><code>readcount</code>, number of Response Messages that have been read.</p></li><li><p><code>writelock</code>, busy writing a Request to <code>io</code>.</p></li><li><p><code>readlock</code>, busy reading a Response from <code>io</code>.</p></li><li><p>`timestamp, time data was last recieved.</p></li><li><p><code>parser::Parser</code>, reuse a <code>Parser</code> when this <code>Connection</code> is reused.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L54-L76">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.Transaction" href="#HTTP.ConnectionPool.Transaction"><code>HTTP.ConnectionPool.Transaction</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A single pipelined HTTP Request/Response transaction`.</p><p>Fields:</p><ul><li><p><code>c</code>, the shared <a href="index.html#HTTP.ConnectionPool.Connection"><code>Connection</code></a> used for this <code>Transaction</code>.</p></li><li><p><code>sequence::Int</code>, identifies this <code>Transaction</code> among the others that share <code>c</code>. </p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L95-L101">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.pool" href="#HTTP.ConnectionPool.pool"><code>HTTP.ConnectionPool.pool</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>The <code>pool</code> is a collection of open <code>Connection</code>s.  The <code>request</code> function calls <code>getconnection</code> to retrieve a connection from the <code>pool</code>.  When the <code>request</code> function has written a Request Message it calls <code>closewrite</code> to signal that the <code>Connection</code> can be reused for writing (to send the next Request). When the <code>request</code> function has read the Response Message it calls <code>closeread</code> to signal that the <code>Connection</code> can be reused for reading.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L303-L311">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.ConnectionPool.getconnection" href="#HTTP.ConnectionPool.getconnection"><code>HTTP.ConnectionPool.getconnection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getconnection(type, host, port) -&gt; Connection</code></pre><p>Find a reusable <code>Connection</code> in the <code>pool</code>, or create a new <code>Connection</code> if required.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L412-L417">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.unread!-Tuple{HTTP.ConnectionPool.Transaction,SubArray{UInt8,1,Array{UInt8,1},Tuple{UnitRange{Int64}},true}}" href="#HTTP.IOExtras.unread!-Tuple{HTTP.ConnectionPool.Transaction,SubArray{UInt8,1,Array{UInt8,1},Tuple{UnitRange{Int64}},true}}"><code>HTTP.IOExtras.unread!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">unread!(::Transaction, bytes)</code></pre><p>Push bytes back into a connection&#39;s <code>excess</code> buffer (to be returned by the next read).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L177-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.startwrite-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.startwrite-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.startwrite</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">startwrite(::Transaction)</code></pre><p>Set <code>writebusy</code>. Should only be called by the <code>Transaction</code> constructor because <code>getconnection</code> only creates new <code>Transaction</code>s when a <code>Connection</code> is available for writing.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L191-L198">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.closewrite-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.closewrite-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.closewrite</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">closewrite(::Transaction)</code></pre><p>Signal that an entire Request Message has been written to the <code>Transaction</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L207-L211">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.startread-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.startread-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.startread</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">startread(::Transaction)</code></pre><p>Wait for prior pending reads to complete, then lock the readlock.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L225-L229">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HTTP.IOExtras.closeread-Tuple{HTTP.ConnectionPool.Transaction}" href="#HTTP.IOExtras.closeread-Tuple{HTTP.ConnectionPool.Transaction}"><code>HTTP.IOExtras.closeread</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">closeread(::Transaction)</code></pre><p>Signal that an entire Response Message has been read from the <code>Transaction</code>.</p><p>Increment <code>readcount</code> and wake up tasks waiting in <code>startread</code> by unlocking <code>readlock</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/d978173611a93aa73270668fc48efa2602ecaa94/src/ConnectionPool.jl#L246-L253">source</a></section><footer><hr/></footer></article></body></html>
