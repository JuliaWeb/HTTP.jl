<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public Interface · HTTP.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">HTTP.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Public Interface</a><ul class="internal"><li><a class="tocitem" href="#Requests"><span>Requests</span></a></li><li><a class="tocitem" href="#URIs"><span>URIs</span></a></li><li><a class="tocitem" href="#Cookies"><span>Cookies</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Server-/-Handlers"><span>Server / Handlers</span></a></li></ul></li><li><a class="tocitem" href="../internal_architecture/">Internal Architecture</a></li><li><a class="tocitem" href="../internal_interface/">Internal Interfaces</a></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public Interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public Interface</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaWeb/HTTP.jl/blob/master/docs/src/public_interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Interface"><a class="docs-heading-anchor" href="#Public-Interface">Public Interface</a><a id="Public-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Interface" title="Permalink"></a></h1><h2 id="Requests"><a class="docs-heading-anchor" href="#Requests">Requests</a><a id="Requests-1"></a><a class="docs-heading-anchor-permalink" href="#Requests" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HTTP.request" href="#HTTP.request"><code>HTTP.request</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.request(method, url [, headers [, body]]; &lt;keyword arguments&gt;]) -&gt; HTTP.Response</code></pre><p>Send a HTTP Request Message and receive a HTTP Response Message.</p><p>e.g.</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;)
println(r.status)
println(String(r.body))</code></pre><p><code>headers</code> can be any collection where <code>[string(k) =&gt; string(v) for (k,v) in headers]</code> yields <code>Vector{Pair}</code>. e.g. a <code>Dict()</code>, a <code>Vector{Tuple}</code>, a <code>Vector{Pair}</code> or an iterator.</p><p><code>body</code> can take a number of forms:</p><ul><li>a <code>String</code>, a <code>Vector{UInt8}</code> or any <code>T</code> accepted by <code>write(::IO, ::T)</code></li><li>a collection of <code>String</code> or <code>AbstractVector{UInt8}</code> or <code>IO</code> streams or items of any type <code>T</code> accepted by <code>write(::IO, ::T...)</code></li><li>a readable <code>IO</code> stream or any <code>IO</code>-like type <code>T</code> for which <code>eof(T)</code> and <code>readavailable(T)</code> are defined.</li></ul><p>The <code>HTTP.Response</code> struct contains:</p><ul><li><code>status::Int16</code> e.g. <code>200</code></li><li><code>headers::Vector{Pair{String,String}}</code>  e.g. [&quot;Server&quot; =&gt; &quot;Apache&quot;, &quot;Content-Type&quot; =&gt; &quot;text/html&quot;]</li><li><code>body::Vector{UInt8}</code>, the Response Body bytes  (empty if a <code>response_stream</code> was specified in the <code>request</code>).</li></ul><p>Functions <code>HTTP.get</code>, <code>HTTP.put</code>, <code>HTTP.post</code> and <code>HTTP.head</code> are defined as shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>, etc.</p><p><code>HTTP.request</code> and <code>HTTP.open</code> also accept optional keyword parameters.</p><p>e.g.</p><pre><code class="language-julia">HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;; retries=4, cookies=true)

HTTP.get(&quot;http://s3.us-east-1.amazonaws.com/&quot;; aws_authorization=true)

conf = (readtimeout = 10,
        pipeline_limit = 4,
        retry = false,
        redirect = false)

HTTP.get(&quot;http://httpbin.org/ip&quot;; conf..)
HTTP.put(&quot;http://httpbin.org/put&quot;, [], &quot;Hello&quot;; conf..)</code></pre><p>URL options</p><ul><li><code>query = nothing</code>, replaces the query part of <code>url</code>.</li></ul><p>Streaming options</p><ul><li><code>response_stream = nothing</code>, a writeable <code>IO</code> stream or any <code>IO</code>-like  type <code>T</code> for which <code>write(T, AbstractVector{UInt8})</code> is defined.</li><li><code>verbose = 0</code>, set to <code>1</code> or <code>2</code> for extra message logging.</li></ul><p>Connection Pool options</p><ul><li><code>connect_timeout = 0</code>, close the connection after this many seconds if it is still attempting to connect. Use <code>connect_timeout = 0</code> to disable.</li><li><code>connection_limit = 8</code>, number of concurrent connections to each host:port.</li><li><code>pipeline_limit = 16</code>, number of concurrent requests per connection.</li><li><code>reuse_limit = nolimit</code>, number of times a connection is reused after the                          first request.</li><li><code>socket_type = TCPSocket</code></li></ul><p>Timeout options</p><ul><li><code>readtimeout = 0</code>, close the connection if no data is received for this many seconds. Use <code>readtimeout = 0</code> to disable.</li></ul><p>Retry options</p><ul><li><code>retry = true</code>, retry idempotent requests in case of error.</li><li><code>retries = 4</code>, number of times to retry.</li><li><code>retry_non_idempotent = false</code>, retry non-idempotent requests too. e.g. POST.</li></ul><p>Redirect options</p><ul><li><code>redirect = true</code>, follow 3xx redirect responses.</li><li><code>redirect_limit = 3</code>, number of times to redirect.</li><li><code>forwardheaders = true</code>, forward original headers on redirect.</li></ul><p>Status Exception options</p><ul><li><code>status_exception = true</code>, throw <code>HTTP.StatusError</code> for response status &gt;= 300.</li></ul><p>SSLContext options</p><ul><li><code>require_ssl_verification = NetworkOptions.verify_host(host)</code>, pass <code>MBEDTLS_SSL_VERIFY_REQUIRED</code> to the mbed TLS library. <a href="https://tls.mbed.org/api/ssl_8h.html#a5695285c9dbfefec295012b566290f37">&quot;... peer must present a valid certificate, handshake is aborted if   verification failed.&quot;</a></li><li><code>sslconfig = SSLConfig(require_ssl_verification)</code></li></ul><p>Basic Authentication options</p><ul><li>Basic authentication is detected automatically from the provided url&#39;s <code>userinfo</code> (in the form <code>scheme://user:password@host</code>) and adds the <code>Authorization: Basic</code> header</li></ul><p>AWS Authentication options</p><ul><li><code>aws_authorization = false</code>, enable AWS4 Authentication.</li><li><code>aws_service = split(url.host, &quot;.&quot;)[1]</code></li><li><code>aws_region = split(url.host, &quot;.&quot;)[2]</code></li><li><code>aws_access_key_id = ENV[&quot;AWS_ACCESS_KEY_ID&quot;]</code></li><li><code>aws_secret_access_key = ENV[&quot;AWS_SECRET_ACCESS_KEY&quot;]</code></li><li><code>aws_session_token = get(ENV, &quot;AWS_SESSION_TOKEN&quot;, &quot;&quot;)</code></li><li><code>body_sha256 = digest(MD_SHA256, body)</code>,</li><li><code>body_md5 = digest(MD_MD5, body)</code>,</li></ul><p>Cookie options</p><ul><li><code>cookies::Union{Bool, Dict{&lt;:AbstractString, &lt;:AbstractString}} = false</code>, enable cookies, or alternatively,      pass a <code>Dict{AbstractString, AbstractString}</code> of name-value pairs to manually pass cookies</li><li><code>cookiejar::Dict{String, Set{Cookie}}=default_cookiejar</code>,</li></ul><p>Canonicalization options</p><ul><li><code>canonicalize_headers = false</code>, rewrite request and response headers in Canonical-Camel-Dash-Format.</li></ul><p>Proxy options</p><ul><li><code>proxy = proxyurl</code>, pass request through a proxy given as a url</li></ul><p>Alternatively, HTTP.jl also respects the <code>http_proxy</code>, <code>HTTP_PROXY</code>, <code>https_proxy</code>, <code>HTTPS_PROXY</code>, and <code>no_proxy</code> environment variables; if set, they will be used automatically when making requests.</p><p><strong>Request Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)</code></pre><p>Stream body from file:</p><pre><code class="language-julia">io = open(&quot;post_data.txt&quot;, &quot;r&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], io)</code></pre><p>Generator body:</p><pre><code class="language-julia">chunks = (&quot;chunk$i&quot; for i in 1:1000)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p>Collection body:</p><pre><code class="language-julia">chunks = [preamble_chunk, data_chunk, checksum(data_chunk)]
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p><code>open() do io</code> body:</p><pre><code class="language-julia">HTTP.open(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;) do io
    write(io, preamble_chunk)
    write(io, data_chunk)
    write(io, checksum(data_chunk))
end</code></pre><p><strong>Response Body Examples</strong></p><p>String body:</p><pre><code class="language-julia">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;)
println(String(r.body))</code></pre><p>Stream body to file:</p><pre><code class="language-julia">io = open(&quot;get_data.txt&quot;, &quot;w&quot;)
r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)
println(read(&quot;get_data.txt&quot;))</code></pre><p>Stream body through buffer:</p><pre><code class="language-julia">io = Base.BufferStream()
@async while !eof(io)
    bytes = readavailable(io)
    println(&quot;GET data: $bytes&quot;)
end
r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)</code></pre><p>Stream body through <code>open() do io</code>:</p><pre><code class="language-julia">r = HTTP.open(&quot;GET&quot;, &quot;http://httpbin.org/stream/10&quot;) do io
   while !eof(io)
       println(String(readavailable(io)))
   end
end

using HTTP.IOExtras

HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    n = 0
    r = startread(http)
    l = parse(Int, HTTP.header(r, &quot;Content-Length&quot;))
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        while !eof(http)
            bytes = readavailable(http)
            write(vlc, bytes)
            n += length(bytes)
            println(&quot;streamed $n-bytes $((100*n)÷l)%\u1b[1A&quot;)
        end
    end
end</code></pre><p><strong>Request and Response Body Examples</strong></p><p>String bodies:</p><pre><code class="language-julia">r = HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)
println(String(r.body))</code></pre><p>Interfacing with RESTful JSON APIs:</p><pre><code class="language-julia">using JSON
params = Dict(&quot;user&quot;=&gt;&quot;RAO...tjN&quot;, &quot;token&quot;=&gt;&quot;NzU...Wnp&quot;, &quot;message&quot;=&gt;&quot;Hello!&quot;)
base_url = &quot;http://api.domain.com&quot;
endpoint = &quot;/1/messages.json&quot;
url = base_url * endpoint
r = HTTP.request(&quot;POST&quot;, url,
             [&quot;Content-Type&quot; =&gt; &quot;application/json&quot;],
             JSON.json(params))
println(JSON.parse(String(r.body)))</code></pre><p>Stream bodies from and to files:</p><pre><code class="language-julia">in = open(&quot;foo.png&quot;, &quot;r&quot;)
out = open(&quot;foo.jpg&quot;, &quot;w&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://convert.com/png2jpg&quot;, [], in, response_stream=out)</code></pre><p>Stream bodies through: <code>open() do io</code>:</p><pre><code class="language-julia">using HTTP.IOExtras

HTTP.open(&quot;POST&quot;, &quot;http://music.com/play&quot;) do io
    write(io, JSON.json([
        &quot;auth&quot; =&gt; &quot;12345XXXX&quot;,
        &quot;song_id&quot; =&gt; 7,
    ]))
    r = startread(io)
    @show r.status
    while !eof(io)
        bytes = readavailable(io)
        play_audio(bytes)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/HTTP.jl#L32-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.open" href="#HTTP.open"><code>HTTP.open</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.open(method, url, [,headers]) do io
    write(io, body)
    [startread(io) -&gt; HTTP.Response]
    while !eof(io)
        readavailable(io) -&gt; AbstractVector{UInt8}
    end
end -&gt; HTTP.Response</code></pre><p>The <code>HTTP.open</code> API allows the Request Body to be written to (and/or the Response Body to be read from) an <code>IO</code> stream.</p><p>e.g. Streaming an audio file to the <code>vlc</code> player:</p><pre><code class="language-julia">HTTP.open(:GET, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        write(vlc, http)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/HTTP.jl#L327-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.get" href="#HTTP.get"><code>HTTP.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.get(url [, headers]; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/HTTP.jl#L387-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.put" href="#HTTP.put"><code>HTTP.put</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.put(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;PUT&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/HTTP.jl#L394-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.post" href="#HTTP.post"><code>HTTP.post</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.post(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;POST&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/HTTP.jl#L401-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.head" href="#HTTP.head"><code>HTTP.head</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.head(url; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;HEAD&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/HTTP.jl#L415-L419">source</a></section></article><h3 id="Request-body-types"><a class="docs-heading-anchor" href="#Request-body-types">Request body types</a><a id="Request-body-types-1"></a><a class="docs-heading-anchor-permalink" href="#Request-body-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Form" href="#HTTP.Form"><code>HTTP.Form</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Form(data; boundary=string(rand(UInt128), base=16))</code></pre><p>Construct a request body for multipart/form-data encoding from <code>data</code>.</p><p><code>data</code> must iterate key-value pairs (e.g. <code>Dict</code> or <code>Vector{Pair}</code>) where the key/value of the iterator is the key/value of each mutipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an <code>IOStream</code> such as returned via <code>open(file)</code>, or an <code>IOBuffer</code> for in-memory data.</p><p>For complete control over a multipart chunk&#39;s details, an <a href="#HTTP.Multipart"><code>HTTP.Multipart</code></a> type is provided to support setting the <code>filename</code>, <code>Content-Type</code>, and <code>Content-Transfer-Encoding</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">data = Dict(
    &quot;text&quot; =&gt; &quot;text data&quot;,
    # filename (cat.png) and content-type (image/png) inferred from the IOStream
    &quot;file1&quot; =&gt; open(&quot;cat.png&quot;),
    # manully controlled chunk
    &quot;file2&quot; =&gt; HTTP.Multipart(&quot;dog.jpeg&quot;, open(&quot;mydog.jpg&quot;), &quot;image/jpeg&quot;),
)
body = HTTP.Form(data)
headers = []
HTTP.post(url, headers, body)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/multipart.jl#L47-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Multipart" href="#HTTP.Multipart"><code>HTTP.Multipart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Multipart(filename::String, data::IO, content_type=HTTP.sniff(data), content_transfer_encoding=&quot;&quot;)</code></pre><p>A type to represent a single multipart upload chunk for a file. This type would be used as the value in a key-value pair when constructing a <a href="#HTTP.Form"><code>HTTP.Form</code></a> for a request body (see example below). The <code>data</code> argument must be an <code>IO</code> type such as <code>IOStream</code>, or <code>IOBuffer</code>. The <code>content_type</code> and <code>content_transfer_encoding</code> arguments allow manual setting of these multipart headers. <code>Content-Type</code> will default to the result of the <code>HTTP.sniff(data)</code> mimetype detection algorithm, whereas <code>Content-Transfer-Encoding</code> will be left out if not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia">body = HTTP.Form(Dict(
    &quot;key&quot; =&gt; HTTP.Multipart(&quot;File.txt&quot;, open(&quot;MyFile.txt&quot;), &quot;text/plain&quot;),
))
headers = []
HTTP.post(url, headers, body)</code></pre><p><strong>Extended help</strong></p><p>Filename SHOULD be included when the Multipart represents the contents of a file <a href="https://tools.ietf.org/html/rfc7578#section-4.2">RFC7578 4.2</a></p><p>Content-Disposition set to &quot;form-data&quot; MUST be included with each Multipart. An additional &quot;name&quot; parameter MUST be included An optional &quot;filename&quot; parameter SHOULD be included if the contents of a file are sent This will be formatted such as:   Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;myfile.txt&quot; <a href="https://tools.ietf.org/html/rfc7578#section-4.2">RFC7578 4.2</a></p><p>Content-Type for each Multipart is optional, but SHOULD be included if the contents of a file are sent. <a href="https://tools.ietf.org/html/rfc7578#section-4.4">RFC7578 4.4</a></p><p>Content-Transfer-Encoding for each Multipart is deprecated <a href="https://tools.ietf.org/html/rfc7578#section-4.7">RFC7578 4.7</a></p><p>Other Content- header fields MUST be ignored <a href="https://tools.ietf.org/html/rfc7578#section-4.8">RFC7578 4.8</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/multipart.jl#L114-L154">source</a></section></article><h3 id="Request-exceptions"><a class="docs-heading-anchor" href="#Request-exceptions">Request exceptions</a><a id="Request-exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Request-exceptions" title="Permalink"></a></h3><p>Request functions may throw the following exceptions:</p><article class="docstring"><header><a class="docstring-binding" id="HTTP.ExceptionRequest.StatusError" href="#HTTP.ExceptionRequest.StatusError"><code>HTTP.ExceptionRequest.StatusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StatusError &lt;: Exception</code></pre><p>The <code>Response</code> has a <code>4xx</code>, <code>5xx</code> or unrecognised status code.</p><p>Fields:</p><ul><li><code>status::Int16</code>, the response status code.</li><li><code>response</code> the <a href="../internal_interface/#HTTP.Messages.Response"><code>HTTP.Response</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/ExceptionRequest.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.ParseError" href="#HTTP.Parsers.ParseError"><code>HTTP.Parsers.ParseError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParseError &lt;: Exception</code></pre><p>Parser input was invalid.</p><p>Fields:</p><ul><li><code>code</code>, error code</li><li><code>bytes</code>, the offending input.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Parsers.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.IOExtras.IOError" href="#HTTP.IOExtras.IOError"><code>HTTP.IOExtras.IOError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IOError &lt;: Exception</code></pre><p>The request terminated with due to an IO-related error.</p><p>Fields:</p><ul><li><code>e</code>, the error.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/IOExtras.jl#L45-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Sockets.DNSError" href="#Sockets.DNSError"><code>Sockets.DNSError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DNSError</code></pre><p>The type of exception thrown when an error occurs in DNS lookup. The <code>host</code> field indicates the host URL string. The <code>code</code> field indicates the error code based on libuv.</p></div></section></article><h2 id="URIs"><a class="docs-heading-anchor" href="#URIs">URIs</a><a id="URIs-1"></a><a class="docs-heading-anchor-permalink" href="#URIs" title="Permalink"></a></h2><p>HTTP.jl uses the <a href="https://github.com/JuliaWeb/URIs.jl">URIs.jl</a> package for handling URIs. Some functionality from URIs.jl, relevant to HTTP.jl, are listed below:</p><article class="docstring"><header><a class="docstring-binding" id="URIs.URI" href="#URIs.URI"><code>URIs.URI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">URI(; scheme=&quot;&quot;, host=&quot;&quot;, port=&quot;&quot;, etc...)
URI(str) = parse(URI, str::String)</code></pre><p>A type representing a URI (e.g. a URL). Can be constructed from distinct parts using the various supported keyword arguments, or from a string. The <code>URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>When constructing a <code>URI</code> from a <code>String</code>, you need to first unescape that string: <code>URI( URIs.unescapeuri(str) )</code>.</p><p>The <code>URI</code> struct stores the complete URI in the <code>uri::String</code> field and the component parts in the following <code>SubString</code> fields:</p><ul><li><code>scheme</code>, e.g. <code>&quot;http&quot;</code> or <code>&quot;https&quot;</code></li><li><code>userinfo</code>, e.g. <code>&quot;username:password&quot;</code></li><li><code>host</code> e.g. <code>&quot;julialang.org&quot;</code></li><li><code>port</code> e.g. <code>&quot;80&quot;</code> or <code>&quot;&quot;</code></li><li><code>path</code> e.g <code>&quot;/&quot;</code></li><li><code>query</code> e.g. <code>&quot;Foo=1&amp;Bar=2&quot;</code></li><li><code>fragment</code></li></ul><p>The <code>queryparams(::URI)</code> function returns a <code>Dict</code> containing the <code>query</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="URIs.escapeuri" href="#URIs.escapeuri"><code>URIs.escapeuri</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">escapeuri(x)</code></pre><p>Apply URI percent-encoding to escape special characters in <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="URIs.unescapeuri" href="#URIs.unescapeuri"><code>URIs.unescapeuri</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unescapeuri(str)</code></pre><p>Percent-decode a string according to the URI escaping rules.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="URIs.splitpath" href="#URIs.splitpath"><code>URIs.splitpath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">URIs.splitpath(path|uri; rstrip_empty_segment=true)</code></pre><p>Splits the path into component segments based on <code>/</code>, according to http://tools.ietf.org/html/rfc3986#section-3.3. Any fragment and query parts of the string are ignored if present.</p><p>A final empty path segment (trailing &#39;/&#39;) is removed, if present. This is technically incompatible with the segment grammar of RFC3986, but it seems to be a common recommendation to make paths with and without a trailing slash equivalent. To preserve any final empty path segment, set <code>rstrip_empty_segment=false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; URIs.splitpath(URI(&quot;http://example.com/foo/bar?a=b&amp;c=d&quot;))
2-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;

julia&gt; URIs.splitpath(&quot;/foo/bar/&quot;)
2-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isvalid-Tuple{URI}" href="#Base.isvalid-Tuple{URI}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>checks if a <code>URI</code> is valid</p></div></section></article><h2 id="Cookies"><a class="docs-heading-anchor" href="#Cookies">Cookies</a><a id="Cookies-1"></a><a class="docs-heading-anchor-permalink" href="#Cookies" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><code>name</code>: name of the cookie</li><li><code>value</code>: value of the cookie</li><li><code>path</code>: applicable path for the cookie</li><li><code>domain</code>: applicable domain for the cookie</li><li><code>expires</code>: a <code>Dates.DateTime</code> representing when the cookie should expire</li><li><code>maxage</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>max age &gt; 0</code> means the # of seconds until expiration</li><li><code>secure::Bool</code>: secure cookie attribute</li><li><code>httponly::Bool</code>: httponly cookie attribute</li><li><code>hostonly::Bool</code>: hostonly cookie attribute</li></ul><p>See http:#tools.ietf.org/html/rfc6265 for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/cookies.jl#L43-L63">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HTTP.sniff" href="#HTTP.sniff"><code>HTTP.sniff</code></a> — <span class="docstring-category">Function</span></header><section><div><p><code>HTTP.sniff(content::Union{Vector{UInt8}, String, IO})</code> =&gt; <code>String</code> (mimetype)</p><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/sniff.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Strings.escapehtml" href="#HTTP.Strings.escapehtml"><code>HTTP.Strings.escapehtml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">escapehtml(i::String)</code></pre><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Strings.jl#L8-L12">source</a></section></article><h2 id="Server-/-Handlers"><a class="docs-heading-anchor" href="#Server-/-Handlers">Server / Handlers</a><a id="Server-/-Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Server-/-Handlers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HTTP.Servers.listen" href="#HTTP.Servers.listen"><code>HTTP.Servers.listen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.listen([host=Sockets.localhost[, port=8081]]; kw...) do http::HTTP.Stream
    ...
end</code></pre><p>Listen for HTTP connections and execute the <code>do</code> function for each request.</p><p>The <code>do</code> function should be of the form <code>f(::HTTP.Stream)::Nothing</code>, and should at the minimum set a status via <code>setstatus()</code> and call <code>startwrite()</code> either explicitly or implicitly by writing out a response via <code>write()</code>.  Failure to do this will result in an HTTP 500 error being transmitted to the client.</p><p>Optional keyword arguments:</p><ul><li><code>sslconfig=nothing</code>, Provide an <code>MbedTLS.SSLConfig</code> object to handle ssl  connections. Pass <code>sslconfig=MbedTLS.SSLConfig(false)</code> to disable ssl  verification (useful for testing).</li><li><code>reuse_limit = nolimit</code>, number of times a connection is allowed to be reused after the first request.</li><li><code>tcpisvalid = tcp-&gt;true</code>, function <code>f(::TCPSocket)::Bool</code> to, check accepted  connection before processing requests. e.g. to do source IP filtering.</li><li><code>readtimeout::Int=0</code>, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.</li><li><code>reuseaddr::Bool=false</code>, allow multiple servers to listen on the same port.</li><li><code>server::Base.IOServer=nothing</code>, provide an <code>IOServer</code> object to listen on;  allows closing the server.</li><li><code>connection_count::Ref{Int}</code>, reference to track the number of currently  open connections.</li><li><code>rate_limit::Rational{Int}=nothing&quot;</code>, number of <code>connections//second</code>  allowed per client IP address; excess connections are immediately closed.  e.g. 5//1.</li><li><code>verbose::Bool=false</code>, log connection information to <code>stdout</code>.</li><li><code>on_shutdown::Union{Function, Vector{&lt;:Function}, Nothing}=nothing</code>, one or  more functions to be run if the server is closed (for example by an  <code>InterruptException</code>). Note, shutdown function(s) will not run if a  <code>IOServer</code> object is supplied and closed by <code>close(server)</code>.</li></ul><p>e.g.</p><pre><code class="language-julia">HTTP.listen(&quot;127.0.0.1&quot;, 8081) do http
    HTTP.setheader(http, &quot;Content-Type&quot; =&gt; &quot;text/html&quot;)
    write(http, &quot;target uri: $(http.message.target)&lt;BR&gt;&quot;)
    write(http, &quot;request body:&lt;BR&gt;&lt;PRE&gt;&quot;)
    write(http, read(http))
    write(http, &quot;&lt;/PRE&gt;&quot;)
    return
end

HTTP.listen(&quot;127.0.0.1&quot;, 8081) do http
    @show http.message
    @show HTTP.header(http, &quot;Content-Type&quot;)
    while !eof(http)
        println(&quot;body data: &quot;, String(readavailable(http)))
    end
    HTTP.setstatus(http, 404)
    HTTP.setheader(http, &quot;Foo-Header&quot; =&gt; &quot;bar&quot;)
    startwrite(http)
    write(http, &quot;response body&quot;)
    write(http, &quot;more response body&quot;)
end</code></pre><p>The <code>server=</code> option can be used to pass an already listening socket to <code>HTTP.listen</code>. This allows manual control of server shutdown.</p><p>e.g.</p><pre><code class="language-julia">using Sockets
server = Sockets.listen(Sockets.InetAddr(parse(IPAddr, host), port))
@async HTTP.listen(f, host, port; server=server)

# Closing server will stop HTTP.listen.
close(server)</code></pre><p>To run the following HTTP chat example, open two Julia REPL windows and paste the example code into both of them. Then in one window run <code>chat_server()</code> and in the other run <code>chat_client()</code>, then type <code>hello</code> and press return. Whatever you type on the client will be displayed on the server and vis-versa.</p><pre><code class="language-none">using HTTP

function chat(io::HTTP.Stream)
    @async while !eof(io)
        write(stdout, readavailable(io), &quot;\n&quot;)
    end
    while isopen(io)
        write(io, readline(stdin))
    end
end

chat_server() = HTTP.listen(&quot;127.0.0.1&quot;, 8087) do io
    write(io, &quot;HTTP.jl Chat Server. Welcome!&quot;)
    chat(io)
end

chat_client() = HTTP.open(&quot;POST&quot;, &quot;http://127.0.0.1:8087&quot;) do io
    chat(io)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Servers.jl#L116-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.serve" href="#HTTP.Handlers.serve"><code>HTTP.Handlers.serve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.serve([host=Sockets.localhost[, port=8081]]; kw...) do req::HTTP.Request
    ...
end
HTTP.serve([host=Sockets.localhost[, port=8081]]; stream=true, kw...) do stream::HTTP.Stream
    ...
end
HTTP.serve(handler, [host=Sockets.localhost[, port=8081]]; kw...)</code></pre><p>Listen for HTTP connections and handle each request received. The &quot;handler&quot; can be a function that operates directly on <code>HTTP.Stream</code>, <code>HTTP.Request</code>, or any kind of <code>HTTP.Handler</code> instance. For functions like <code>f(::HTTP.Stream)</code>, also pass <code>stream=true</code> to signal a streaming handler.</p><p>Optional keyword arguments:</p><ul><li><code>sslconfig=nothing</code>, Provide an <code>MbedTLS.SSLConfig</code> object to handle ssl connections.  Pass <code>sslconfig=MbedTLS.SSLConfig(false)</code> to disable ssl verification (useful for testing)</li><li><code>reuse_limit = nolimit</code>, number of times a connection is allowed to be reused  after the first request.</li><li><code>tcpisvalid::Function (::TCPSocket) -&gt; Bool</code>, check accepted connection before  processing requests. e.g. to implement source IP filtering, rate-limiting, etc.</li><li><code>readtimeout::Int=0</code>, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.</li><li><code>reuseaddr::Bool=false</code>, allow multiple server processes to listen on the same port. Only fully supported on linux; OSX will allow multiple server processes to listen, but only one will accept connections</li><li><code>server::Base.IOServer=nothing</code>, provide an <code>IOServer</code> object to listen on;  allows manual control over closing the server.</li><li><code>connection_count::Ref{Int}</code>, reference to track the # of currently open connections.</li><li><code>rate_limit::Rational{Int}=nothing&quot;</code>, number of <code>connections//second</code> allowed  per client IP address; excess connections are immediately closed. e.g. 5//1.</li><li><code>stream::Bool=false</code>, the handler will operate on an <code>HTTP.Stream</code> instead of <code>HTTP.Request</code></li><li><code>verbose::Bool=false</code>, log connection information to <code>stdout</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">HTTP.serve(; stream=true) do http::HTTP.Stream
    @show http.message
    @show HTTP.header(http, &quot;Content-Type&quot;)
    while !eof(http)
        println(&quot;body data: &quot;, String(readavailable(http)))
    end
    HTTP.setstatus(http, 404)
    HTTP.setheader(http, &quot;Foo-Header&quot; =&gt; &quot;bar&quot;)
    startwrite(http)
    write(http, &quot;response body&quot;)
    write(http, &quot;more response body&quot;)
    return
end

# pass in own server socket to control shutdown
using Sockets
server = Sockets.listen(Sockets.InetAddr(parse(IPAddr, host), port))
@async HTTP.serve(f, host, port; server=server)
# close server which will stop HTTP.serve
close(server)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Handlers.jl#L287-L341">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers" href="#HTTP.Handlers"><code>HTTP.Handlers</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>Examples</strong></p><p>Let&#39;s put together an example http REST server for our hypothetical &quot;ZooApplication&quot; that utilizes various parts of the Servers &amp; Handler frameworks.</p><p>Our application allows users to interact with custom &quot;animal&quot; JSON objects.</p><p>First we have our &quot;model&quot; or data structures:</p><pre><code class="language-julia">mutable struct Animal
    id::Int
    type::String
    name::String
end</code></pre><p>Now we want to define our REST api, or how do we allow users to create, update, retrieve and delete animals:</p><pre><code class="language-julia"># use a plain `Dict` as a &quot;data store&quot;
const ANIMALS = Dict{Int, Animal}()
const NEXT_ID = Ref(0)
function getNextId()
    id = NEXT_ID[]
    NEXT_ID[] += 1
    return id
end

# &quot;service&quot; functions to actually do the work
function createAnimal(req::HTTP.Request)
    animal = JSON2.read(IOBuffer(HTTP.payload(req)), Animal)
    animal.id = getNextId()
    ANIMALS[animal.id] = animal
    return HTTP.Response(200, JSON2.write(animal))
end

function getAnimal(req::HTTP.Request)
    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10
    animal = ANIMALS[parse(Int, animalId)]
    return HTTP.Response(200, JSON2.write(animal))
end

function updateAnimal(req::HTTP.Request)
    animal = JSON2.read(IOBuffer(HTTP.payload(req)), Animal)
    ANIMALS[animal.id] = animal
    return HTTP.Response(200, JSON2.write(animal))
end

function deleteAnimal(req::HTTP.Request)
    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10
    delete!(ANIMALS, parse(Int, animal.id))
    return HTTP.Response(200)
end

# define REST endpoints to dispatch to &quot;service&quot; functions
const ANIMAL_ROUTER = HTTP.Router()
HTTP.@register(ANIMAL_ROUTER, &quot;POST&quot;, &quot;/api/zoo/v1/animals&quot;, createAnimal)
# note the use of `*` to capture the path segment &quot;variable&quot; animal id
HTTP.@register(ANIMAL_ROUTER, &quot;GET&quot;, &quot;/api/zoo/v1/animals/*&quot;, getAnimal)
HTTP.@register(ANIMAL_ROUTER, &quot;PUT&quot;, &quot;/api/zoo/v1/animals&quot;, updateAnimal)
HTTP.@register(ANIMAL_ROUTER, &quot;DELETE&quot;, &quot;/api/zoo/v1/animals/*&quot;, deleteAnimal)</code></pre><p>Great! At this point, we could spin up our server and let users start managing their animals:</p><pre><code class="language-julia">HTTP.serve(ANIMAL_ROUTER, Sockets.localhost, 8081)</code></pre><p>Now, you may have noticed that there was a bit of repetition in our &quot;service&quot; functions, particularly with regards to the JSON serialization/deserialization. Perhaps we can simplify things by writing a custom &quot;JSONHandler&quot; to do some of the repetitive work for us.</p><pre><code class="language-julia">function JSONHandler(req::HTTP.Request)
    # first check if there&#39;s any request body
    body = IOBuffer(HTTP.payload(req))
    if eof(body)
        # no request body
        response_body = handle(ANIMAL_ROUTER, req)
    else
        # there&#39;s a body, so pass it on to the handler we dispatch to
        response_body = handle(ANIMAL_ROUTER, req, JSON2.read(body, Animal))
    end
    return HTTP.Response(200, JSON2.write(response_body))
end

# **simplified** &quot;service&quot; functions
function createAnimal(req::HTTP.Request, animal)
    animal.id = getNextId()
    ANIMALS[animal.id] = animal
    return animal
end

function getAnimal(req::HTTP.Request)
    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10
    return ANIMALS[animalId]
end

function updateAnimal(req::HTTP.Request, animal)
    ANIMALS[animal.id] = animal
    return animal
end

function deleteAnimal(req::HTTP.Request)
    animalId = HTTP.URIs.splitpath(req.target)[5] # /api/zoo/v1/animals/10, get 10
    delete!(ANIMALS, animal.id)
    return &quot;&quot;
end</code></pre><p>And we modify slightly how we run our server, letting our new <code>JSONHandler</code> be the entry point instead of our router:</p><pre><code class="language-julia">HTTP.serve(JSONHandler, Sockets.localhost, 8081)</code></pre><p>Our <code>JSONHandler</code> is nice because it saves us a bunch of repetition: if a request body comes in, we automatically deserialize it and pass it on to the service function. And each service function doesn&#39;t need to worry about returning <code>HTTP.Response</code>s anymore, but can just focus on returning plain Julia objects/strings. The other huge advantage is it provides a clean separation of concerns between the &quot;service&quot; layer, which should really concern itself with application logic, and the &quot;REST API&quot; layer, which should take care of translating between our model and a web data format (JSON).</p><p>Let&#39;s take this one step further and allow multiple users to manage users, and add in one more custom handler to provide an authentication layer to our application. We can&#39;t just let anybody be modifying another user&#39;s animals!</p><pre><code class="language-julia"># modified Animal struct to associate with specific user
mutable struct Animal
    id::Int
    userId::Base.UUID
    type::String
    name::String
end

# modify our data store to allow for multiple users
const ANIMALS = Dict{Base.UUID, Dict{Int, Animal}}()

# creating a user returns a new UUID key unique to the user
createUser(req) = Base.UUID(rand(UInt128))

# add an additional endpoint for user creation
HTTP.@register(ANIMAL_ROUTER, &quot;POST&quot;, &quot;/api/zoo/v1/users&quot;, createUser)
# modify service endpoints to have user pass UUID in
HTTP.@register(ANIMAL_ROUTER, &quot;GET&quot;, &quot;/api/zoo/v1/users/*/animals/*&quot;, getAnimal)
HTTP.@register(ANIMAL_ROUTER, &quot;DELETE&quot;, &quot;/api/zoo/v1/users/*/animals/*&quot;, deleteAnimal)

# modified service functions to account for multiple users
function createAnimal(req::HTTP.Request, animal)
    animal.id = getNextId()
    ANIMALS[animal.userId][animal.id] = animal
    return animal
end

function getAnimal(req::HTTP.Request)
    paths = HTTP.URIs.splitpath(req.target)
    userId = path[5] # /api/zoo/v1/users/x92jf-.../animals/10, get user UUID
    animalId = path[7] # /api/zoo/v1/users/x92jf-.../animals/10, get 10
    return ANIMALS[userId][parse(Int, animalId)]
end

function updateAnimal(req::HTTP.Request, animal)
    ANIMALS[animal.userId][animal.id] = animal
    return animal
end

function deleteAnimal(req::HTTP.Request)
    paths = HTTP.URIs.splitpath(req.target)
    userId = path[5] # /api/zoo/v1/users/x92jf-.../animals/10, get user UUID
    animalId = path[7] # /api/zoo/v1/users/x92jf-.../animals/10, get 10
    delete!(ANIMALS[userId], parse(Int, animal.id))
    return &quot;&quot;
end

# AuthHandler to reject any unknown users
function AuthHandler(req)
    if HTTP.hasheader(req, &quot;Animal-UUID&quot;)
        uuid = HTTP.header(req, &quot;Animal-UUID&quot;)
        if haskey(ANIMALS, uuid)
            return JSONHandler(req)
        end
    end
    return HTTP.Response(401, &quot;unauthorized&quot;)
end</code></pre><p>And our modified server invocation:</p><pre><code class="language-julia">HTTP.serve(AuthHandler, Sockets.localhost, 8081)</code></pre><p>Let&#39;s review what&#39;s going on here:</p><ul><li>Each <code>Animal</code> object now includes a <code>UUID</code> object unique to a user</li><li>We added a <code>/api/zoo/v1/users</code> endpoint for creating a new user</li><li>Each of our service functions now account for individual users</li><li>We made a new <code>AuthHandler</code> as the very first entry point in our middleware stack, this means that every single request must first pass through this authentication layer before reaching the service layer. Our <code>AuthHandler</code> checks that the user provided our security request header <code>Animal-UUID</code> and if so, ensures the provided UUID corresponds to a valid user. If not, the <code>AuthHandler</code> returns a 401 HTTP response, signalling that the request is unauthorized</li></ul><p>Voila, hopefully that helps provide a slightly-more-than-trivial example of utilizing the HTTP.Handler framework in conjunction with running an HTTP server.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Handlers.jl#L1-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.handle" href="#HTTP.Handlers.handle"><code>HTTP.Handlers.handle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HTTP.handle(handler::HTTP.RequestHandler, ::HTTP.Request) =&gt; HTTP.Response
HTTP.handle(handler::HTTP.StreamHandler, ::HTTP.Stream)</code></pre><p>Dispatch function used to handle incoming requests to a server. Can be overloaded by custom <code>HTTP.Handler</code> subtypes to implement custom &quot;handling&quot; behavior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Handlers.jl#L214-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.RequestHandlerFunction" href="#HTTP.Handlers.RequestHandlerFunction"><code>HTTP.Handlers.RequestHandlerFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RequestHandlerFunction(f)</code></pre><p>A function-wrapper type that is a subtype of <code>RequestHandler</code>. Takes a single function as an argument that should be of the form <code>f(::HTTP.Request) =&gt; HTTP.Response</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Handlers.jl#L244-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.StreamHandlerFunction" href="#HTTP.Handlers.StreamHandlerFunction"><code>HTTP.Handlers.StreamHandlerFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StreamHandlerFunction(f)</code></pre><p>A function-wrapper type that is a subtype of <code>StreamHandler</code>. Takes a single function as an argument that should be of the form <code>f(::HTTP.Stream) =&gt; Nothing</code>, i.e. it accepts a raw <code>HTTP.Stream</code>, handles the incoming request, writes a response back out to the stream directly, then returns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Handlers.jl#L259-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.Router" href="#HTTP.Handlers.Router"><code>HTTP.Handlers.Router</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HTTP.Router(h::Handler)
HTTP.Router(f::Function)
HTTP.Router()</code></pre><p>An <code>HTTP.Handler</code> type that supports pattern matching request url paths to registered <code>HTTP.Handler</code>s. Can accept a default <code>Handler</code> or <code>Function</code> that will be used in case no other handlers match; by default, a 404 response handler is used. Paths can be mapped to a handler via <code>HTTP.@register(r::Router, path, handler)</code>, see <code>?HTTP.@register</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Handlers.jl#L358-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.@register" href="#HTTP.Handlers.@register"><code>HTTP.Handlers.@register</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">HTTP.@register(r::Router, path, handler)
HTTP.@register(r::Router, method::String, path, handler)
HTTP.@register(r::Router, method::String, scheme::String, host::String, path, handler)</code></pre><p>Function to map request urls matching <code>path</code> and optional method, scheme, host to another <code>handler::HTTP.Handler</code>. URL paths are registered one at a time, and multiple urls can map to the same handler. The URL can be passed as a String. Requests can be routed based on: method, scheme, hostname, or path. The following examples show how various urls will direct how a request is routed by a server:</p><ul><li><code>&quot;http://*&quot;</code>: match all HTTP requests, regardless of path</li><li><code>&quot;https://*&quot;</code>: match all HTTPS requests, regardless of path</li><li><code>&quot;/gmail&quot;</code>: regardless of scheme or host, match any request with a path starting with &quot;gmail&quot;</li><li><code>&quot;/gmail/userId/*/inbox</code>: match any request matching the path pattern, &quot;*&quot; is used as a wildcard that matches any value between the two &quot;/&quot;</li></ul><p>Note that due to being a macro (and the internal routing functionality), routes can only be registered statically, i.e. at the top level of a module, and not dynamically, i.e. inside a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/4f0175c9c815b2339a4785039fb76b72d18e1d49/src/Handlers.jl#L423-L440">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../internal_architecture/">Internal Architecture »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 23 February 2021 14:37">Tuesday 23 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
