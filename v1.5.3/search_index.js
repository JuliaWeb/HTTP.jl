var documenterSearchIndex = {"docs":
[{"location":"client/#Client","page":"Client","title":"Client","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"HTTP.jl provides a wide range of HTTP client functionality, mostly exposed through the HTTP.request family of functions. This document aims to walk through the various ways requests can be configured to accomplish whatever your goal may be.","category":"page"},{"location":"client/#Basic-Usage","page":"Client","title":"Basic Usage","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"The standard form for making requests is:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"HTTP.request(method, url [, headers [, body]]; <keyword arguments>]) -> HTTP.Response","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"First, let's walk through the positional arguments.","category":"page"},{"location":"client/#Method","page":"Client","title":"Method","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"method refers to the HTTP method (sometimes known as \"verb\"), including GET, POST, PUT, DELETE, PATCH, TRACE, etc. It can be provided either as a String like HTTP.request(\"GET\", ...), or a Symbol like HTTP.request(:GET, ...). There are also convenience methods for the most common methods, including:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"HTTP.get(...)\nHTTP.post(...)\nHTTP.put(...)\nHTTP.delete(...)\nHTTP.patch(...)\nHTTP.head(...)","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"These methods operate identically to HTTP.request, except the method argument is \"builtin\" via function name.","category":"page"},{"location":"client/#Url","page":"Client","title":"Url","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"For the request url argument, the URIs.jl package is used to parse this String argument into a URI object, which detects the HTTP scheme, user info, host, port (if any), path, query parameters, fragment, etc. The host and port will be used to actually make a connection to the remote server and send data to and receive data from. Query parameters can be included in the url String itself, or passed as a separate query keyword argument to HTTP.request, which will be discussed in more detail later.","category":"page"},{"location":"client/#Headers","page":"Client","title":"Headers","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"The headers argument is an optional list of header name-value pairs to be included in the request. They can be provided as a Vector of Pairs, like [\"header1\" => \"value1\", \"header2\" => \"value2\"], or a Dict, like Dict(\"header1\" => \"value1\", \"header2\" => \"value2\"). Header names do not have to be unique, so any argument passed will be converted to Vector{Pair}. By default, HTTP.request will include a few headers automatically, including \"Host\" => url.host, \"Accept\" => \"*/*\", \"User-Agent\" => \"HTTP.jl/1.0\", and \"Content-Length\" => body_length. These can be overwritten by providing them yourself, like HTTP.get(url, [\"Accept\" => \"application/json\"]), or you can prevent the header from being included by default by including it yourself with an empty string as value, like HTTP.get(url, [\"Accept\" => \"\"]), following the curl convention. There are keyword arguments that control the inclusion/setting of other headers, like basicauth, detect_content_type, cookies, etc. that will be discussed in more detail later.","category":"page"},{"location":"client/#Body","page":"Client","title":"Body","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"The optional body argument makes up the \"body\" of the sent request and is only used for HTTP methods that expect a body, like POST and PUT. A variety of objects are supported:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"a Dict or NamedTuple to be serialized as the \"application/x-www-form-urlencoded\" content type, so Dict(\"nm\" => \"val\") will be sent in the request body like nm=val\nany AbstractString or AbstractVector{UInt8} which will be sent \"as is\" for the request body\na readable IO stream or any IO-like type T for which eof(T) and readavailable(T) are defined. This stream will be read and sent until eof is true. This object should support the mark/reset methods if request retires are desired (if not, no retries will be attempted).\nAny collection or iterable of the above (Dict, AbstractString, AbstractVector{UInt8}, or IO) which will result in a \"Transfer-Encoding=chunked\" request body, where each iterated element will be sent as a separate chunk\na HTTP.Form, which will be serialized as the \"multipart/form-data\" content-type","category":"page"},{"location":"client/#Response","page":"Client","title":"Response","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Upon successful completion, HTTP.request returns a HTTP.Response object. It includes the following fields:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"status: the HTTP status code of the response, e.g. 200 for normal response\nheaders: a Vector of String Pairs for each name=value pair in the response headers. Convenience methods for working with headers include: HTTP.hasheader(resp, key) to check if header exists; HTTP.header(resp, key) retrive the value of a header with name key; HTTP.headers(resp, key) retrieve a list of all the headers with name key, since headers can have duplicate names\nbody: a Vector{UInt8} of the response body bytes. Alternatively, an IO object can be provided via the response_stream keyword argument to have the response body streamed as it is received.","category":"page"},{"location":"client/#Keyword-Arguments","page":"Client","title":"Keyword Arguments","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"A number of keyword arguments are provided to give fine-tuned control over the request process.","category":"page"},{"location":"client/#query","page":"Client","title":"query","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Query parameters are included in the url of the request like http://httpbin.org/anything?q1=v1&q2=v2, where the string ?q1=v1&q2=v2 after the question mark represent the \"query parameters\". They are essentially a list of key-value pairs. Query parameters can be included in the url itself when calling HTTP.request, like HTTP.request(:GET, \"http://httpbin.org/anything?q1=v1&q2=v2\"), but oftentimes, it's convenient to generate and pass them programmatically. To do this, pass an object that iterates String Pairs to the query keyword argument, like the following examples:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"HTTP.get(url; query=Dict(\"x1\" => \"y1\", \"x2\" => \"y2\")\nHTTP.get(url; query=[\"x1\" => \"y1\", \"x1\" => \"y2\"]: this form allows duplicate key values\nHTTP.get(url; query=[(\"x1\", \"y1)\", (\"x2\", \"y2\")]","category":"page"},{"location":"client/#response_stream","page":"Client","title":"response_stream","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"By default, the HTTP.Response body is returned as a Vector{UInt8}. There may be scenarios, however, where more control is desired, like downloading large files, where it's preferrable to stream the response body directly out to file or into some other IO object. By passing a writeable IO object to the response_stream keyword argument, the response body will not be fully materialized and will be written to as it is received from the remote connection. Note that in the presense of request redirects and retries, multiple requests end up being made in a single call to HTTP.request by default (configurable via the redirects and retry keyword arguments). If response_stream is provided and a request is redirected or retried, the response_stream is not written to until the final request is completed (either the redirect is successfully followed, or the request doesn't need to be retried, etc.).","category":"page"},{"location":"client/#Examples","page":"Client","title":"Examples","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Stream body to file:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"io = open(\"get_data.txt\", \"w\")\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\nprintln(read(\"get_data.txt\", String))","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Stream body through buffer:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"r = HTTP.get(\"http://httpbin.org/get\", response_stream=IOBuffer())\nprintln(String(take!(r.body)))","category":"page"},{"location":"client/#verbose","page":"Client","title":"verbose","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"HTTP requests can be a pain sometimes. We get it. It can be tricky to get the headers, query parameters, or expected body in just the right format. For convenience, the verbose keyword argument is provided to enable debug logging for the duration of the call to HTTP.request. This can be helpful to \"peek under the hood\" of what all goes on in the process of making request: are redirects returned and followed? Is the connection not getting made to the right host? Is some error causing the request to be retried unexpectedly? Currently, the verbose keyword argument supports passing increasing levels to enable more and more verbose logging, from 0 (no debug logging, the default), up to 3 (most verbose, probably too much for anyone but package developers).","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"If you're running into a real head-scratcher, don't hesitate to open an issue and include the problem you're running into; it's most helpful when you can include the output of passing verbose=3, so package maintainers can see a detailed view of what's going on.","category":"page"},{"location":"client/#Connection-keyword-arguments","page":"Client","title":"Connection keyword arguments","text":"","category":"section"},{"location":"client/#connect_timeout","page":"Client","title":"connect_timeout","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"When a connection is attempted to a remote host, sometimes the connection is unable to be established for whatever reason. Passing a non-zero connect_timetout value will cause HTTP.request to wait that many seconds before giving up and throwing an error.","category":"page"},{"location":"client/#connection_limit","page":"Client","title":"connection_limit","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Many remote web services/APIs have rate limits or throttling in place to avoid bad actors from abusing their service. They may prevent too many requests over a time period or they may prevent too many connections being simultaneously open from the same client. By default, when HTTP.request opens a remote connection, it remembers the exact host:port combination and will keep the connection open to be reused by subsequent requests to the same host:port. The connection_limit keyword argument controls how many concurrent connections are allowed to a single remote host.","category":"page"},{"location":"client/#readtimeout","page":"Client","title":"readtimeout","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"After a connection is established and a request is sent, a response is expected. If a non-zero value is passed to the readtimeout keyword argument, HTTP.request will wait to receive a response that many seconds before throwing an error. Note that for chunked or streaming responses, each chunk/packet of bytes received causes the timeout to reset. Passing readtimeout = 0 disables any timeout checking and is the default.","category":"page"},{"location":"client/#status_exception","page":"Client","title":"status_exception","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"When a non-2XX HTTP status code is received in a response, this is meant to convey some error condition. 3XX responses typically deal with \"redirects\" where the request should actually try a different url (these are followed automatically by default in HTTP.request, though up to a limit; see redirect). 4XX status codes typically mean the remote server thinks something is wrong in how the request is made. 5XX typically mean something went wrong on the server-side when responding. By default, as mentioned previously, HTTP.request will attempt to follow redirect responses, and retry \"retryable\" requests (where the status code and original request method allow). If, after redirects/retries, a response still has a non-2XX response code, the default behavior is to throw an HTTP.StatusError exception to signal that the request didn't succeed. This behavior can be disabled by passing status_exception=false, where the HTTP.Response object will be returned with the non-2XX status code intact.","category":"page"},{"location":"client/#basicauth","page":"Client","title":"basicauth","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"By default, if \"user info\" is detected in the request url, like http://user:password@host, the Authorization: Basic header will be added to the request headers before the request is sent. While not very common, some APIs use this form of authentication to verify requests. This automatic adding of the header can be disabled by passing basicauth=false.","category":"page"},{"location":"client/#canonicalize_headers","page":"Client","title":"canonicalize_headers","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"In the HTTP specification, header names are case insensitive, yet it is sometimes desirable to send/receive headers in a more predictable format. Passing canonicalize_headers=true (false by default) will reformat all request and response headers to use the Canonical-Camel-Dash-Format.","category":"page"},{"location":"client/#proxy","page":"Client","title":"proxy","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"In certain network environments, connections to a proxy must first be made and external requests are then sent \"through\" the proxy. HTTP.request supports this workflow by allowing the passing of a proxy url via the proxy keyword argument. Alternatively, it's a common pattern for HTTP libraries to check for the http_proxy, HTTP_PROXY, https_proxy, HTTPS_PROXY, and no_proxy environment variables and, if present, be used for these kind of proxied requests. Note that environment variables typically should be set prior to starting the Julia process; alternatively, the withenv Julia function can be used to temporarily modify the current process environment variables, so it could be used like:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"resp = withenv(\"http_proxy\" => proxy_url) do\n    HTTP.request(:GET, url)\nend","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"The no_proxy argument is typically a comma-separated list of urls that should not use the proxy, and is parsed when the HTTP.jl package is loaded, and thus won't work with the withenv method mentioned.","category":"page"},{"location":"client/#detect_content_type","page":"Client","title":"detect_content_type","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"By default, the Content-Type header is not included by HTTP.request. To automatically detect various content types (html, xml, pdf, images, zip, gzip, JSON) and set this header, pass detect_content_type=true.","category":"page"},{"location":"client/#decompress","page":"Client","title":"decompress","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"By default, when the response includes the Content-Encoding: gzip header, the response body will be decompressed. To avoid this behavior, pass decompress=false. This keyword also controls the automatic inclusion of the Accept-Encoding: gzip header in the request being sent.","category":"page"},{"location":"client/#Retry-arguments","page":"Client","title":"Retry arguments","text":"","category":"section"},{"location":"client/#retry","page":"Client","title":"retry","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Controls overall whether requests will be retried at all; pass retry=false to disable all retries.","category":"page"},{"location":"client/#retries","page":"Client","title":"retries","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Controls the total number of retries that will be attempted. Can also disable all retries by passing retries = 0. Note that for a request to be retried, in addition to the retry and retries keyword arguments, must be \"retryable\", which includes the following requirements:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Request body must be static (string or bytes) or an IO the supports the mark/reset interface\nThe request method must be idempotent as defined by RFC-7231, which includes GET, HEAD, OPTIONS, TRACE, PUT, and DELETE (not POST or PATCH).\nIf the method isn't idempotent, can pass retry_non_idempotent=true keyword argument to retry idempotent requests\nThe retry limit hasn't been reached, as specified by retries keyword argument\nThe \"failed\" response must have one of the following status codes: 403, 408, 409, 429, 500, 502, 503, 504, 599.","category":"page"},{"location":"client/#retry_non_idempotent","page":"Client","title":"retry_non_idempotent","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"By default, this keyword argument is false, which controls whether non-idempotent requests will be retried (POST or PATCH requests).","category":"page"},{"location":"client/#Redirect-Arguments","page":"Client","title":"Redirect Arguments","text":"","category":"section"},{"location":"client/#redirect","page":"Client","title":"redirect","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"This keyword argument controls whether responses that specify a redirect (via 3XX status code + Location header) will be \"followed\" by issuing a follow up request to the specified Location. There are certain rules/logic that are followed when deciding whether to redirect and how the redirected request will be made:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"The Location redirect url must be \"valid\" with an appropriate scheme and host; if the new location is relative to the original request url, the new url is resolved by calling URIs.resolvereference\nThe response status code is one of: 301, 302, 307, or 308\nThe method of the redirected request may change: 307 or 308 status codes will not change the method, 303 means only a GET request is allowed, otherwise, if the redirect_method keyword argument is provided, it will be used. If not provided, the redirected request will default to a GET request.\nWe'll only make a redirect request if we haven't made too many redirect attempts already, as controlled by the redirect_limit keyword argument (default 3)\nThe original request headers will, by default, be forwarded in the redirected request, unless the new url is an entirely new host, then Cookie and Authorization headers will be removed.","category":"page"},{"location":"client/#redirect_limit","page":"Client","title":"redirect_limit","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Controls how many redirects will be \"followed\" by making additional requests in the case of a redirected response url recursively returning redirect responses and so on. In addition to redirect=false, passing redirect_limit=0 will also disable any redirect behavior all together.","category":"page"},{"location":"client/#redirect_method","page":"Client","title":"redirect_method","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"May control the method that will be used in the redirected request. For 307 or 308 status codes, the same method will be used by default. For 303, only GET requests are allowed. For other status codes (301, 302), this keyword argument will be used to determine what the redirect request method will be. Passing redirect_method=:same will result in the same method as the original request. Otherwise, passing redirect_method=:GET, or any other valid method as String or Symbol, will result in that method for the redirected request.","category":"page"},{"location":"client/#forwardheaders","page":"Client","title":"forwardheaders","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Controls whether original request headers will be included in the redirected request. true by default. Pass forwardheaders=false to disable headers being used in redirected requests. By design, if the new redirect location url is a different host than the original host, \"sensitive\" headers will not be forwarded, including Cookie and Authorization headers.","category":"page"},{"location":"client/#SSL-Arguments","page":"Client","title":"SSL Arguments","text":"","category":"section"},{"location":"client/#require_ssl_verification","page":"Client","title":"require_ssl_verification","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Controls whether the SSL configuration for a secure connection is verified in the handshake process. true by default. Should only be set to false if developing against a local server that can be completely trusted.","category":"page"},{"location":"client/#sslconfig","page":"Client","title":"sslconfig","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Allows specifying a custom MbedTLS.SSLConfig configuration to be used in the secure connection handshake process to verify the connection. A custom cert and key file can be passed to construct a custom SSLConfig like MbedTLS.SSLConfig(cert_file, key_file).","category":"page"},{"location":"client/#Cookie-Arguments","page":"Client","title":"Cookie Arguments","text":"","category":"section"},{"location":"client/#cookies","page":"Client","title":"cookies","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Controls if and how a request Cookie header is set for a request. By default, cookies is true, which means the cookiejar (an internal global by default) will be checked for previously received Set-Cookie headers from past responses for the request domain and, if found, will be included in the outgoing request. Passing cookies=false will disable any automatic cookie tracking/setting. For more granular control, the Cookie header can be set manually in the headers request argument and cookies=false is passed. Otherwise, a Dict{String, String} can be passed in the cookies argument, which should be cookie name-value pairs to be serialized into the Cookie header for the current request. If cookies=false or an empty Dict is passed in the cookies keyword argument, no Set-Cookie response headers will be parsed and stored for use in future requests. In the automatic case of including previously received cookies, verification is done to ensure the cookie hasn't expired, matches the correct domain, etc.","category":"page"},{"location":"client/#cookiejar","page":"Client","title":"cookiejar","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"If cookies are \"enabled\" (either by passing cookies=true or passing a non-empty Dict via cookies keyword argument), this keyword argument specifies the HTTP.CookieJar object that should be used to store received Set-Cookie cookie name-value pairs from responses. Cookies are stored for the appropriate host/domain and will, by default, be included in future requests when the host/domain match and other conditions are met (cookie hasn't expired, etc.). By default, a single global CookieJar is used, which is threadsafe. To pass a custom CookieJar, first create one: jar = HTTP.CookieJar(), then pass like HTTP.get(...; cookiejar=jar).","category":"page"},{"location":"client/#Streaming-Requests","page":"Client","title":"Streaming Requests","text":"","category":"section"},{"location":"client/#HTTP.open","page":"Client","title":"HTTP.open","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Allows a potentially more convenient API when the request and/or response bodies need to be streamed. Works like:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"HTTP.open(method, url, [,headers]; kw...) do io\n    write(io, body)\n    [startread(io) -> HTTP.Response]\n    while !eof(io)\n        readavailable(io) -> AbstractVector{UInt8}\n    end\nend -> HTTP.Response","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Where the io argument provided to the function body is an HTTP.Stream object, a custom IO that represents an open connection that is ready to be written to in order to send the request body, and/or read from to recieve the response body. Note that startread(io) should be called before calling readavailable to ensure the response statu line and headers are received and parsed appropriately. Calling eof(io) will return true until the response body has been completely received. Note that the returned HTTP.Response from HTTP.open will not have a .body field since the body was read in the function body.","category":"page"},{"location":"client/#Download","page":"Client","title":"Download","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"A download function is provided for similar functionality to Downloads.download.","category":"page"},{"location":"client/#Client-side-Middleware-(Layers)","page":"Client","title":"Client-side Middleware (Layers)","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"An HTTP.Layer is an abstract type to represent a client-side middleware. A layer is any function of the form f(::Handler) -> Handler, where Handler is a function of the form f(::Request) -> Response. Note that this Handler definition is the same from the server-side documentation. It may also be apparent that a Layer is the same as the Middleware interface from server-side, which is true, but we define Layer to clarify the client-side distinction and its unique usage.","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Creating custom layers can be a convenient way to \"enhance\" the HTTP.request process with custom functionality. It might be a layer that computes a special authorization header, or modifies the body in some way, or treats the response specially. Oftentimes, layers are application or domain-specific, where certain domain knowledge can be used to improve or simplify the request process. Layers can also be used to enforce the usage of certain keyword arguments if desired.","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Custom layers can be deployed in one of two ways:","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"HTTP.@client: Create a custom \"client\" with shorthand verb definitions, but which include custom layers; only these new verb methods will use the custom layers.\nHTTP.pushlayer!/HTTP.poplayer!: Allows globally adding and removing layers from the default HTTP.jl layer stack; all http requests will then use the custom layers","category":"page"},{"location":"client/#Quick-Examples","page":"Client","title":"Quick Examples","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"module Auth\n\nusing HTTP\n\nfunction auth_layer(handler)\n    # returns a `Handler` function; check for a custom keyword arg `authcreds` that\n    # a user would pass like `HTTP.get(...; authcreds=creds)`.\n    # We also accept trailing keyword args `kw...` and pass them along later.\n    return function(req; authcreds=nothing, kw...)\n        # only apply the auth layer if the user passed `authcreds`\n        if authcreds !== nothing\n            # we add a custom header with stringified auth creds\n            HTTP.setheader(req, \"X-Auth-Creds\" => string(authcreds))\n        end\n        # pass the request along to the next layer by calling `auth_layer` arg `handler`\n        # also pass along the trailing keyword args `kw...`\n        return handler(req; kw...)\n    end\nend\n\n# Create a new client with the auth layer added\nHTTP.@client [auth_layer]\n\nend # module\n\n# Can now use custom client like:\nAuth.get(url; authcreds=creds) # performs GET request with auth_layer layer included\n\n# Or can include layer globally in all HTTP.jl requests\nHTTP.pushlayer!(Auth.auth_layer)\n\n# Now can use normal HTTP.jl methods and auth_layer will be included\nHTTP.get(url; authcreds=creds)","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"For more ideas or examples on how client-side layers work, it can be useful to see how HTTP.request is built on layers internally, in the /src/clientlayers source code directory.","category":"page"},{"location":"server/#Server","page":"Server","title":"Server","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"For server-side functionality, HTTP.jl provides a robust framework for core HTTP and websocket serving, flexible handler and middleware interfaces, and low-level access for unique workflows. The core server listening code is in the /src/Servers.jl file, while the handler, middleware, router, and  higher level HTTP.serve function are defined in the /src/Handlers.jl file.","category":"page"},{"location":"server/#HTTP.serve","page":"Server","title":"HTTP.serve","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"HTTP.serve/HTTP.serve! are the primary entrypoints for HTTP server functionality, while HTTP.listen/HTTP.listen! are considered the lower-level core server loop methods that only operate directly with HTTP.Streams. HTTP.serve is also built directly integrated with the Handler and Middleware interfaces and provides easy flexiblity by doing so. The signature is:","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"HTTP.serve(f, host, port; kw...)\nHTTP.serve!(f, host, port; kw...) -> HTTP.Server","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"Where f is a Handler function, typically of the form f(::Request) -> Response, but can also operate directly on an HTTP.Stream of the form f(::Stream) -> Nothing while also passing stream=true to the keyword arguments. The host argument should be a String, or IPAddr, created like ip\"0.0.0.0\". port should be a valid port number as an Integer. HTTP.serve is the blocking server method, whereas HTTP.serve! is non-blocking and returns the listening HTTP.Server object that can be close(server)ed manually.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"Supported keyword arguments include:","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"sslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl  connections. Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl  verification (useful for testing). Construct a custom SSLConfig object  with MbedTLS.SSLConfig(certfile, keyfile).\ntcpisvalid = tcp->true, function f(::TCPSocket)::Bool to check if accepted  connections are valid before processing requests. e.g. to do source IP filtering.\nreadtimeout::Int=0, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple servers to listen on the same port.  Not supported on some OS platforms. Can check HTTP.Servers.supportsreuseaddr().\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows manually closing or configuring the server socket.\nverbose::Bool=false, log connection information to stdout.\naccess_log::Function, function for formatting access log messages. The  function should accept two arguments, io::IO to which the messages should  be written, and http::HTTP.Stream which can be used to query information  from. See also @logfmt_str.\non_shutdown::Union{Function, Vector{<:Function}, Nothing}=nothing, one or  more functions to be run if the server is closed (for example by an  InterruptException). Note, shutdown function(s) will not run if an  IOServer object is supplied to the server keyword argument and closed  by close(server).","category":"page"},{"location":"server/#HTTP.Handler","page":"Server","title":"HTTP.Handler","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"Abstract type for the handler interface that exists for documentation purposes. A Handler is any function of the form f(req::HTTP.Request) -> HTTP.Response. There is no requirement to subtype Handler and users should not rely on or dispatch on Handler. A Handler function f can be passed to HTTP.serve wherein a server will pass each incoming request to f to be handled and a response to be returned. Handler functions are also the inputs to Middleware functions which are functions of the form f(::Handler) -> Handler, i.e. they take a Handler function as input, and return a \"modified\" or enhanced Handler function.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"For advanced cases, a Handler function can also be of the form f(stream::HTTP.Stream) -> Nothing. In this case, the server would be run like HTTP.serve(f, ...; stream=true). For this use-case, the handler function reads the request and writes the response to the stream directly. Note that any middleware used with a stream handler also needs to be of the form f(stream_handler) -> stream_handler, i.e. it needs to accept a stream Handler function and return a stream Handler function.","category":"page"},{"location":"server/#HTTP.Middleware","page":"Server","title":"HTTP.Middleware","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"Abstract type for the middleware interface that exists for documentation purposes. A Middleware is any function of the form f(::Handler) -> Handler (ref: Handler). There is no requirement to subtype Middleware and users should not rely on or dispatch on the Middleware type. While HTTP.serve(f, ...) requires a handler function f to be passed, middleware can be \"stacked\" to create a chain of functions that are called in sequence, like HTTP.serve(base_handler |> cookie_middleware |> auth_middlware, ...), where the base_handler Handler function is passed to cookie_middleware, which takes the handler and returns a \"modified\" handler (that parses and stores cookies). This \"modified\" handler is then an input to the auth_middlware, which further enhances/modifies the handler.","category":"page"},{"location":"server/#HTTP.Router","page":"Server","title":"HTTP.Router","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"Object part of the Handler framework for routing requests based on path matching registered routes.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"r = HTTP.Router(_404, _405)","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"Define a router object that maps incoming requests by path to registered routes and associated handlers. Paths can be registered using HTTP.register!. The router object itself is a \"request handler\" that can be called like:","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"r = HTTP.Router()\nresp = r(reqest)","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"Which will inspect the request, find the matching, registered handler from the url, and pass the request on to be handled further.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"See HTTP.register! for additional information on registering handlers based on routes.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"If a request doesn't have a matching, registered handler, the _404 handler is called which, by default, returns a HTTP.Response(404). If a route matches the path, but not the method/verb (e.g. there's a registerd route for \"GET /api\", but the request is \"POST /api\"), then the _405 handler is called, which by default returns HTTP.Response(405) (method not allowed).","category":"page"},{"location":"server/#HTTP.listen","page":"Server","title":"HTTP.listen","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"Lower-level core server functionality that only operates on HTTP.Stream. Provides a level of separation from HTTP.serve and the Handler framework. Supports all the same arguments and keyword arguments as HTTP.serve, but the handler function f must take a single HTTP.Stream as argument. HTTP.listen! is the non-blocking counterpart to HTTP.serve!.","category":"page"},{"location":"server/#Log-formatting","page":"Server","title":"Log formatting","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"Nginx-style log formatting is supported via the HTTP.@logfmt_str macro and can be passed via the access_log keyword argument for HTTP.listen or HTTP.serve.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"    # NOTE this file is autogenerated, do not edit examples.md directly. To make an example, upload the .jl file to the examples folder. Header comments may be included at the top of the file using \"\"\" syntax","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Some examples that may prove potentially useful for those using  HTTP.jl. The code for these examples can also be found on Github  in the docs/examples folder.","category":"page"},{"location":"examples/#Simple-Server","page":"Examples","title":"Simple Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a server with HTTP.jl. It handles creating, deleting,  updating, and retrieving Animals from a dictionary through 4 different routes","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON3, StructTypes, Sockets\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::Base.UUID\n    type::String\n    name::String\n    Animal() = new()\nend\n\nStructTypes.StructType(::Type{Animal}) = StructTypes.Mutable()\n\n# use a plain `Dict` as a \"data store\"\nconst ANIMALS = Dict{Int, Animal}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# \"service\" functions to actually do the work\nfunction createAnimal(req::HTTP.Request)\n    animal = JSON3.read(req.body, Animal)\n    animal.id = getNextId()\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction getAnimal(req::HTTP.Request)\n    animalId = HTTP.getparams(req)[\"id\"]\n    animal = ANIMALS[parse(Int, animalId)]\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = JSON3.read(req.body, Animal)\n    ANIMALS[animal.id] = animal\n    return HTTP.Response(200, JSON3.write(animal))\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    animalId = HTTP.getparams(req)[\"id\"]\n    delete!(ANIMALS, animalId)\n    return HTTP.Response(200)\nend\n\n# define REST endpoints to dispatch to \"service\" functions\nconst ANIMAL_ROUTER = HTTP.Router()\nHTTP.register!(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/animals\", createAnimal)\n# note the use of `*` to capture the path segment \"variable\" animal id\nHTTP.register!(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/animals/{id}\", getAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"PUT\", \"/api/zoo/v1/animals\", updateAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/animals/{id}\", deleteAnimal)\n\nserver = HTTP.serve!(ANIMAL_ROUTER, Sockets.localhost, 8080)\n\n# using our server\nx = Animal()\nx.type = \"cat\"\nx.name = \"pete\"\n# create 1st animal\nresp = HTTP.post(\"http://localhost:8080/api/zoo/v1/animals\", [], JSON3.write(x))\nx2 = JSON3.read(resp.body, Animal)\n# retrieve it back\nresp = HTTP.get(\"http://localhost:8080/api/zoo/v1/animals/$(x2.id)\")\nx3 = JSON3.read(resp.body, Animal)\n\n# close the server which will stop the HTTP server from listening\nclose(server)\n@assert istaskdone(server.task)\n","category":"page"},{"location":"examples/#Cors-Server","page":"Examples","title":"Cors Server","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Server example that takes after the simple server, however, handles dealing with CORS preflight headers when dealing with more than just a simple request. For CORS details, see e.g. https://cors-errors.info/","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"\nusing HTTP, JSON3, StructTypes, Sockets, UUIDs\n\n# modified Animal struct to associate with specific user\nmutable struct Animal\n    id::Int\n    userId::UUID\n    type::String\n    name::String\n    Animal() = new()\nend\n\nStructTypes.StructType(::Type{Animal}) = StructTypes.Mutable()\n\n# use a plain `Dict` as a \"data store\", outer Dict maps userId to user-specific Animals\nconst ANIMALS = Dict{UUID, Dict{Int, Animal}}()\nconst NEXT_ID = Ref(0)\nfunction getNextId()\n    id = NEXT_ID[]\n    NEXT_ID[] += 1\n    return id\nend\n\n# CORS preflight headers that show what kinds of complex requests are allowed to API\nconst CORS_OPT_HEADERS = [\n    \"Access-Control-Allow-Origin\" => \"*\",\n    \"Access-Control-Allow-Headers\" => \"*\",\n    \"Access-Control-Allow-Methods\" => \"POST, GET, OPTIONS\"\n]\n\n# CORS response headers that set access right of the recepient\nconst CORS_RES_HEADERS = [\"Access-Control-Allow-Origin\" => \"*\"]\n\n#= \nJSONMiddleware minimizes code by automatically converting the request body\nto JSON to pass to the other service functions automatically. JSONMiddleware\nrecieves the body of the response from the other service funtions and sends\nback a success response code\n=#\nfunction JSONMiddleware(handler)\n    # Middleware functions return *Handler* functions\n    return function(req::HTTP.Request)\n        # first check if there's any request body\n        if isempty(req.body)\n            # we slightly change the Handler interface here because we know\n            # our handler methods will either return nothing or an Animal instance\n            ret = handler(req)\n        else\n            # replace request body with parsed Animal instance\n            req.body = JSON3.read(req.body, Animal)\n            ret = handler(req)\n        end\n        # return a Response, if its a response already (from 404 and 405 handlers)\n        if ret isa HTTP.Response\n            return ret\n        else # otherwise serialize any Animal as json string and wrap it in Response\n            return HTTP.Response(200, CORS_RES_HEADERS, ret === nothing ? \"\" : JSON3.write(ret))\n        end\n    end\nend\n\n#= CorsMiddleware: handles preflight request with the OPTIONS flag\nIf a request was recieved with the correct headers, then a response will be \nsent back with a 200 code, if the correct headers were not specified in the request,\nthen a CORS error will be recieved on the client side\n\nSince each request passes throught the CORS Handler, then if the request is \nnot a preflight request, it will simply go to the JSONMiddleware to be passed to the\ncorrect service function =#\nfunction CorsMiddleware(handler)\n    return function(req::HTTP.Request)\n        if HTTP.hasheader(req, \"OPTIONS\")\n            return HTTP.Response(200, CORS_OPT_HEADERS)\n        else \n            return handler(req)\n        end\n    end\nend\n\n# **simplified** \"service\" functions\nfunction createAnimal(req::HTTP.Request)\n    animal = req.body\n    animal.id = getNextId()\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction getAnimal(req::HTTP.Request)\n    # retrieve our matched path parameters from registered route\n    animalId = parse(Int, HTTP.getparams(req)[\"id\"])\n    userId = UUID(HTTP.getparams(req)[\"userId\"])\n    return ANIMALS[userId][animalId]\nend\n\nfunction updateAnimal(req::HTTP.Request)\n    animal = req.body\n    ANIMALS[animal.userId][animal.id] = animal\n    return animal\nend\n\nfunction deleteAnimal(req::HTTP.Request)\n    # retrieve our matched path parameters from registered route\n    animalId = parse(Int, HTTP.getparams(req)[\"id\"])\n    userId = UUID(HTTP.getparams(req)[\"userId\"])\n    delete!(ANIMALS[userId], animal.id)\n    return nothing\nend\n\nfunction createUser(req::HTTP.Request)\n    userId = uuid4()\n    ANIMALS[userId] = Dict{Int, Animal}()\n    return userId\nend\n\n# CORS handlers for error responses\ncors404(::HTTP.Request) = HTTP.Response(404, CORS_RES_HEADERS, \"\")\ncors405(::HTTP.Request) = HTTP.Response(405, CORS_RES_HEADERS, \"\")\n\n# add an additional endpoint for user creation\nconst ANIMAL_ROUTER = HTTP.Router(cors404, cors405)\nHTTP.register!(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users\", createUser)\n# modify service endpoints to have user pass UUID in\nHTTP.register!(ANIMAL_ROUTER, \"POST\", \"/api/zoo/v1/users/{userId}/animals\", createAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"GET\", \"/api/zoo/v1/users/{userId}/animals/{id}\", getAnimal)\nHTTP.register!(ANIMAL_ROUTER, \"DELETE\", \"/api/zoo/v1/users/{userId}/animals/{id}\", deleteAnimal)\n\nserver = HTTP.serve!(ANIMAL_ROUTER |> JSONMiddleware |> CorsMiddleware, Sockets.localhost, 8080)\n\n# using our server\nresp = HTTP.post(\"http://localhost:8080/api/zoo/v1/users\")\nuserId = JSON3.read(resp.body, UUID)\nx = Animal()\nx.userId = userId\nx.type = \"cat\"\nx.name = \"pete\"\n# create 1st animal\nresp = HTTP.post(\"http://localhost:8080/api/zoo/v1/users/$(userId)/animals\", [], JSON3.write(x))\nx2 = JSON3.read(resp.body, Animal)\n# retrieve it back\nresp = HTTP.get(\"http://localhost:8080/api/zoo/v1/users/$(userId)/animals/$(x2.id)\")\nx3 = JSON3.read(resp.body, Animal)\n# try bad path\nresp = HTTP.get(\"http://localhost:8080/api/zoo/v1/badpath\")\n\n# close the server which will stop the HTTP server from listening\nclose(server)\n@assert istaskdone(server.task)\n","category":"page"},{"location":"examples/#Server-Sent-Events","page":"Examples","title":"Server Sent Events","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server that implements server-sent events, loosely following this tutorial.","category":"page"},{"location":"examples/#Example-client-code-(JS):","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Server-sent events demo</title>\n</head>\n<body>\n    <h3>Fetched items:</h3>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    const evtSource = new EventSource(\"http://127.0.0.1:8080/api/events\")\n    evtSource.onmessage = async function (event) {\n        const newElement = document.createElement(\"li\");\n        const eventList = document.getElementById(\"list\");\n        if (parseFloat(event.data) > 0.5) {\n            const r = await fetch(\"http://127.0.0.1:8080/api/getItems\")\n            if (r.ok) {\n                const body = await r.json()\n                newElement.textContent = body;\n                eventList.appendChild(newElement);\n            }\n        }\n    }\n    evtSource.addEventListener(\"ping\", function(event) {\n        console.log('ping:', event.data)\n    });\n</script>\n</html>","category":"page"},{"location":"examples/#Example-client-code-(Julia)","page":"Examples","title":"Example client code (Julia)","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, JSON\n\nHTTP.open(\"GET\", \"http://127.0.0.1:8080/api/events\") do io\n    while !eof(io)\n        println(String(readavailable(io)))\n    end\nend","category":"page"},{"location":"examples/#Server-code:","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP, Sockets, JSON\n\nconst ROUTER = HTTP.Router()\n\nfunction getItems(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\"\n    ]\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    return HTTP.Response(200, headers, JSON.json(rand(2)))\nend\n\nfunction events(stream::HTTP.Stream)\n    HTTP.setheader(stream, \"Access-Control-Allow-Origin\" => \"*\")\n    HTTP.setheader(stream, \"Access-Control-Allow-Methods\" => \"GET, OPTIONS\")\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n\n    if HTTP.method(stream.message) == \"OPTIONS\"\n        return nothing\n    end\n\n    HTTP.setheader(stream, \"Content-Type\" => \"text/event-stream\")\n    HTTP.setheader(stream, \"Cache-Control\" => \"no-cache\")\n    while true\n        write(stream, \"event: ping\\ndata: $(round(Int, time()))\\n\\n\")\n        if rand(Bool)\n            write(stream, \"data: $(rand())\\n\\n\")\n        end\n        sleep(1)\n    end\n    return nothing\nend\n\nHTTP.register!(ROUTER, \"GET\", \"/api/getItems\", HTTP.streamhandler(getItems))\nHTTP.register!(ROUTER, \"/api/events\", events)\n\nserver = HTTP.serve!(ROUTER, \"127.0.0.1\", 8080; stream=true)\n\n# Julia usage\nresp = HTTP.get(\"http://localhost:8080/api/getItems\")\n\nclose = Ref(false)\n@async HTTP.open(\"GET\", \"http://127.0.0.1:8080/api/events\") do io\n    while !eof(io) && !close[]\n        println(String(readavailable(io)))\n    end\nend\n\n# run the following to stop the streaming client request\nclose[] = true\n\n# close the server which will stop the HTTP server from listening\nclose(server)\n@assert istaskdone(server.task)\n","category":"page"},{"location":"examples/#Session","page":"Examples","title":"Session","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"A simple example of creating a persistent session and logging into a web form. HTTP.jl does not have a distinct session object like requests.session() or rvest::html_session() but rather uses the cookies flag along with standard functions","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\n#dummy site, any credentials work\nurl = \"http://quotes.toscrape.com/login\"\nsession = HTTP.get(url; cookies = true)\n\ncredentials = Dict(\n    \"Username\" => \"username\",\n    \"Password\" => \"password\")\n\nresponse = HTTP.post(url, credentials)\n","category":"page"},{"location":"examples/#Squaring-Server-Client","page":"Examples","title":"Squaring Server Client","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Simple server in Julia and client code in JS.","category":"page"},{"location":"examples/#Example-client-code-(JS):-2","page":"Examples","title":"Example client code (JS):","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Squaring numbers</title>\n</head>\n<body>\n    <input id=\"number\" placeholder=\"Input a number\" type=\"number\">\n    <button id=\"submit\">Square</button>\n    <h4>Outputs</h4>\n    <ul id=\"list\"></ul>\n</body>\n<script>\n    document.getElementById('submit').addEventListener('click', async function (event) {\n        const list = document.getElementById('list');\n        try {\n            const r = await fetch('http://127.0.0.1:8080/api/square', {\n                method: 'POST',\n                body: document.getElementById('number').value\n            });\n\n            if (r.ok) {\n                const body = await r.text()\n                const newElement = document.createElement('li');\n                newElement.textContent = body;\n                list.insertBefore(newElement, list.firstChild);\n            } else {\n                console.error(r)\n            };\n        } catch (err) {\n            console.error(err)\n        }\n    })\n</script>\n</html>","category":"page"},{"location":"examples/#Server-code:-2","page":"Examples","title":"Server code:","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using HTTP\n\nconst ROUTER = HTTP.Router()\n\nfunction square(req::HTTP.Request)\n    headers = [\n        \"Access-Control-Allow-Origin\" => \"*\",\n        \"Access-Control-Allow-Methods\" => \"POST, OPTIONS\"\n    ]\n    # handle CORS requests\n    if HTTP.method(req) == \"OPTIONS\"\n        return HTTP.Response(200, headers)\n    end\n    body = parse(Float64, String(req.body))\n    square = body^2\n    HTTP.Response(200, headers, string(square))\nend\n\nHTTP.register!(ROUTER, \"POST\", \"/api/square\", square)\n\nserver = HTTP.serve!(ROUTER, Sockets.localhost, 8080)\n\n# usage\nresp = HTTP.post(\"http://localhost:8080/api/square\"; body=\"3\")\nsq = parse(Float64, String(resp.body))\n@assert sq == 9.0\n\n# close the server which will stop the HTTP server from listening\nclose(server)\n@assert istaskdone(server.task)\n","category":"page"},{"location":"examples/#Readme-Examples","page":"Examples","title":"Readme Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"#CLIENT\n\n#HTTP.request sends a HTTP Request Message and returns a Response Message.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nprintln(r.status) \nprintln(String(r.body)) \n\n#HTTP.open sends a HTTP Request Message and opens an IO stream from which the Response can be read.\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n#SERVERS\n\n#Using HTTP.Servers.listen:\n#The server will start listening on 127.0.0.1:8081 by default.\n\nusing HTTP\n\nHTTP.listen() do http::HTTP.Stream\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    HTTP.startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n\n#Using HTTP.Handlers.serve:\n\nusing HTTP\n\n# HTTP.listen! and HTTP.serve! are the non-blocking versions of HTTP.listen/HTTP.serve\nserver = HTTP.serve!() do request::HTTP.Request\n    @show request\n    @show request.method\n    @show HTTP.header(request, \"Content-Type\")\n    @show request.body\n    try\n        return HTTP.Response(\"Hello\")\n    catch e\n        return HTTP.Response(400, \"Error: $e\")\n    end\n end\n # HTTP.serve! returns an `HTTP.Server` object that we can close manually\n close(server)\n\n#WebSocket Examples\nusing HTTP.WebSockets\nserver = WebSockets.listen!(\"127.0.0.1\", 8081) do ws\n        for msg in ws\n            send(ws, msg)\n        end\n    end\n\nWebSockets.open(\"ws://127.0.0.1:8081\") do ws\n           send(ws, \"Hello\")\n           s = receive(ws)\n           println(s)\n       end;\nHello\n#Output: Hello\n\nclose(server)\n\n","category":"page"},{"location":"websockets/#WebSockets","page":"WebSockets","title":"WebSockets","text":"","category":"section"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"HTTP.jl provides a complete and well-tested websockets implementation via the WebSockets module. It is tested against the industry standard autobahn testsuite. The client and server usage are similar to their HTTP counterparts, but provide a WebSocket object that enables sending and receiving messages.","category":"page"},{"location":"websockets/#WebSocket-object","page":"WebSockets","title":"WebSocket object","text":"","category":"section"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"Both WebSockets.open (client) and WebSockets.listen (server) take a handler function that should accept a single WebSocket object argument. It has a small, simple API to provide full websocket functionality, including:","category":"page"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"receive(ws): blocking call to receive a single, non-control message from the remote. If ping/pong messages are received, they are handled/responded to automatically and a non-control message is waited for. If a CLOSE message is received, an error will be thrown. Returns either a String or Vector{UInt8} depending on whether the message had a TEXT or BINARY frame type. Fragmented messages are received fully before returning and the bodies of each frame are concatenated for a full, final message body.\nsend(ws, msg): sends a message to the remote. If msg is AbstractVector{UInt8}, the message will have the BINARY type, if AbstractString, it will have TEXT type. msg can also be an iterable of either AbstractVector{UInt8} or AbstractString and a fragmented message will be sent, with one fragment for each iterated element.\nclose(ws): initiate the close sequence of the websocket\nping(ws[, data]): send a PING message to the remote with optional data. PONG responses are received by calling receive(ws).\npong(ws[, data]): send a PONG message to the remote with optional data.\nfor msg in ws: for convenience, the WebSocket object supports the iteration protocol, which results in a call to receive(ws) to produce each iterated element. Iteration terminates when a non-error CLOSE message is received. This is the most common way to handle the life of a WebSocket, and looks like:","category":"page"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"# client\nWebSockets.open(url) do ws\n    for msg in ws\n        # do cool stuff with msg\n    end\nend\n\n# server\nWebSockets.listen(host, port) do ws\n    # iterate incoming websocket messages\n    for msg in ws\n        # send message back to client or do other logic here\n        send(ws, msg)\n    end\n    # iteration ends when the websocket connection is closed by client or error\nend","category":"page"},{"location":"websockets/#WebSocket-Client","page":"WebSockets","title":"WebSocket Client","text":"","category":"section"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"To initiate a websocket client connection, the WebSockets.open function is provided, which operates similar to HTTP.open, but the handler function should operate on a single WebSocket argument instead of an HTTP.Stream.","category":"page"},{"location":"websockets/#Example","page":"WebSockets","title":"Example","text":"","category":"section"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"# simple websocket client\nWebSockets.open(\"ws://websocket.org\") do ws\n    # we can iterate the websocket\n    # where each iteration yields a received message\n    # iteration finishes when the websocket is closed\n    for msg in ws\n        # do stuff with msg\n        # send back message as String, Vector{UInt8}, or iterable of either\n        send(ws, resp)\n    end\nend","category":"page"},{"location":"websockets/#WebSocket-Server","page":"WebSockets","title":"WebSocket Server","text":"","category":"section"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"To start a websocket server to listen for client connections, the WebSockets.listen function is provided, which mirrors the HTTP.listen function, but the provided handler should operate on a single WebSocket argument instead of an HTTP.Stream.","category":"page"},{"location":"websockets/#Example-2","page":"WebSockets","title":"Example","text":"","category":"section"},{"location":"websockets/","page":"WebSockets","title":"WebSockets","text":"# websocket server is very similar to client usage\nWebSockets.listen(\"0.0.0.0\", 8080) do ws\n    for msg in ws\n        # simple echo server\n        send(ws, msg)\n    end\nend","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"reference.md\"]\nDepth = 3","category":"page"},{"location":"reference/#Client-Requests","page":"API Reference","title":"Client Requests","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.request\nHTTP.get\nHTTP.put\nHTTP.post\nHTTP.head\nHTTP.patch\nHTTP.delete\nHTTP.open\nHTTP.download","category":"page"},{"location":"reference/#HTTP.request","page":"API Reference","title":"HTTP.request","text":"HTTP.request(method, url [, headers [, body]]; <keyword arguments>]) -> HTTP.Response\n\nSend a HTTP Request Message and receive a HTTP Response Message.\n\ne.g.\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nr = HTTP.get(\"http://httpbin.org/ip\") # equivalent shortcut\nprintln(r.status)\nprintln(String(r.body))\n\nheaders can be any collection where [string(k) => string(v) for (k,v) in headers] yields Vector{Pair}. e.g. a Dict(), a Vector{Tuple}, a Vector{Pair} or an iterator. By convention, if a header value is an empty string, it will not be written when sending a request (following the curl convention).\n\nbody can be a variety of objects:\n\na Dict or NamedTuple to be serialized as the \"application/x-www-form-urlencoded\" content type\nany AbstractString or AbstractVector{UInt8} which will be sent \"as is\" for the request body\na readable IO stream or any IO-like type T for which eof(T) and readavailable(T) are defined. This stream will be read and sent until eof is true. This object should support the mark/reset methods if request retires are desired (if not, no retries will be attempted).\nAny collection or iterable of the above (Dict, AbstractString, AbstractVector{UInt8}, or IO) which will result in a \"chunked\" request body, where each iterated element will be sent as a separate chunk\na HTTP.Form, which will be serialized as the \"multipart/form-data\" content-type\n\nThe HTTP.Response struct contains:\n\nstatus::Int16 e.g. 200\nheaders::Vector{Pair{String,String}}  e.g. [\"Server\" => \"Apache\", \"Content-Type\" => \"text/html\"]\nbody::Vector{UInt8} or ::IO, the Response Body bytes or the io argument  provided via the response_stream keyword argument\n\nFunctions HTTP.get, HTTP.put, HTTP.post and HTTP.head are defined as shorthand for HTTP.request(\"GET\", ...), etc.\n\nSupported optional keyword arguments:\n\nquery = nothing, a Pair or Dict of key => values to be included in the url\nresponse_stream = nothing, a writeable IO stream or any IO-like  type T for which write(T, AbstractVector{UInt8}) is defined. The response body  will be written to this stream instead of returned as a Vector{UInt8}.\nverbose = 0, set to 1 or 2 for increasingly verbose logging of the  request and response process\nconnect_timeout = 0, close the connection after this many seconds if it is still attempting to connect. Use connect_timeout = 0 to disable.\nconnection_limit = 8, number of concurrent connections allowed to each host:port.\nreadtimeout = 0, close the connection if no data is received for this many seconds. Use readtimeout = 0 to disable.\nstatus_exception = true, throw HTTP.StatusError for response status >= 300.\nBasic authentication is detected automatically from the provided url's userinfo (in the form scheme://user:password@host) and adds the Authorization: Basic header; this can be disabled by passing basicauth=false\ncanonicalize_headers = false, rewrite request and response headers in Canonical-Camel-Dash-Format.\nproxy = proxyurl, pass request through a proxy given as a url; alternatively, the http_proxy, HTTP_PROXY, https_proxy, HTTPS_PROXY, and no_proxy environment variables are also detected/used; if set, they will be used automatically when making requests.\ndetect_content_type = false: if true and the request body is not a form or IO, it will be  inspected and the \"Content-Type\" header will be set to the detected content type.\ndecompress = nothing, by default, decompress the response body if the response has a  \"Content-Encoding\" header set to \"gzip\". If decompress=true, decompress the response body  regardless of Content-Encoding header. If decompress=false, do not decompress the response body.\n\nRetry arguments:\n\nretry = true, retry idempotent requests in case of error.\nretries = 4, number of times to retry.\nretry_non_idempotent = false, retry non-idempotent requests too. e.g. POST.\n\nRedirect arguments:\n\nredirect = true, follow 3xx redirect responses; i.e. additional requests will be made to the redirected location\nredirect_limit = 3, maximum number of times a redirect will be followed\nredirect_method = nothing, the method to use for the redirected request; by default,  GET will be used, only responses with 307/308 will use the same original request method.  Pass redirect_method=:same to pass the same method as the orginal request though note that some servers  may not respond/accept the same method. It's also valid to pass the exact method to use  as a string, like redirect_method=\"PUT\".\nforwardheaders = true, forward original headers on redirect.\n\nSSL arguments:\n\nrequire_ssl_verification = NetworkOptions.verify_host(host), pass MBEDTLS_SSL_VERIFY_REQUIRED to the mbed TLS library. \"... peer must present a valid certificate, handshake is aborted if   verification failed.\"\nsslconfig = SSLConfig(require_ssl_verification)\nsocket_type_tls = MbedTLS.SSLContext, the type of socket to use for TLS connections. Defaults to MbedTLS.SSLContext.  Also supported is passing socket_type_tls = OpenSSL.SSLStream. To change the global default, set HTTP.SOCKET_TYPE_TLS[] = OpenSSL.SSLStream.\n\nCookie arguments:\n\ncookies::Union{Bool, Dict{<:AbstractString, <:AbstractString}} = true, enable cookies, or alternatively,      pass a Dict{AbstractString, AbstractString} of name-value pairs to manually pass cookies in the request \"Cookie\" header\ncookiejar::HTTP.CookieJar=HTTP.COOKIEJAR: threadsafe cookie jar struct for keeping track of cookies per host;  a global cookie jar is used by default.\n\nRequest Body Examples\n\nString body:\n\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], \"post body data\")\n\nStream body from file:\n\nio = open(\"post_data.txt\", \"r\")\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], io)\n\nGenerator body:\n\nchunks = (\"chunk$i\" for i in 1:1000)\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nCollection body:\n\nchunks = [preamble_chunk, data_chunk, checksum(data_chunk)]\nHTTP.request(\"POST\", \"http://httpbin.org/post\", [], chunks)\n\nopen() do io body:\n\nHTTP.open(\"POST\", \"http://httpbin.org/post\") do io\n    write(io, preamble_chunk)\n    write(io, data_chunk)\n    write(io, checksum(data_chunk))\nend\n\nResponse Body Examples\n\nString body:\n\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\")\nprintln(String(r.body))\n\nStream body to file:\n\nio = open(\"get_data.txt\", \"w\")\nr = HTTP.request(\"GET\", \"http://httpbin.org/get\", response_stream=io)\nclose(io)\nprintln(read(\"get_data.txt\"))\n\nStream body through buffer:\n\nr = HTTP.get(\"http://httpbin.org/get\", response_stream=IOBuffer())\nprintln(String(take!(r.body)))\n\nStream body through open() do io:\n\nr = HTTP.open(\"GET\", \"http://httpbin.org/stream/10\") do io\n   while !eof(io)\n       println(String(readavailable(io)))\n   end\nend\n\nHTTP.open(\"GET\", \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    n = 0\n    r = startread(http)\n    l = parse(Int, HTTP.header(r, \"Content-Length\"))\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        while !eof(http)\n            bytes = readavailable(http)\n            write(vlc, bytes)\n            n += length(bytes)\n            println(\"streamed $n-bytes $((100*n)l)%\\u1b[1A\")\n        end\n    end\nend\n\nInterfacing with RESTful JSON APIs:\n\nusing JSON\nparams = Dict(\"user\"=>\"RAO...tjN\", \"token\"=>\"NzU...Wnp\", \"message\"=>\"Hello!\")\nurl = \"http://api.domain.com/1/messages.json\"\nr = HTTP.post(url, body=JSON.json(params))\nprintln(JSON.parse(String(r.body)))\n\nStream bodies from and to files:\n\nin = open(\"foo.png\", \"r\")\nout = open(\"foo.jpg\", \"w\")\nHTTP.request(\"POST\", \"http://convert.com/png2jpg\", [], in, response_stream=out)\n\nStream bodies through: open() do io:\n\nHTTP.open(\"POST\", \"http://music.com/play\") do io\n    write(io, JSON.json([\n        \"auth\" => \"12345XXXX\",\n        \"song_id\" => 7,\n    ]))\n    r = startread(io)\n    @show r.status\n    while !eof(io)\n        bytes = readavailable(io)\n        play_audio(bytes)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.get","page":"API Reference","title":"HTTP.get","text":"HTTP.get(url [, headers]; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"GET\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.put","page":"API Reference","title":"HTTP.put","text":"HTTP.put(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"PUT\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.post","page":"API Reference","title":"HTTP.post","text":"HTTP.post(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"POST\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.head","page":"API Reference","title":"HTTP.head","text":"HTTP.head(url; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"HEAD\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.patch","page":"API Reference","title":"HTTP.patch","text":"HTTP.patch(url, headers, body; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"PATCH\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.delete","page":"API Reference","title":"HTTP.delete","text":"HTTP.delete(url [, headers]; <keyword arguments>) -> HTTP.Response\n\nShorthand for HTTP.request(\"DELETE\", ...). See HTTP.request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.open","page":"API Reference","title":"HTTP.open","text":"WebSockets.open(handler, url; verbose=false, kw...)\n\nInitiate a websocket connection to url (which should have schema like ws:// or wss://), and call handler(ws) with the websocket connection. Passing verbose=true or verbose=2 will enable debug logging for the life of the websocket connection. handler should be a function of the form f(ws) -> nothing, where ws is a WebSocket. Supported keyword arguments are the same as supported by HTTP.request. Typical websocket usage is:\n\nWebSockets.open(url) do ws\n    # iterate incoming websocket messages\n    for msg in ws\n        # send message back to server or do other logic here\n        send(ws, msg)\n    end\n    # iteration ends when the websocket connection is closed by server or error\nend\n\n\n\n\n\nHTTP.open(method, url, [,headers]) do io\n    write(io, body)\n    [startread(io) -> HTTP.Response]\n    while !eof(io)\n        readavailable(io) -> AbstractVector{UInt8}\n    end\nend -> HTTP.Response\n\nThe HTTP.open API allows the request body to be written to (and/or the response body to be read from) an IO stream.\n\ne.g. Streaming an audio file to the vlc player:\n\nHTTP.open(:GET, \"https://tinyurl.com/bach-cello-suite-1-ogg\") do http\n    open(`vlc -q --play-and-exit --intf dummy -`, \"w\") do vlc\n        write(vlc, http)\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.download","page":"API Reference","title":"HTTP.download","text":"download(url, [local_path], [headers]; update_period=1, kw...)\n\nSimilar to Base.download this downloads a file, returning the filename. If the local_path:\n\nis not provided, then it is saved in a temporary directory\nif part to a directory is provided then it is saved into that directory\notherwise the local path is uses as the filename to save to.\n\nWhen saving into a directory, the filename is determined (where possible), from the rules of the HTTP.\n\nupdate_period controls how often (in seconds) to report the progress.\nset to Inf to disable reporting\nheaders specifies headers to be used for the HTTP GET request\nany additional keyword args (kw...) are passed on to the HTTP request.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Request/Response-Objects","page":"API Reference","title":"Request/Response Objects","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Request\nHTTP.Response\nHTTP.Stream\nHTTP.WebSockets.WebSocket\nHTTP.Messages.header\nHTTP.Messages.headers\nHTTP.Messages.hasheader\nHTTP.Messages.headercontains\nHTTP.Messages.setheader\nHTTP.Messages.appendheader\nHTTP.Messages.removeheader\nHTTP.Messages.decode","category":"page"},{"location":"reference/#HTTP.Messages.Request","page":"API Reference","title":"HTTP.Messages.Request","text":"HTTP.Request(method, target, headers=[], body=nobody;\n    version=v\"1.1\", url::URI=URI(), responsebody=nothing, parent=nothing, context=HTTP.Context())\n\nRepresents a HTTP Request Message with fields:\n\nmethod::String  RFC7230 3.1.1\ntarget::String  RFC7230 5.3\nversion::VersionNumber  RFC7230 2.6\nheaders::HTTP.Headers  RFC7230 3.2\nbody::Union{Vector{UInt8}, IO}  RFC7230 3.3\nresponse, the Response to this Request\nurl::URI, the full URI of the request\nparent, the Response (if any) that led to this request (e.g. in the case of a redirect).  RFC7230 6.4\ncontext, a Dict{Symbol, Any} store used by middleware to share state\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Messages.Response","page":"API Reference","title":"HTTP.Messages.Response","text":"HTTP.Response(status, headers::HTTP.Headers, body; request=nothing)\nHTTP.Response(status, body)\nHTTP.Response(body)\n\nRepresents an HTTP response message with fields:\n\nversion::VersionNumber  RFC7230 2.6\nstatus::Int16  RFC7230 3.1.2  RFC7231 6\nheaders::Vector{Pair{String,String}}  RFC7230 3.2\nbody::Vector{UInt8} or body::IO  RFC7230 3.3\nrequest, the Request that yielded this Response.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Streams.Stream","page":"API Reference","title":"HTTP.Streams.Stream","text":"Stream(::Request, ::IO)\n\nCreates a HTTP.Stream that wraps an existing IO stream.\n\nstartwrite(::Stream) sends the Request headers to the IO stream.\nwrite(::Stream, body) sends the body (or a chunk of the body).\nclosewrite(::Stream) sends the final 0 chunk (if needed) and calls closewrite on the IO stream.\nstartread(::Stream) calls startread on the IO stream then  reads and parses the Response headers.\neof(::Stream) and readavailable(::Stream) parse the body from the IO  stream.\ncloseread(::Stream) reads the trailers and calls closeread on the IO  stream.  When the IO stream is a HTTP.ConnectionPool.Connection,  calling closeread releases the connection back to the connection pool  for reuse. If a complete response has not been received, closeread throws  EOFError.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.WebSockets.WebSocket","page":"API Reference","title":"HTTP.WebSockets.WebSocket","text":"WebSocket(io::HTTP.Connection, req, resp; client=true)\n\nRepresentation of a websocket connection. Use WebSockets.open to open a websocket connection, passing a handler function f(ws) to send and receive messages. Use WebSockets.listen to listen for incoming websocket connections, passing a handler function f(ws) to send and receive messages.\n\nCall send(ws, msg) to send a message; if msg is an AbstractString, a TEXT websocket message will be sent; if msg is an AbstractVector{UInt8}, a BINARY websocket message will be sent. Otherwise, msg should be an iterable of either AbstractString or AbstractVector{UInt8}, and a fragmented message will be sent, one frame for each iterated element.\n\nControl frames can be sent by calling ping(ws[, data]), pong(ws[, data]), or close(ws[, body::WebSockets.CloseFrameBody]). Calling close will initiate the close sequence and close the underlying connection.\n\nTo receive messages, call receive(ws), which will block until a non-control, full message is received. PING messages will automatically be responded to when received. CLOSE messages will also be acknowledged and then a WebSocketError will be thrown with the WebSockets.CloseFrameBody payload, which may include a non-error CLOSE frame status code. WebSockets.isok(err) can be called to check if the CLOSE was normal or unexpected. Fragmented messages will be received until the final frame is received and the full concatenated payload can be returned. receive(ws) returns a Vector{UInt8} for BINARY messages, and a String for TEXT messages.\n\nFor convenience, WebSockets support the iteration protocol, where each iteration will receive a non-control message, with iteration terminating when the connection is closed. E.g.:\n\nWebSockets.open(url) do ws\n    for msg in ws\n        # do cool stuff with msg\n    end\nend\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Messages.header","page":"API Reference","title":"HTTP.Messages.header","text":"HTTP.header(::Message, key [, default=\"\"]) -> String\n\nGet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.headers","page":"API Reference","title":"HTTP.Messages.headers","text":"HTTP.headers(m::Message, key) -> Vector{String}\n\nGet all headers with key k or empty if none\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.hasheader","page":"API Reference","title":"HTTP.Messages.hasheader","text":"HTTP.hasheader(::Message, key) -> Bool\n\nDoes header value for key exist (case-insensitive)?\n\n\n\n\n\nHTTP.hasheader(::Message, key, value) -> Bool\n\nDoes header for key match value (both case-insensitive)?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.headercontains","page":"API Reference","title":"HTTP.Messages.headercontains","text":"HTTP.headercontains(::Message, key, value) -> Bool\n\nDoes the header for key (interpreted as comma-separated list) contain value (both case-insensitive)?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.setheader","page":"API Reference","title":"HTTP.Messages.setheader","text":"HTTP.setheader(::Message, key => value)\n\nSet header value for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.appendheader","page":"API Reference","title":"HTTP.Messages.appendheader","text":"HTTP.appendheader(::Message, key => value)\n\nAppend a header value to message.headers.\n\nIf key is the same as the previous header, the value is appended to the value of the previous header with a comma delimiter\n\nSet-Cookie headers are not comma-combined because cookies often contain internal commas.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.removeheader","page":"API Reference","title":"HTTP.Messages.removeheader","text":"HTTP.removeheader(::Message, key)\n\nRemove header for key (case-insensitive).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.decode","page":"API Reference","title":"HTTP.Messages.decode","text":"HTTP.decode(r::Union{Request, Response}) -> Vector{UInt8}\n\nFor a gzip encoded request/response body, decompress it and return the decompressed body.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Request-body-types","page":"API Reference","title":"Request body types","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Form\nHTTP.Multipart","category":"page"},{"location":"reference/#HTTP.Forms.Form","page":"API Reference","title":"HTTP.Forms.Form","text":"HTTP.Form(data; boundary=string(rand(UInt128), base=16))\n\nConstruct a request body for multipart/form-data encoding from data.\n\ndata must iterate key-value pairs (e.g. Dict or Vector{Pair}) where the key/value of the iterator is the key/value of each mutipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an IOStream such as returned via open(file), or an IOBuffer for in-memory data.\n\nFor complete control over a multipart chunk's details, an HTTP.Multipart type is provided to support setting the filename, Content-Type, and Content-Transfer-Encoding.\n\nExamples\n\ndata = Dict(\n    \"text\" => \"text data\",\n    # filename (cat.png) and content-type (image/png) inferred from the IOStream\n    \"file1\" => open(\"cat.png\"),\n    # manully controlled chunk\n    \"file2\" => HTTP.Multipart(\"dog.jpeg\", open(\"mydog.jpg\"), \"image/jpeg\"),\n)\nbody = HTTP.Form(data)\nheaders = []\nHTTP.post(url, headers, body)\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Forms.Multipart","page":"API Reference","title":"HTTP.Forms.Multipart","text":"HTTP.Multipart(filename::String, data::IO, content_type=HTTP.sniff(data), content_transfer_encoding=\"\")\n\nA type to represent a single multipart upload chunk for a file. This type would be used as the value in a key-value pair when constructing a HTTP.Form for a request body (see example below). The data argument must be an IO type such as IOStream, or IOBuffer. The content_type and content_transfer_encoding arguments allow manual setting of these multipart headers. Content-Type will default to the result of the HTTP.sniff(data) mimetype detection algorithm, whereas Content-Transfer-Encoding will be left out if not specified.\n\nExamples\n\nbody = HTTP.Form(Dict(\n    \"key\" => HTTP.Multipart(\"File.txt\", open(\"MyFile.txt\"), \"text/plain\"),\n))\nheaders = []\nHTTP.post(url, headers, body)\n\nExtended help\n\nFilename SHOULD be included when the Multipart represents the contents of a file RFC7578 4.2\n\nContent-Disposition set to \"form-data\" MUST be included with each Multipart. An additional \"name\" parameter MUST be included An optional \"filename\" parameter SHOULD be included if the contents of a file are sent This will be formatted such as:   Content-Disposition: form-data; name=\"user\"; filename=\"myfile.txt\" RFC7578 4.2\n\nContent-Type for each Multipart is optional, but SHOULD be included if the contents of a file are sent. RFC7578 4.4\n\nContent-Transfer-Encoding for each Multipart is deprecated RFC7578 4.7\n\nOther Content- header fields MUST be ignored RFC7578 4.8\n\n\n\n\n\n","category":"type"},{"location":"reference/#Request-exceptions","page":"API Reference","title":"Request exceptions","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Request functions may throw the following exceptions:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.ConnectError\nHTTP.TimeoutError\nHTTP.StatusError\nHTTP.RequestError","category":"page"},{"location":"reference/#HTTP.Exceptions.ConnectError","page":"API Reference","title":"HTTP.Exceptions.ConnectError","text":"HTTP.ConnectError\n\nRaised when an error occurs while trying to establish a request connection to the remote server. To see the underlying error, see the error field.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Exceptions.TimeoutError","page":"API Reference","title":"HTTP.Exceptions.TimeoutError","text":"HTTP.TimeoutError\n\nRaised when a request times out according to readtimeout keyword argument provided.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Exceptions.StatusError","page":"API Reference","title":"HTTP.Exceptions.StatusError","text":"HTTP.StatusError\n\nRaised when an HTTP.Response has a 4xx, 5xx or unrecognised status code.\n\nFields:\n\nstatus::Int16, the response status code.\nmethod::String, the request method.\ntarget::String, the request target.\nresponse, the HTTP.Response\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Exceptions.RequestError","page":"API Reference","title":"HTTP.Exceptions.RequestError","text":"HTTP.RequestError\n\nRaised when an error occurs while physically sending a request to the remote server or reading the response back. To see the underlying error, see the error field.\n\n\n\n\n\n","category":"type"},{"location":"reference/#URIs","page":"API Reference","title":"URIs","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.jl uses the URIs.jl package for handling URIs. Some functionality from URIs.jl, relevant to HTTP.jl, are listed below:","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"URI\nURIs.escapeuri\nURIs.unescapeuri\nURIs.splitpath\nBase.isvalid(::URIs.URI)","category":"page"},{"location":"reference/#URIs.URI","page":"API Reference","title":"URIs.URI","text":"URI(; scheme=\"\", host=\"\", port=\"\", etc...)\nURI(str) = parse(URI, str::String)\n\nA type representing a URI (e.g. a URL). Can be constructed from distinct parts using the various supported keyword arguments, or from a string. The URI constructors will automatically escape any provided query arguments, typically provided as \"key\"=>\"value\"::Pair or Dict(\"key\"=>\"value\"). Note that multiple values for a single query key can provided like Dict(\"key\"=>[\"value1\", \"value2\"]).\n\nWhen constructing a URI from a String, you need to first unescape that string: URI( URIs.unescapeuri(str) ).\n\nThe URI struct stores the complete URI in the uri::String field and the component parts in the following SubString fields:\n\nscheme, e.g. \"http\" or \"https\"\nuserinfo, e.g. \"username:password\"\nhost e.g. \"julialang.org\"\nport e.g. \"80\" or \"\"\npath e.g \"/\"\nquery e.g. \"Foo=1&Bar=2\"\nfragment\n\nThe queryparams(::URI) function returns a Dict containing the query.\n\n\n\n\n\n","category":"type"},{"location":"reference/#URIs.escapeuri","page":"API Reference","title":"URIs.escapeuri","text":"escapeuri(x)\n\nApply URI percent-encoding to escape special characters in x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#URIs.unescapeuri","page":"API Reference","title":"URIs.unescapeuri","text":"unescapeuri(str)\n\nPercent-decode a string according to the URI escaping rules.\n\n\n\n\n\n","category":"function"},{"location":"reference/#URIs.splitpath","page":"API Reference","title":"URIs.splitpath","text":"URIs.splitpath(path|uri; rstrip_empty_segment=true)\n\nSplits the path into component segments based on /, according to http://tools.ietf.org/html/rfc3986#section-3.3. Any fragment and query parts of the string are ignored if present.\n\nA final empty path segment (trailing '/') is removed, if present. This is technically incompatible with the segment grammar of RFC3986, but it seems to be a common recommendation to make paths with and without a trailing slash equivalent. To preserve any final empty path segment, set rstrip_empty_segment=false.\n\nExamples\n\njulia> URIs.splitpath(URI(\"http://example.com/foo/bar?a=b&c=d\"))\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\njulia> URIs.splitpath(\"/foo/bar/\")\n2-element Array{String,1}:\n \"foo\"\n \"bar\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.isvalid-Tuple{URI}","page":"API Reference","title":"Base.isvalid","text":"checks if a URI is valid\n\n\n\n\n\n","category":"method"},{"location":"reference/#Cookies","page":"API Reference","title":"Cookies","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Cookie\nHTTP.Cookies.stringify\nHTTP.Cookies.addcookie!\nHTTP.Cookies.cookies","category":"page"},{"location":"reference/#HTTP.Cookies.Cookie","page":"API Reference","title":"HTTP.Cookies.Cookie","text":"Cookie()\nCookie(; kwargs...)\nCookie(name, value; kwargs...)\n\nA Cookie represents an HTTP cookie as sent in the \"Set-Cookie\" header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:\n\nname::String: name of the cookie\nvalue::String: value of the cookie\npath::String: applicable path for the cookie\ndomain::String: applicable domain for the cookie\nexpires::Dates.DateTime: when the cookie should expire\nmaxage::Int: maxage == 0 means no max age, maxage < 0 means delete cookie now, maxage > 0 means the # of seconds until expiration\nsecure::Bool: secure cookie attribute\nhttponly::Bool: httponly cookie attribute\nhostonly::Bool: hostonly cookie attribute\nsamesite::Bool: SameSite cookie attribute\n\nSee IETF RFC 6265 for details.\n\nThe string representation of a cookie is generated by calling stringify(cookie; isrequest=true), where isrequest=true will only include the name=value pair for requests, and if false, will generate the \"Set-Cookie\" representation for a response header.\n\nA Vector{Cookie} can be retrieved from a Request/Response object by calling Cookies.cookies(r).\n\nA Cookie can be added to a Request/Response object by calling Cookies.addcookie!(r, cookie).\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Cookies.stringify","page":"API Reference","title":"HTTP.Cookies.stringify","text":"stringify(cookie::Cookie, isrequest=true)\n\nGenerate the string representation of a cookie. By default, isrequest=true, and only the name=value pair will be included in the cookie string. For isrequest=false, the other cookie attributes will be included, ;-separated, for use in a \"Set-Cookie\" header.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Cookies.addcookie!","page":"API Reference","title":"HTTP.Cookies.addcookie!","text":"Cookies.addcookie!(r::Union{HTTP.Request, HTTP.Response}, c::Cookie)\n\nConvenience function for adding a single cookie to a request or response object. For requests, the cookie will be stringified and concatenated to any existing \"Cookie\" header. For responses, an additional \"Set-Cookie\" header will be appended.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Cookies.cookies","page":"API Reference","title":"HTTP.Cookies.cookies","text":"HTTP.cookies(r::Union{Request, Response}) -> Vector{Cookie}\n\nReturn a list of cookies, if any, parsed from the request \"Cookie\" or response \"Set-Cookie\" headers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#WebSockets","page":"API Reference","title":"WebSockets","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.WebSockets.send(::HTTP.WebSockets.WebSocket, msg)\nHTTP.WebSockets.receive\nHTTP.WebSockets.close(::HTTP.WebSockets.WebSocket, body)\nHTTP.WebSockets.ping\nHTTP.WebSockets.pong\nHTTP.WebSockets.iterate(::HTTP.WebSockets.WebSocket, st)\nHTTP.WebSockets.isclosed\nHTTP.WebSockets.isok","category":"page"},{"location":"reference/#Sockets.send-Tuple{HTTP.WebSockets.WebSocket, Any}","page":"API Reference","title":"Sockets.send","text":"send(ws::WebSocket, msg)\n\nSend a message on a websocket connection. If msg is an AbstractString, a TEXT websocket message will be sent; if msg is an AbstractVector{UInt8}, a BINARY websocket message will be sent. Otherwise, msg should be an iterable of either AbstractString or AbstractVector{UInt8}, and a fragmented message will be sent, one frame for each iterated element.\n\nControl frames can be sent by calling ping(ws[, data]), pong(ws[, data]), or close(ws[, body::WebSockets.CloseFrameBody]). Calling close will initiate the close sequence and close the underlying connection.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HTTP.WebSockets.receive","page":"API Reference","title":"HTTP.WebSockets.receive","text":"receive(ws::WebSocket) -> Union{String, Vector{UInt8}}\n\nReceive a message from a websocket connection. Returns a String if the message was TEXT, or a Vector{UInt8} if the message was BINARY. If control frames (ping or pong) are received, they are handled automatically and a non-control message is waited for. If a CLOSE message is received, it is responded to and a WebSocketError is thrown with the WebSockets.CloseFrameBody as the error value. This error can be checked with WebSockets.isok(err) to see if the closing was \"normal\" or if an actual error occurred. For fragmented messages, the incoming frames will continue to be read until the final fragment is received. The bodies of each fragment are concatenated into the final message returned by receive. Note that WebSocket objects can be iterated, where each iteration yields a message until the connection is closed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.ping","page":"API Reference","title":"HTTP.WebSockets.ping","text":"ping(ws, data=[])\n\nSend a PING control frame on a websocket connection. data is an optional body to send with the message. PONG messages are automatically responded to when a PING message is received by a websocket connection.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.pong","page":"API Reference","title":"HTTP.WebSockets.pong","text":"pong(ws, data=[])\n\nSend a PONG control frame on a websocket connection. data is an optional body to send with the message. Note that PING messages are automatically responded to internally by the websocket connection with a corresponding PONG message, but in certain cases, a unidirectional PONG message can be used as a one-way heartbeat.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.iterate-Tuple{HTTP.WebSockets.WebSocket, Any}","page":"API Reference","title":"Base.iterate","text":"iterate(ws)\n\nContinuously call receive(ws) on a WebSocket connection, with each iteration yielding a message until the connection is closed. E.g.\n\nfor msg in ws\n    # do something with msg\nend\n\n\n\n\n\n","category":"method"},{"location":"reference/#HTTP.WebSockets.isclosed","page":"API Reference","title":"HTTP.WebSockets.isclosed","text":"WebSockets.isclosed(ws) -> Bool\n\nCheck whether a WebSocket has sent and received CLOSE frames.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.isok","page":"API Reference","title":"HTTP.WebSockets.isok","text":"WebSockets.isok(x::WebSocketError) -> Bool\n\nReturns true if the WebSocketError has a non-error status code. When calling receive(websocket), if a CLOSE frame is received, the CLOSE frame body is parsed and thrown inside the WebSocketError, but if the CLOSE frame has a non-error status code, it's safe to ignore the error and return from the WebSockets.open or WebSockets.listen calls without throwing.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Utilities","page":"API Reference","title":"Utilities","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.sniff\nHTTP.Strings.escapehtml\nHTTP.Strings.tocameldash\nHTTP.Strings.iso8859_1_to_utf8\nHTTP.Strings.ascii_lc_isequal\nHTTP.statustext","category":"page"},{"location":"reference/#HTTP.Sniff.sniff","page":"API Reference","title":"HTTP.Sniff.sniff","text":"HTTP.sniff(content::Union{Vector{UInt8}, String, IO}) => String (mimetype)\n\nHTTP.sniff will look at the first 512 bytes of content to try and determine a valid mimetype. If a mimetype can't be determined appropriately, \"application/octet-stream\" is returned.\n\nSupports JSON detection through the HTTP.isjson(content) function.\n\nExamples\n\njulia> HTTP.sniff(\"Hello world!!\")\n\"text/plain; charset=utf-8\"\n\njulia> HTTP.sniff(\"<html><body>Hello world!!</body></html>\")\n\"text/html; charset=utf-8\"\n\njulia> HTTP.sniff(\"{\"a\": -1.0}\")\n\"application/json; charset=utf-8\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.escapehtml","page":"API Reference","title":"HTTP.Strings.escapehtml","text":"escapehtml(i::String)\n\nReturns a string with special HTML characters escaped: &, <, >, \", '\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.tocameldash","page":"API Reference","title":"HTTP.Strings.tocameldash","text":"tocameldash(s::String)\n\nEnsure the first character and characters that follow a '-' are uppercase.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.iso8859_1_to_utf8","page":"API Reference","title":"HTTP.Strings.iso8859_1_to_utf8","text":"iso8859_1_to_utf8(bytes::AbstractVector{UInt8})\n\nConvert from ISO8859_1 to UTF8.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Strings.ascii_lc_isequal","page":"API Reference","title":"HTTP.Strings.ascii_lc_isequal","text":"Case insensitive ASCII character comparison.\n\n\n\n\n\nHTTP.ascii_lc_isequal(a::String, b::String)\n\nCase insensitive ASCII string comparison.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.statustext","page":"API Reference","title":"HTTP.Messages.statustext","text":"statustext(::Int) -> String\n\nString representation of a HTTP status code.\n\nExamples\n\njulia> statustext(200)\n\"OK\"\n\njulia> statustext(404)\n\"Not Found\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#Server-/-Handlers","page":"API Reference","title":"Server / Handlers","text":"","category":"section"},{"location":"reference/#Core-Server","page":"API Reference","title":"Core Server","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.listen\nHTTP.serve\nWebSockets.listen","category":"page"},{"location":"reference/#HTTP.Servers.listen","page":"API Reference","title":"HTTP.Servers.listen","text":"HTTP.listen(handler, host=Sockets.localhost, port=8081; kw...)\nHTTP.listen(handler, port::Integer=8081; kw...)\nHTTP.listen(handler, server::Base.IOServer; kw...)\nHTTP.listen!(args...; kw...) -> HTTP.Server\n\nListen for HTTP connections and execute the handler function for each request. Listening details can be passed as host/port pair, a single port (host will default to localhost), or an already listening server object, as returned from Sockets.listen. To open up a server to external requests, the host argument is typically \"0.0.0.0\".\n\nThe HTTP.listen! form is non-blocking and returns an HTTP.Server object which can be wait(server)ed on manually, or close(server)ed to gracefully shut down the server. Calling HTTP.forceclose(server) will immediately force close the server and all active connections. HTTP.listen will block on the server listening loop until interrupted or and an irrecoverable error occurs.\n\nThe handler function should be of the form f(::HTTP.Stream)::Nothing, and should at the minimum set a status via setstatus() and call startwrite() either explicitly or implicitly by writing out a response via write(). Failure to do this will result in an HTTP 500 error being transmitted to the client.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl  connections. Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl  verification (useful for testing). Construct a custom SSLConfig object  with MbedTLS.SSLConfig(certfile, keyfile).\ntcpisvalid = tcp->true, function f(::TCPSocket)::Bool to check if accepted  connections are valid before processing requests. e.g. to do source IP filtering.\nreadtimeout::Int=0, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.\nreuseaddr::Bool=false, allow multiple servers to listen on the same port.  Not supported on some OS platforms. Can check HTTP.Servers.supportsreuseaddr().\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;  allows manually closing or configuring the server socket.\nverbose::Bool=false, log connection information to stdout.\naccess_log::Function, function for formatting access log messages. The  function should accept two arguments, io::IO to which the messages should  be written, and http::HTTP.Stream which can be used to query information  from. See also @logfmt_str.\non_shutdown::Union{Function, Vector{<:Function}, Nothing}=nothing, one or  more functions to be run if the server is closed (for example by an  InterruptException). Note, shutdown function(s) will not run if an  IOServer object is supplied to the server keyword argument and closed  by close(server).\n\ne.g.\n\n# start a blocking server\nHTTP.listen(\"127.0.0.1\", 8081) do http\n    HTTP.setheader(http, \"Content-Type\" => \"text/html\")\n    write(http, \"target uri: $(http.message.target)<BR>\")\n    write(http, \"request body:<BR><PRE>\")\n    write(http, read(http))\n    write(http, \"</PRE>\")\n    return\nend\n\n# non-blocking server\nserver = HTTP.listen!(\"127.0.0.1\", 8081) do http\n    @show http.message\n    @show HTTP.header(http, \"Content-Type\")\n    while !eof(http)\n        println(\"body data: \", String(readavailable(http)))\n    end\n    HTTP.setstatus(http, 404)\n    HTTP.setheader(http, \"Foo-Header\" => \"bar\")\n    startwrite(http)\n    write(http, \"response body\")\n    write(http, \"more response body\")\nend\n# can gracefully close server manually\nclose(server)\n\nTo run the following HTTP chat example, open two Julia REPL windows and paste the example code into both of them. Then in one window run chat_server() and in the other run chat_client(), then type hello and press return. Whatever you type on the client will be displayed on the server and vis-versa.\n\nusing HTTP\n\nfunction chat(io::HTTP.Stream)\n    @async while !eof(io)\n        write(stdout, readavailable(io), \"\\n\")\n    end\n    while isopen(io)\n        write(io, readline(stdin))\n    end\nend\n\nchat_server() = HTTP.listen(\"127.0.0.1\", 8087) do io\n    write(io, \"HTTP.jl Chat Server. Welcome!\")\n    chat(io)\nend\n\nchat_client() = HTTP.open(\"POST\", \"http://127.0.0.1:8087\") do io\n    chat(io)\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.serve","page":"API Reference","title":"HTTP.Handlers.serve","text":"HTTP.serve(handler, host=Sockets.localhost, port=8081; kw...)\nHTTP.serve(handler, port::Integer=8081; kw...)\nHTTP.serve(handler, server::Base.IOServer; kw...)\nHTTP.serve!(args...; kw...) -> HTTP.Server\n\nListen for HTTP connections and execute the handler function for each request. Listening details can be passed as host/port pair, a single port (host will default to localhost), or an already listening server object, as returned from Sockets.listen. To open up a server to external requests, the host argument is typically \"0.0.0.0\".\n\nThe HTTP.serve! form is non-blocking and returns an HTTP.Server object which can be wait(server)ed on manually, or close(server)ed to gracefully shut down the server. Calling HTTP.forceclose(server) will immediately force close the server and all active connections. HTTP.serve will block on the server listening loop until interrupted or and an irrecoverable error occurs.\n\nThe handler function should be of the form f(req::HTTP.Request)::HTTP.Response. Alternatively, passing stream=true requires the handler to be of the form f(stream::HTTP.Stream) -> Nothing. See HTTP.Router for details on using it as a request handler.\n\nOptional keyword arguments:\n\nsslconfig=nothing, Provide an MbedTLS.SSLConfig object to handle ssl\n\nconnections. Pass sslconfig=MbedTLS.SSLConfig(false) to disable ssl verification (useful for testing). Construct a custom SSLConfig object with MbedTLS.SSLConfig(certfile, keyfile).\n\ntcpisvalid = tcp->true, function f(::TCPSocket)::Bool to check if accepted\n\nconnections are valid before processing requests. e.g. to do source IP filtering.\n\nreadtimeout::Int=0, close the connection if no data is received for this\n\nmany seconds. Use readtimeout = 0 to disable.\n\nreuseaddr::Bool=false, allow multiple servers to listen on the same port.\n\nNot supported on some OS platforms. Can check HTTP.Servers.supportsreuseaddr().\n\nserver::Base.IOServer=nothing, provide an IOServer object to listen on;\n\nallows manually closing or configuring the server socket.\n\nverbose::Bool=false, log connection information to stdout.\naccess_log::Function, function for formatting access log messages. The\n\nfunction should accept two arguments, io::IO to which the messages should be written, and http::HTTP.Stream which can be used to query information from. See also @logfmt_str.\n\non_shutdown::Union{Function, Vector{<:Function}, Nothing}=nothing, one or\n\nmore functions to be run if the server is closed (for example by an InterruptException). Note, shutdown function(s) will not run if an IOServer object is supplied to the server keyword argument and closed by close(server).\n\n# start a blocking echo server\nHTTP.serve(\"127.0.0.1\", 8081) do req\n    return HTTP.Response(200, req.body)\nend\n\n# non-blocking server\nserver = HTTP.serve!(8081) do req\n    return HTTP.Response(200, \"response body\")\nend\n# can gracefully close server manually\nclose(server)\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.WebSockets.listen","page":"API Reference","title":"HTTP.WebSockets.listen","text":"WebSockets.listen(handler, host, port; verbose=false, kw...)\nWebSockets.listen!(handler, host, port; verbose=false, kw...) -> HTTP.Server\n\nListen for websocket connections on host and port, and call handler(ws), which should be a function taking a single WebSocket argument. Keyword arguments kw... are the same as supported by HTTP.listen. Typical usage is like:\n\nWebSockets.listen(host, port) do ws\n    # iterate incoming websocket messages\n    for msg in ws\n        # send message back to client or do other logic here\n        send(ws, msg)\n    end\n    # iteration ends when the websocket connection is closed by client or error\nend\n\n\n\n\n\n","category":"function"},{"location":"reference/#Middleware-/-Handlers","page":"API Reference","title":"Middleware / Handlers","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Handler\nHTTP.Middleware\nHTTP.streamhandler\nHTTP.Router\nHTTP.register!\nHTTP.getparam\nHTTP.getparams\nHTTP.Handlers.cookie_middleware\nHTTP.getcookies\nHTTP.@logfmt_str","category":"page"},{"location":"reference/#HTTP.Handlers.Handler","page":"API Reference","title":"HTTP.Handlers.Handler","text":"Handler\n\nAbstract type for the handler interface that exists for documentation purposes. A Handler is any function of the form f(req::HTTP.Request) -> HTTP.Response. There is no requirement to subtype Handler and users should not rely on or dispatch on Handler. A Handler function f can be passed to HTTP.serve wherein a server will pass each incoming request to f to be handled and a response to be returned. Handler functions are also the inputs to Middleware functions which are functions of the form f(::Handler) -> Handler, i.e. they take a Handler function as input, and return a \"modified\" or enhanced Handler function.\n\nFor advanced cases, a Handler function can also be of the form f(stream::HTTP.Stream) -> Nothing. In this case, the server would be run like HTTP.serve(f, ...; stream=true). For this use-case, the handler function reads the request and writes the response to the stream directly. Note that any middleware used with a stream handler also needs to be of the form f(stream_handler) -> stream_handler, i.e. it needs to accept a stream Handler function and return a stream Handler function.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Handlers.Middleware","page":"API Reference","title":"HTTP.Handlers.Middleware","text":"Middleware\n\nAbstract type for the middleware interface that exists for documentation purposes. A Middleware is any function of the form f(::Handler) -> Handler (ref: Handler). There is no requirement to subtype Middleware and users should not rely on or dispatch on the Middleware type. While HTTP.serve(f, ...) requires a handler function f to be passed, middleware can be \"stacked\" to create a chain of functions that are called in sequence, like HTTP.serve(base_handler |> cookie_middleware |> auth_middlware, ...), where the base_handler Handler function is passed to cookie_middleware, which takes the handler and returns a \"modified\" handler (that parses and stores cookies). This \"modified\" handler is then an input to the auth_middlware, which further enhances/modifies the handler.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Handlers.streamhandler","page":"API Reference","title":"HTTP.Handlers.streamhandler","text":"streamhandler(request_handler) -> stream handler\n\nMiddleware that takes a request handler and returns a stream handler. Used by default in HTTP.serve to take the user-provided request handler and process the Stream from HTTP.listen and pass the parsed Request to the handler.\n\nIs included by default in HTTP.serve as the base \"middleware\" when stream=false is passed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.Router","page":"API Reference","title":"HTTP.Handlers.Router","text":"HTTP.Router(_404, _405, middleware=nothing)\n\nDefine a router object that maps incoming requests by path to registered routes and associated handlers. Paths can be registered using HTTP.register!. The router object itself is a \"request handler\" that can be called like:\n\nr = HTTP.Router()\nresp = r(reqest)\n\nWhich will inspect the request, find the matching, registered handler from the url, and pass the request on to be handled further.\n\nSee HTTP.register! for additional information on registering handlers based on routes.\n\nIf a request doesn't have a matching, registered handler, the _404 handler is called which, by default, returns a HTTP.Response(404). If a route matches the path, but not the method/verb (e.g. there's a registerd route for \"GET /api\", but the request is \"POST /api\"), then the _405 handler is called, which by default returns HTTP.Response(405) (method not allowed).\n\nA middleware (Middleware) can optionally be provided as well, which will be called after the router has matched the request to a route, but before the route's handler is called. This provides a \"hook\" for matched routes that can be helpful for metric tracking, logging, etc. Note that the middleware is only called if the route is matched; for the 404 and 405 cases, users should wrap those handlers in the middleware manually.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Handlers.register!","page":"API Reference","title":"HTTP.Handlers.register!","text":"HTTP.register!(r::Router, method, path, handler)\nHTTP.register!(r::Router, path, handler)\n\nRegister a handler function that should be called when an incoming request matches path and the optionally provided method (if not provided, any method is allowed). Can be used to dynamically register routes. When a registered route is matched, the original route string is stored in the request.context[:route] variable. The following path types are allowed for matching:\n\n/api/widgets: exact match of static strings\n/api/*/owner: single * to wildcard match anything for a single segment\n/api/widget/{id}: Define a path variable id that matches any valued provided for this segment; path variables are available in the request context like HTTP.getparams(req)[\"id\"]\n/api/widget/{id:[0-9]+}: Define a path variable id that does a regex match for integers for this segment\n/api/**: double wildcard matches any number of trailing segments in the request path; the double wildcard must be the last segment in the path\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.getparam","page":"API Reference","title":"HTTP.Handlers.getparam","text":"HTTP.getparam(req, name, default=nothing) -> String\n\nRetrieve a matched path parameter with name name from request context. If a path was registered with a router via HTTP.register! like \"/api/widget/{id}\", then the path parameter can be retrieved like `id = HTTP.getparam(req, \"id\").\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.getparams","page":"API Reference","title":"HTTP.Handlers.getparams","text":"HTTP.getparams(req) -> Dict{String, String}\n\nRetrieve any matched path parameters from the request context. If a path was registered with a router via HTTP.register! like \"/api/widget/{id}\", then the path parameters are available in the request context and can be retrieved like id = HTTP.getparams(req)[\"id\"].\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.cookie_middleware","page":"API Reference","title":"HTTP.Handlers.cookie_middleware","text":"HTTP.Handlers.cookie_middleware(handler) -> handler\n\nMiddleware that parses and stores any cookies in the incoming request in the request context. Cookies can then be retrieved by calling HTTP.getcookies(req) in subsequent middlewares/handlers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Handlers.getcookies","page":"API Reference","title":"HTTP.Handlers.getcookies","text":"HTTP.getcookies(req) -> Vector{Cookie}\n\nRetrieve any parsed cookies from a request context. Cookies are expected to be stored in the req.context[:cookies] of the request context as implemented in the HTTP.Handlers.cookie_middleware middleware.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.@logfmt_str","page":"API Reference","title":"HTTP.@logfmt_str","text":"logfmt\"...\"\n\nParse an NGINX-style log format string and return a function mapping (io::IO, http::HTTP.Stream) -> body suitable for passing to HTTP.listen using the access_log keyword argument.\n\nThe following variables are currently supported:\n\n$http_name: arbitrary request header (with - replaced with _, e.g. http_user_agent)\n$sent_http_name: arbitrary response header (with - replaced with _)\n$request: the request line, e.g. GET /index.html HTTP/1.1\n$request_method: the request method\n$request_uri: the request URI\n$remote_addr: client address\n$remote_port: client port\n$remote_user: user name supplied with the Basic authentication\n$server_protocol: server protocol\n$time_iso8601: local time in ISO8601 format\n$time_local: local time in Common Log Format\n$status: response status code\n$body_bytes_sent: number of bytes in response body\n\nExamples\n\nlogfmt\"[$time_iso8601] \\\"$request\\\" $status\" # [2021-05-01T12:34:40+0100] \"GET /index.html HTTP/1.1\" 200\n\nlogfmt\"$remote_addr \\\"$http_user_agent\\\"\" # 127.0.0.1 \"curl/7.47.0\"\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Advanced-Topics","page":"API Reference","title":"Advanced Topics","text":"","category":"section"},{"location":"reference/#Messages-Interface","page":"API Reference","title":"Messages Interface","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Messages.iserror\nHTTP.Messages.isredirect\nHTTP.Messages.ischunked\nHTTP.Messages.issafe\nHTTP.Messages.isidempotent\nHTTP.Messages.retryable\nHTTP.Messages.defaultheader!\nHTTP.Messages.readheaders\nHTTP.DefaultHeadersRequest.setuseragent!\nHTTP.Messages.readchunksize\nHTTP.Messages.headerscomplete(::HTTP.Messages.Response)\nHTTP.Messages.writestartline\nHTTP.Messages.writeheaders\nBase.write(::IO,::HTTP.Messages.Message)\nHTTP.Streams.closebody\nHTTP.Streams.isaborted","category":"page"},{"location":"reference/#HTTP.Messages.iserror","page":"API Reference","title":"HTTP.Messages.iserror","text":"iserror(::Response)\n\nDoes this Response have an error status?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.isredirect","page":"API Reference","title":"HTTP.Messages.isredirect","text":"isredirect(::Response)\n\nDoes this Response have a redirect status?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.ischunked","page":"API Reference","title":"HTTP.Messages.ischunked","text":"ischunked(::Message)\n\nDoes the Message have a \"Transfer-Encoding: chunked\" header?\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.issafe","page":"API Reference","title":"HTTP.Messages.issafe","text":"issafe(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.1\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.isidempotent","page":"API Reference","title":"HTTP.Messages.isidempotent","text":"isidempotent(::Request)\n\nhttps://tools.ietf.org/html/rfc7231#section-4.2.2\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.retryable","page":"API Reference","title":"HTTP.Messages.retryable","text":"retryable(::Request)\n\nWhether a Request is eligible to be retried.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.defaultheader!","page":"API Reference","title":"HTTP.Messages.defaultheader!","text":"defaultheader!(::Message, key => value)\n\nSet header value in message for key if it is not already set.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.readheaders","page":"API Reference","title":"HTTP.Messages.readheaders","text":"readheaders(::IO, ::Message)\n\nRead headers (and startline) from an IO stream into a Message struct. Throw EOFError if input is incomplete.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.DefaultHeadersRequest.setuseragent!","page":"API Reference","title":"HTTP.DefaultHeadersRequest.setuseragent!","text":"setuseragent!(x::Union{String, Nothing})\n\nSet the default User-Agent string to be used in each HTTP request. Can be manually overridden by passing an explicit User-Agent header. Setting nothing will prevent the default User-Agent header from being passed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.readchunksize","page":"API Reference","title":"HTTP.Messages.readchunksize","text":"Read chunk-size from an IO stream. After the final zero size chunk, read trailers into a Message struct.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}","page":"API Reference","title":"HTTP.Messages.headerscomplete","text":"headerscomplete(::Message)\n\nHave the headers been read into this Message?\n\n\n\n\n\n","category":"method"},{"location":"reference/#HTTP.Messages.writestartline","page":"API Reference","title":"HTTP.Messages.writestartline","text":"writestartline(::IO, ::Message)\n\ne.g. \"GET /path HTTP/1.1\\r\\n\" or \"HTTP/1.1 200 OK\\r\\n\"\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Messages.writeheaders","page":"API Reference","title":"HTTP.Messages.writeheaders","text":"writeheaders(::IO, ::Message)\n\nWrite Message start line and a line for each \"name: value\" pair and a trailing blank line.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.write-Tuple{IO, HTTP.Messages.Message}","page":"API Reference","title":"Base.write","text":"write(::IO, ::Message)\n\nWrite start line, headers and body of HTTP Message.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HTTP.Streams.closebody","page":"API Reference","title":"HTTP.Streams.closebody","text":"closebody(::Stream)\n\nWrite the final 0 chunk if needed.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Streams.isaborted","page":"API Reference","title":"HTTP.Streams.isaborted","text":"isaborted(::Stream{<:Response})\n\nHas the server signaled that it does not wish to receive the message body?\n\n\"If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.\" RFC7230, 6.5\n\n\n\n\n\n","category":"function"},{"location":"reference/#Cookie-Persistence","page":"API Reference","title":"Cookie Persistence","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Cookies.CookieJar\nHTTP.Cookies.getcookies!\nHTTP.Cookies.setcookies!","category":"page"},{"location":"reference/#HTTP.Cookies.CookieJar","page":"API Reference","title":"HTTP.Cookies.CookieJar","text":"CookieJar()\n\nA thread-safe object for storing cookies returned in \"Set-Cookie\" response headers. Keyed by appropriate host from the original request made. Can be created manually and passed like HTTP.get(url; cookiejar=mycookiejar) to avoid using the default global CookieJar. The 2 main functions for interacting with a CookieJar are Cookies.getcookies!, which returns a Vector{Cookie} for a given url (and will remove expired cookies from the jar), and Cookies.setcookies!, which will store \"Set-Cookie\" response headers in the cookie jar.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.Cookies.getcookies!","page":"API Reference","title":"HTTP.Cookies.getcookies!","text":"Cookies.getcookies!(jar::CookieJar, url::URI)\n\nRetrieve valid Cookies from the CookieJar according to the provided url. Cookies will be returned as a Vector{Cookie}. Only cookies for http or https scheme in the url will be returned. Cookies will be checked according to the canonical host of the url and any cookie max age or expiration will be accounted for. Expired cookies will not be returned and will be removed from the cookie jar.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Cookies.setcookies!","page":"API Reference","title":"HTTP.Cookies.setcookies!","text":"Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers)\n\nIdentify, \"Set-Cookie\" response headers from headers, parse the Cookies, and store valid entries in the cookie jar according to the canonical host in url. Cookies can be retrieved from the jar via Cookies.getcookies!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Client-side-Middleware-(Layers)","page":"API Reference","title":"Client-side Middleware (Layers)","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Layer\nHTTP.@client\nHTTP.pushlayer!\nHTTP.pushfirstlayer!\nHTTP.poplayer!\nHTTP.popfirstlayer!\nHTTP.MessageRequest.messagelayer\nHTTP.RedirectRequest.redirectlayer\nHTTP.DefaultHeadersRequest.defaultheaderslayer\nHTTP.BasicAuthRequest.basicauthlayer\nHTTP.CookieRequest.cookielayer\nHTTP.CanonicalizeRequest.canonicalizelayer\nHTTP.TimeoutRequest.timeoutlayer\nHTTP.ExceptionRequest.exceptionlayer\nHTTP.RetryRequest.retrylayer\nHTTP.ConnectionRequest.connectionlayer\nHTTP.DebugRequest.debuglayer\nHTTP.StreamRequest.streamlayer\nHTTP.ContentTypeDetection.contenttypedetectionlayer","category":"page"},{"location":"reference/#HTTP.Layer","page":"API Reference","title":"HTTP.Layer","text":"Layer\n\nAbstract type to represent a client-side middleware that exists for documentation purposes. A layer is any function of the form f(::Handler) -> Handler, where Handler is a function of the form f(::Request) -> Response. Note that the Handler definition is from the server-side documentation, and is \"hard-coded\" on the client side. It may also be apparent that a Layer is the same as the Middleware interface from server-side, which is true, but we define Layer to clarify the client-side distinction and its unique usage. Custom layers can be deployed in one of two ways:\n\nHTTP.@client: Create a custom \"client\" with shorthand verb definitions, but which include custom layers; only these new verb methods will use the custom layers.\nHTTP.pushlayer!/HTTP.poplayer!: Allows globally adding and removing layers from the default HTTP.jl layer stack; all http requests will then use the custom layers\n\nQuick Examples\n\nmodule Auth\n\nusing HTTP\n\nfunction auth_layer(handler)\n    # returns a `Handler` function; check for a custom keyword arg `authcreds` that\n    # a user would pass like `HTTP.get(...; authcreds=creds)`.\n    # We also accept trailing keyword args `kw...` and pass them along later.\n    return function(req; authcreds=nothing, kw...)\n        # only apply the auth layer if the user passed `authcreds`\n        if authcreds !== nothing\n            # we add a custom header with stringified auth creds\n            HTTP.setheader(req, \"X-Auth-Creds\" => string(authcreds))\n        end\n        # pass the request along to the next layer by calling `auth_layer` arg `handler`\n        # also pass along the trailing keyword args `kw...`\n        return handler(req; kw...)\n    end\nend\n\n# Create a new client with the auth layer added\nHTTP.@client [auth_layer]\n\nend # module\n\n# Can now use custom client like:\nAuth.get(url; authcreds=creds) # performs GET request with auth_layer layer included\n\n# Or can include layer globally in all HTTP.jl requests\nHTTP.pushlayer!(Auth.auth_layer)\n\n# Now can use normal HTTP.jl methods and auth_layer will be included\nHTTP.get(url; authcreds=creds)\n\n\n\n\n\n","category":"type"},{"location":"reference/#HTTP.@client","page":"API Reference","title":"HTTP.@client","text":"HTTP.@client requestlayers\nHTTP.@client requestlayers streamlayers\nHTTP.@client (first=requestlayers, last=requestlayers) (first=streamlayers, last=streamlayers)\n\nConvenience macro for creating a custom HTTP.jl client that will include custom layers when performing requests. It's common to want to define a custom Layer to enhance a specific category of requests, such as custom authentcation for a web API. Instead of affecting the global HTTP.jl request stack via HTTP.pushlayer!, a custom wrapper client can be defined with convenient shorthand methods. See Layer for an example of defining a custom layer and creating a new client that includes the layer.\n\nCustom layer arguments can be provided as a collection of request or stream-based layers; alternatively, a NamedTuple with keys first and last can be provided with values being a collection of layers. The NamedTuple form provides finer control over the order in which the layers will be included in the default http layer stack: first request layers are executed before all other layers, last request layers are executed right before all stream layers, and similarly for stream layers.\n\nAn empty collection can always be passed for request or stream layers when not needed.\n\nOne use case for custom clients is to control the value of standard HTTP.request keyword arguments. This can be achieved by passing a (first=[defaultkeywordlayer],) where defaultkeywordlayer is defined like:\n\ndefaultkeywordlayer(handler) = (req; kw...) -> handler(req; retry=false, redirect=false, kw...)\n\nThis client-side layer is basically a no-op as it doesn't modify the request at all, except that it hard-codes the value of the retry and redirect keyword arguments. When we pass this layer as (first=[defaultkeywordlayer],) this ensures this layer will be executed before all other layers, effectively over-writing the default and any user-provided keyword arguments for retry or redirect.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#HTTP.pushlayer!","page":"API Reference","title":"HTTP.pushlayer!","text":"HTTP.pushlayer!(layer; request=true)\n\nPush a layer onto the stack of layers that will be applied to all requests. The \"layer\" is expected to be a function that takes and returns a Handler function. See Layer for more details. If request=false, the layer is expected to take and return a \"stream\" handler function. The custom layer will be put on the top of the stack, so it will be the first layer executed. To add a layer at the bottom of the stack, see HTTP.pushfirstlayer!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.pushfirstlayer!","page":"API Reference","title":"HTTP.pushfirstlayer!","text":"HTTP.pushfirstlayer!(layer; request=true)\n\nPush a layer to the start of the stack of layers that will be applied to all requests. The \"layer\" is expected to be a function that takes and returns a Handler function. See Layer for more details. If request=false, the layer is expected to take and return a \"stream\" handler function. The custom layer will be put on the bottom of the stack, so it will be the last layer executed. To add a layer at the top of the stack, see HTTP.pushlayer!.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.poplayer!","page":"API Reference","title":"HTTP.poplayer!","text":"HTTP.poplayer!(; request=true)\n\nInverse of HTTP.pushlayer!, removes the top layer of the global HTTP.jl layer stack. Can be used to \"cleanup\" after a custom layer has been added. If request=false, will remove the top \"stream\" layer as opposed to top \"request\" layer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.popfirstlayer!","page":"API Reference","title":"HTTP.popfirstlayer!","text":"HTTP.popfirstlayer!(; request=true)\n\nInverse of HTTP.pushfirstlayer!, removes the bottom layer of the global HTTP.jl layer stack. Can be used to \"cleanup\" after a custom layer has been added. If request=false, will remove the bottom \"stream\" layer as opposed to bottom \"request\" layer.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.MessageRequest.messagelayer","page":"API Reference","title":"HTTP.MessageRequest.messagelayer","text":"messagelayer(handler) -> handler\n\nConstruct a Request object from method, url, headers, and body. Hard-coded as the first layer in the request pipeline.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.RedirectRequest.redirectlayer","page":"API Reference","title":"HTTP.RedirectRequest.redirectlayer","text":"redirectlayer(handler) -> handler\n\nRedirects the request in the case of 3xx response status.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.DefaultHeadersRequest.defaultheaderslayer","page":"API Reference","title":"HTTP.DefaultHeadersRequest.defaultheaderslayer","text":"defaultheaderslayer(handler) -> handler\n\nSets default expected headers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.BasicAuthRequest.basicauthlayer","page":"API Reference","title":"HTTP.BasicAuthRequest.basicauthlayer","text":"basicauthlayer(handler) -> handler\n\nAdd Authorization: Basic header using credentials from url userinfo.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.CookieRequest.cookielayer","page":"API Reference","title":"HTTP.CookieRequest.cookielayer","text":"cookielayer(handler) -> handler\n\nCheck for host-appropriate cookies to include in the outgoing request from the cookiejar keyword argument (by default, a global cookiejar is used). Store \"Set-Cookie\" cookies from the response headers.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.CanonicalizeRequest.canonicalizelayer","page":"API Reference","title":"HTTP.CanonicalizeRequest.canonicalizelayer","text":"canonicalizelayer(handler) -> handler\n\nRewrite request and response headers in Canonical-Camel-Dash-Format.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.TimeoutRequest.timeoutlayer","page":"API Reference","title":"HTTP.TimeoutRequest.timeoutlayer","text":"timeoutlayer(handler) -> handler\n\nClose the HTTP.Stream if no data has been received for readtimeout seconds.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ExceptionRequest.exceptionlayer","page":"API Reference","title":"HTTP.ExceptionRequest.exceptionlayer","text":"exceptionlayer(handler) -> handler\n\nThrow a StatusError if the request returns an error response status.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.RetryRequest.retrylayer","page":"API Reference","title":"HTTP.RetryRequest.retrylayer","text":"retrylayer(handler) -> handler\n\nRetry the request if it throws a recoverable exception.\n\nBase.retry and Base.ExponentialBackOff implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.\n\nMethods of isrecoverable(e) define which exception types lead to a retry. e.g. Sockets.DNSError, Base.EOFError and HTTP.StatusError (if status is 5xx).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ConnectionRequest.connectionlayer","page":"API Reference","title":"HTTP.ConnectionRequest.connectionlayer","text":"connectionlayer(handler) -> handler\n\nRetrieve an IO connection from the ConnectionPool.\n\nClose the connection if the request throws an exception. Otherwise leave it open so that it can be reused.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.DebugRequest.debuglayer","page":"API Reference","title":"HTTP.DebugRequest.debuglayer","text":"debuglayer(handler) -> handler\n\nIf the positive verbose keyword arg passed to the handler, then enable debug logging with verbosity verbose for the lifetime of the request. If no verbose is specified, it defaults to the HTTP.jl global DEBUG_LEVEL[].\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.StreamRequest.streamlayer","page":"API Reference","title":"HTTP.StreamRequest.streamlayer","text":"streamlayer(stream) -> HTTP.Response\n\nCreate a Stream to send a Request and body to an IO stream and read the response.\n\nSend the Request body in a background task and begins reading the response immediately so that the transmission can be aborted if the Response status indicates that the server does not wish to receive the message body. RFC7230 6.5.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ContentTypeDetection.contenttypedetectionlayer","page":"API Reference","title":"HTTP.ContentTypeDetection.contenttypedetectionlayer","text":"contenttypedetectionlayer(handler) -> handler\n\nTry and detect the content type of the request body and add the \"Content-Type\" header.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Raw-Request-Connection","page":"API Reference","title":"Raw Request Connection","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.openraw\nHTTP.Connection","category":"page"},{"location":"reference/#HTTP.openraw","page":"API Reference","title":"HTTP.openraw","text":"HTTP.openraw(method, url, [, headers])::Tuple{Connection, Response}\n\nOpen a raw socket that is unmanaged by HTTP.jl. Useful for doing HTTP upgrades to other protocols.  Any bytes of the body read from the socket when reading headers, is returned as excess bytes in the last tuple argument.\n\nExample of a WebSocket upgrade:\n\nheaders = Dict(\n    \"Upgrade\" => \"websocket\",\n    \"Connection\" => \"Upgrade\",\n    \"Sec-WebSocket-Key\" => \"dGhlIHNhbXBsZSBub25jZQ==\",\n    \"Sec-WebSocket-Version\" => \"13\")\n\nsocket, response, excess = HTTP.openraw(\"GET\", \"ws://echo.websocket.org\", headers)\n\n# Write a WebSocket frame\nframe = UInt8[0x81, 0x85, 0x37, 0xfa, 0x21, 0x3d, 0x7f, 0x9f, 0x4d, 0x51, 0x58]\nwrite(socket, frame)\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.ConnectionPool.Connection","page":"API Reference","title":"HTTP.ConnectionPool.Connection","text":"Connection\n\nA TCPSocket or SSLContext connection to a HTTP host and port.\n\nFields:\n\nhost::String\nport::String, exactly as specified in the URI (i.e. may be empty).\nidle_timeout, No. of seconds to maintain connection after last request/response.\nrequire_ssl_verification, whether ssl verification is required for an ssl connection\npeerip, remote IP adress (used for debug/log messages).\npeerport, remote TCP port number (used for debug/log messages).\nlocalport, local TCP port number (used for debug messages).\nio::T, the TCPSocket or `SSLContext.\nclientconnection::Bool, whether the Connection was created from client code (as opposed to server code)\nbuffer::IOBuffer, left over bytes read from the connection after  the end of a response header (or chunksize). These bytes are usually  part of the response body.\ntimestamp, time data was last received.\nreadable, whether the Connection object is readable\nwritable, whether the Connection object is writable\n\n\n\n\n\n","category":"type"},{"location":"reference/#Parser-Interface","page":"API Reference","title":"Parser Interface","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"HTTP.Parsers.find_end_of_header\nHTTP.Parsers.find_end_of_chunk_size\nHTTP.Parsers.find_end_of_trailer\nHTTP.Parsers.parse_status_line!\nHTTP.Parsers.parse_request_line!\nHTTP.Parsers.parse_header_field\nHTTP.Parsers.parse_chunk_size","category":"page"},{"location":"reference/#HTTP.Parsers.find_end_of_header","page":"API Reference","title":"HTTP.Parsers.find_end_of_header","text":"find_end_of_header(bytes) -> length or 0\n\nFind length of header delimited by \\r\\n\\r\\n or \\n\\n.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.find_end_of_chunk_size","page":"API Reference","title":"HTTP.Parsers.find_end_of_chunk_size","text":"Find \\n after chunk size in bytes.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.find_end_of_trailer","page":"API Reference","title":"HTTP.Parsers.find_end_of_trailer","text":"find_end_of_trailer(bytes) -> length or 0\n\nFind length of trailer delimited by \\r\\n\\r\\n (or starting with \\r\\n). RFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_status_line!","page":"API Reference","title":"HTTP.Parsers.parse_status_line!","text":"Parse HTTP response-line bytes and set the status and version fields of response. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_request_line!","page":"API Reference","title":"HTTP.Parsers.parse_request_line!","text":"Parse HTTP request-line bytes and set the method, target and version fields of request. Return a SubString containing the header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_header_field","page":"API Reference","title":"HTTP.Parsers.parse_header_field","text":"Parse HTTP header-field. Return Pair(field-name => field-value) and a SubString containing the remaining header-field lines.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HTTP.Parsers.parse_chunk_size","page":"API Reference","title":"HTTP.Parsers.parse_chunk_size","text":"Parse HTTP chunk-size. Return number of bytes of chunk-data.\n\nchunk-size = 1*HEXDIG\n\nRFC7230 4.1\n\n\n\n\n\n","category":"function"},{"location":"#HTTP.jl-Documentation","page":"Home","title":"HTTP.jl Documentation","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.jl provides both client and server functionality for the http and websocket protocols. As a client, it provides the ability to make a wide range of requests, including GET, POST, websocket upgrades, form data, multipart, chunking, and cookie handling. There is also advanced functionality to provide client-side middleware and generate your own customized HTTP client. On the server side, it provides the ability to listen, accept, and route http requests, with middleware and handler interfaces to provide flexibility in processing responses.","category":"page"},{"location":"#Quickstart","page":"Home","title":"Quickstart","text":"","category":"section"},{"location":"#Making-requests-(client)","page":"Home","title":"Making requests (client)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.request sends an http request and returns a response.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# make a GET request, both forms are equivalent\nresp = HTTP.request(\"GET\", \"http://httpbin.org/ip\")\nresp = HTTP.get(\"http://httpbin.org/ip\")\nprintln(resp.status)\nprintln(String(resp.body))\n\n# make a POST request, sending data via `body` keyword argument\nresp = HTTP.post(\"http://httpbin.org/body\"; body=\"request body\")\n\n# make a POST request, sending form-urlencoded body\nresp = HTTP.post(\"http://httpbin.org/body\"; body=Dict(\"nm\" => \"val\"))\n\n# include query parameters in a request\n# and turn on verbose logging of the request/response process\nresp = HTTP.get(\"http://httpbin.org/anything\"; query=[\"hello\" => \"world\"], verbose=2)\n\n# simple websocket client\nWebSockets.open(\"ws://websocket.org\") do ws\n    # we can iterate the websocket\n    # where each iteration yields a received message\n    # iteration finishes when the websocket is closed\n    for msg in ws\n        # do stuff with msg\n        # send back message as String, Vector{UInt8}, or iterable of either\n        send(ws, resp)\n    end\nend","category":"page"},{"location":"#Handling-requests-(server)","page":"Home","title":"Handling requests (server)","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"HTTP.serve allows specifying middleware + handlers for how incoming requests should be processed.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# authentication middleware to ensure property security\nfunction auth(handler)\n    return function(req)\n        ident = parse_auth(req)\n        if ident === nothing\n            # failed to security authentication\n            return HTTP.Response(401, \"unauthorized\")\n        else\n            # store parsed identity in request context for handler usage\n            req.context[:auth] = ident\n            # pass request on to handler function for further processing\n            return handler(req)\n        end\n    end\nend\n\n# handler function to return specific user's data\nfunction handler(req)\n    ident = req.context[:auth]\n    return HTTP.Response(200, get_user_data(ident))\nend\n\n# start a server listening on port 8081 (default port) for localhost (default host)\n# requests will first be handled by teh auth middleware before being passed to the `handler`\n# request handler function\nHTTP.serve(auth(handler))\n\n# websocket server is very similar to client usage\nWebSockets.listen(\"0.0.0.0\", 8080) do ws\n    for msg in ws\n        # simple echo server\n        send(ws, msg)\n    end\nend","category":"page"},{"location":"#Further-Documentation","page":"Home","title":"Further Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Check out the client, server, and websocket-specific documentation pages for more in-depth discussions and examples for the many configurations available.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"client.md\", \"server.md\", \"websockets.md\", \"reference.md\"]","category":"page"},{"location":"#Migrating-Legacy-Code-to-1.0","page":"Home","title":"Migrating Legacy Code to 1.0","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The 1.0 release is finally here! It's been a lot of work over the course of about 9 months combing through every part of the codebase to try and modernize APIs, fix long-standing issues, and bring the level of functionality up to par with other language http implementations. Along the way, some breaking changes were made, but with the aim that the package will now be committed to current published APIs for a long time to come. With the amount of increased functionality and fixes, we hope it provides enough incentive to make the update; as always, if you run into issues upgrading or feel something didn't get polished or fixed quite right, don't hesitate to open an issue so we can help.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The sections below outline a mix of breaking changes that were made, in addition to some of the new features in 1.0 with the aim to help those updating legacy codebases.","category":"page"},{"location":"#Struct-Changes","page":"Home","title":"Struct Changes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The HTTP.Request and HTTP.Response body fields are not restricted to Vector{UInt8}; if a response_stream is passed to HTTP.request, it will be set as the resp.body (previously the body was an empty UInt8[]). This simplified many codepaths so these \"other body object types\" didn't have to be held in some other state, but could be stored in the Request/Response directly. It also opens up the possibility, (as shown in the Cors Server example), where middleware can serialize/deserialize to/from the body field directly.\nIn related news, a Request body can now be passed as a Dict or NamedTuple to have the key-value pairs serialized in the appliction/x-www-form-urlencoded Content-Type matching many other libaries functionality\nResponses with the Transfer-Encoding: gzip header will now also be automatically decompressed, and this behavior is configurable via the decompress::Bool keyword argument for HTTP.request\nIf a response_stream is provided for streaming a request's response body, HTTP.request will not call close before returning, leaving that up to the caller.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, in the face of redirects or retried requests, note the response_stream will not be written to until the final response is received.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If a streaming request body is provided, it should support the mark/reset methods in case the request needs to be retried.\nUsers are encouraged to access the publicly documented fields of Request/Response instead of the previously documented \"accessor\" functions; these fields are now committed as the public API, so feel free to do resp.body instead of HTTP.body(resp). The accessor methods are still defined for backwards compat.\nThe Request object now stores the original url argument provided to HTTP.request as a parsed URIs.URI object, and accessed via the req.url field. This is commonly desired in handlers/middleware, so convenient to keep it around.\nThe Request object also has a new req.context field of type Dict{Symbol, Any} for storing/sharing state between handler/middlware layers. For example, the HTTP.Router now parses and stores named path parameters with the :params key in the context for handlers to access. Another HTTP.cookie_middleware will parse and store any request Cookie header in the :cookies context key.\nHTTP.request now throws more consistent and predictable error types, including (and restricted to): HTTP.ConnectError, HTTP.StatusError, HTTP.TimeoutError, and HTTP.RequestError. See the Request exceptions section for more details on each exception type.\nCookie persistence used to use a Dict per thread to store domain-specific cookie sessions. A new threadsafe CookieJar struct now globally manages cookie persistence by default. Users can still construct and pass their own cookiejar keyword argument to HTTP.request if desired.","category":"page"},{"location":"#Keyword-Argument-Changes","page":"Home","title":"Keyword Argument Changes","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The pipeline_limit keyword argument (and support for it) were removed in HTTP.request; the implementation was poor and it drastically complicated the request internal implementation. In addition, it's not commonly supported in other modern http implementations, which encourage use of HTTP/2 for better designed functionality.\nreuse_limit support was removed in both HTTP.request and HTTP.listen; another feature that complicated code more than it was actually useful and hence removed.\naws_authentication and its related keyword arguments have been removed in favor of using the AWS.jl package\nA new redirect_method keyword argument exists and supports finer-grained control over which method to use in the case of a request redirect","category":"page"},{"location":"#Other-Largish-Changes","page":"Home","title":"Other Largish Changes","text":"","category":"section"},{"location":"#\"Handlers\"-framework-overhaul","page":"Home","title":"\"Handlers\" framework overhaul","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The server-side Handlers framework has been changed to a more modern and flexible framework, including the Handler and Middleware interfaces. It's similar in ways to the old interfaces, but in our opinion, simpler and more straightforward with the clear distinction/pattern between what a Handler does vs. a Middlware.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In that vein, HTTP.Handlers.handle has been removed. HTTP.serve expects a single request or stream Handler function, which should be of the form f(::Request)::Response for the request case, or f(::Stream)::Nothing for streams.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are also plans to either include some common useful middleware functions in HTTP.jl directly, or a sister package specifically for collecting useful middlewares people can reuse.","category":"page"},{"location":"#WebSockets-overhaul","page":"Home","title":"WebSockets overhaul","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The WebSockets code was some of the oldeset and least maintained code in HTTP.jl. It was debated removing it entirely, but there aren't really other modern implementations that are well-maintained. So the WebSockets code was overhauled, modernized, and is now tested against the industry standard autobahn test suite (yay for 3rd party verification!). The API changed as well; while WebSockets.open and WebSockets.listen have stayed the same, the WebSocket object itself now doesn't subtype IO and has a restricted interface like:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ws.id access a unique generated UUID id for this websocket connection\nreceive(ws) receive a single non-control message on a websocket, returning a String or Vector{UInt8} depending on whether the message was sent as TEXT or BINARY\nsend(ws, msg) send a message; supports TEXT and BINARY messages, and can provide an iterable for msg to send fragmented messages\nclose(ws) close a websocket connection\nFor convenience, a WebSocket object can be iterated, where each iteration yields a non-control message and iteration terminates when the connection is closed","category":"page"},{"location":"#HTTP.Router-reimplementation","page":"Home","title":"HTTP.Router reimplementation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While clever, the old HTTP.Router implementation relied on having routes registered \"statically\", which can be really inconvenient for any cases where the routes are generated programmatically or need to be set/updated dynamically.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The new HTTP.Router implementation uses a text-matching based trie data structure on incoming request path segments to find the right matching handler to process the request. It also supports parsing and storing path variables, like /api/{id} or double wildcards for matching trailing path segments, like /api/**.","category":"page"},{"location":"","page":"Home","title":"Home","text":"HTTP.Router now also supports complete unrestricted route registeration via HTTP.register!.","category":"page"},{"location":"#Internal-client-side-layers-overhaul","page":"Home","title":"Internal client-side layers overhaul","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"While grandiose in vision, the old type-based \"layers\" framework relied heavily on type parameter abuse for generating a large \"stack\" of layers to handle different parts of each HTTP.request. The new framework actually matches very closely with the server-side Handler and Middleware interfaces, and can be found in more detail under the Client-side Middleware (Layers) section of the docs. The new implementation, while hopefully bringing greater consistency between client-side and server-side frameworks, is much simpler and forced a large cleanup of state-handling in the HTTP.request process for the better.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition to the changing of all the client-side layer definitions, HTTP.stack now behaves slightly different in returning the new \"layer\" chain for HTTP.request, while also accepting custom request/stream layers is provided. A new HTTP.@client macro is provided for convenience in the case that users want to write a custom client-side middleware/layer and wrap its usage in an HTTP.jl-like client.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There also existed a few internal methods previously for manipulating the global stack of client-side layers (insert, insert_default!, etc.). These have been removed and replaced with a more formal (and documented) API via HTTP.pushlayer! and HTTP.poplayer!. These can be used to globally manipulate the client-side stack of layers for any HTTP.request that is made.","category":"page"}]
}
