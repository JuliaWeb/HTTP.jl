<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · HTTP.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">HTTP.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../client/">Client</a></li><li><a class="tocitem" href="../server/">Server</a></li><li><a class="tocitem" href="../websockets/">WebSockets</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Client-Requests"><span>Client Requests</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li><li><a class="tocitem" href="#Server-/-Handlers"><span>Server / Handlers</span></a></li><li><a class="tocitem" href="#Advanced-Topics"><span>Advanced Topics</span></a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaWeb/HTTP.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="#API-Reference">API Reference</a></li><li class="no-marker"><ul><li><a href="#Client-Requests">Client Requests</a></li><li class="no-marker"><ul><li><a href="#Request/Response-Objects">Request/Response Objects</a></li><li><a href="#Request-body-types">Request body types</a></li><li><a href="#Request-exceptions">Request exceptions</a></li><li><a href="#URIs">URIs</a></li><li><a href="#Cookies">Cookies</a></li><li><a href="#WebSockets">WebSockets</a></li></ul></li><li><a href="#Utilities">Utilities</a></li><li><a href="#Server-/-Handlers">Server / Handlers</a></li><li class="no-marker"><ul><li><a href="#Core-Server">Core Server</a></li><li><a href="#Middleware-/-Handlers">Middleware / Handlers</a></li></ul></li><li><a href="#Advanced-Topics">Advanced Topics</a></li><li class="no-marker"><ul><li><a href="#Messages-Interface">Messages Interface</a></li><li><a href="#Cookie-Persistence">Cookie Persistence</a></li><li><a href="#Client-side-Middleware-(Layers)">Client-side Middleware (Layers)</a></li><li><a href="#Raw-Request-Connection">Raw Request Connection</a></li><li><a href="#Parser-Interface">Parser Interface</a></li></ul></li></ul></li></ul><h2 id="Client-Requests"><a class="docs-heading-anchor" href="#Client-Requests">Client Requests</a><a id="Client-Requests-1"></a><a class="docs-heading-anchor-permalink" href="#Client-Requests" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HTTP.request" href="#HTTP.request"><code>HTTP.request</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.request(method, url [, headers [, body]]; &lt;keyword arguments&gt;]) -&gt; HTTP.Response</code></pre><p>Send a HTTP Request Message and receive a HTTP Response Message.</p><p>e.g.</p><pre><code class="language-julia hljs">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/ip&quot;)
r = HTTP.get(&quot;http://httpbin.org/ip&quot;) # equivalent shortcut
println(r.status)
println(String(r.body))</code></pre><p><code>headers</code> can be any collection where <code>[string(k) =&gt; string(v) for (k,v) in headers]</code> yields <code>Vector{Pair}</code>. e.g. a <code>Dict()</code>, a <code>Vector{Tuple}</code>, a <code>Vector{Pair}</code> or an iterator. By convention, if a header <em>value</em> is an empty string, it will not be written when sending a request (following the curl convention).</p><p><code>body</code> can be a variety of objects:</p><ul><li>a <code>Dict</code> or <code>NamedTuple</code> to be serialized as the &quot;application/x-www-form-urlencoded&quot; content type</li><li>any <code>AbstractString</code> or <code>AbstractVector{UInt8}</code> which will be sent &quot;as is&quot; for the request body</li><li>a readable <code>IO</code> stream or any <code>IO</code>-like type <code>T</code> for which <code>eof(T)</code> and <code>readavailable(T)</code> are defined. This stream will be read and sent until <code>eof</code> is <code>true</code>. This object should support the <code>mark</code>/<code>reset</code> methods if request retires are desired (if not, no retries will be attempted).</li><li>Any collection or iterable of the above (<code>Dict</code>, <code>AbstractString</code>, <code>AbstractVector{UInt8}</code>, or <code>IO</code>) which will result in a &quot;chunked&quot; request body, where each iterated element will be sent as a separate chunk</li><li>a <a href="#HTTP.Forms.Form"><code>HTTP.Form</code></a>, which will be serialized as the &quot;multipart/form-data&quot; content-type</li></ul><p>The <code>HTTP.Response</code> struct contains:</p><ul><li><code>status::Int16</code> e.g. <code>200</code></li><li><code>headers::Vector{Pair{String,String}}</code>  e.g. [&quot;Server&quot; =&gt; &quot;Apache&quot;, &quot;Content-Type&quot; =&gt; &quot;text/html&quot;]</li><li><code>body::Vector{UInt8}</code> or <code>::IO</code>, the Response Body bytes or the <code>io</code> argument  provided via the <code>response_stream</code> keyword argument</li></ul><p>Functions <code>HTTP.get</code>, <code>HTTP.put</code>, <code>HTTP.post</code> and <code>HTTP.head</code> are defined as shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>, etc.</p><p>Supported optional keyword arguments:</p><ul><li><code>query = nothing</code>, a <code>Pair</code> or <code>Dict</code> of key =&gt; values to be included in the url</li><li><code>response_stream = nothing</code>, a writeable <code>IO</code> stream or any <code>IO</code>-like  type <code>T</code> for which <code>write(T, AbstractVector{UInt8})</code> is defined. The response body  will be written to this stream instead of returned as a <code>Vector{UInt8}</code>.</li><li><code>verbose = 0</code>, set to <code>1</code> or <code>2</code> for increasingly verbose logging of the  request and response process</li><li><code>connect_timeout = 0</code>, close the connection after this many seconds if it is still attempting to connect. Use <code>connect_timeout = 0</code> to disable.</li><li><code>connection_limit = 8</code>, number of concurrent connections allowed to each host:port.</li><li><code>readtimeout = 0</code>, close the connection if no data is received for this many seconds. Use <code>readtimeout = 0</code> to disable.</li><li><code>status_exception = true</code>, throw <code>HTTP.StatusError</code> for response status &gt;= 300.</li><li>Basic authentication is detected automatically from the provided url&#39;s <code>userinfo</code> (in the form <code>scheme://user:password@host</code>) and adds the <code>Authorization: Basic</code> header; this can be disabled by passing <code>basicauth=false</code></li><li><code>canonicalize_headers = false</code>, rewrite request and response headers in Canonical-Camel-Dash-Format.</li><li><code>proxy = proxyurl</code>, pass request through a proxy given as a url; alternatively, the <code>http_proxy</code>, <code>HTTP_PROXY</code>, <code>https_proxy</code>, <code>HTTPS_PROXY</code>, and <code>no_proxy</code> environment variables are also detected/used; if set, they will be used automatically when making requests.</li><li><code>detect_content_type = false</code>: if <code>true</code> and the request body is not a form or <code>IO</code>, it will be  inspected and the &quot;Content-Type&quot; header will be set to the detected content type.</li><li><code>decompress = nothing</code>, by default, decompress the response body if the response has a  &quot;Content-Encoding&quot; header set to &quot;gzip&quot;. If <code>decompress=true</code>, decompress the response body  regardless of <code>Content-Encoding</code> header. If <code>decompress=false</code>, do not decompress the response body.</li></ul><p>Retry arguments:</p><ul><li><code>retry = true</code>, retry idempotent requests in case of error.</li><li><code>retries = 4</code>, number of times to retry.</li><li><code>retry_non_idempotent = false</code>, retry non-idempotent requests too. e.g. POST.</li></ul><p>Redirect arguments:</p><ul><li><code>redirect = true</code>, follow 3xx redirect responses; i.e. additional requests will be made to the redirected location</li><li><code>redirect_limit = 3</code>, maximum number of times a redirect will be followed</li><li><code>redirect_method = nothing</code>, the method to use for the redirected request; by default,  GET will be used, only responses with 307/308 will use the same original request method.  Pass <code>redirect_method=:same</code> to pass the same method as the orginal request though note that some servers  may not respond/accept the same method. It&#39;s also valid to pass the exact method to use  as a string, like <code>redirect_method=&quot;PUT&quot;</code>.</li><li><code>forwardheaders = true</code>, forward original headers on redirect.</li></ul><p>SSL arguments:</p><ul><li><code>require_ssl_verification = NetworkOptions.verify_host(host)</code>, pass <code>MBEDTLS_SSL_VERIFY_REQUIRED</code> to the mbed TLS library. <a href="https://tls.mbed.org/api/ssl_8h.html#a5695285c9dbfefec295012b566290f37">&quot;... peer must present a valid certificate, handshake is aborted if   verification failed.&quot;</a></li><li><code>sslconfig = SSLConfig(require_ssl_verification)</code></li></ul><p>Cookie arguments:</p><ul><li><code>cookies::Union{Bool, Dict{&lt;:AbstractString, &lt;:AbstractString}} = true</code>, enable cookies, or alternatively,      pass a <code>Dict{AbstractString, AbstractString}</code> of name-value pairs to manually pass cookies in the request &quot;Cookie&quot; header</li><li><code>cookiejar::HTTP.CookieJar=HTTP.COOKIEJAR</code>: threadsafe cookie jar struct for keeping track of cookies per host;  a global cookie jar is used by default.</li></ul><p><strong>Request Body Examples</strong></p><p>String body:</p><pre><code class="language-julia hljs">HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], &quot;post body data&quot;)</code></pre><p>Stream body from file:</p><pre><code class="language-julia hljs">io = open(&quot;post_data.txt&quot;, &quot;r&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], io)</code></pre><p>Generator body:</p><pre><code class="language-julia hljs">chunks = (&quot;chunk$i&quot; for i in 1:1000)
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p>Collection body:</p><pre><code class="language-julia hljs">chunks = [preamble_chunk, data_chunk, checksum(data_chunk)]
HTTP.request(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;, [], chunks)</code></pre><p><code>open() do io</code> body:</p><pre><code class="language-julia hljs">HTTP.open(&quot;POST&quot;, &quot;http://httpbin.org/post&quot;) do io
    write(io, preamble_chunk)
    write(io, data_chunk)
    write(io, checksum(data_chunk))
end</code></pre><p><strong>Response Body Examples</strong></p><p>String body:</p><pre><code class="language-julia hljs">r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;)
println(String(r.body))</code></pre><p>Stream body to file:</p><pre><code class="language-julia hljs">io = open(&quot;get_data.txt&quot;, &quot;w&quot;)
r = HTTP.request(&quot;GET&quot;, &quot;http://httpbin.org/get&quot;, response_stream=io)
close(io)
println(read(&quot;get_data.txt&quot;))</code></pre><p>Stream body through buffer:</p><pre><code class="language-julia hljs">r = HTTP.get(&quot;http://httpbin.org/get&quot;, response_stream=IOBuffer())
println(String(take!(r.body)))</code></pre><p>Stream body through <code>open() do io</code>:</p><pre><code class="language-julia hljs">r = HTTP.open(&quot;GET&quot;, &quot;http://httpbin.org/stream/10&quot;) do io
   while !eof(io)
       println(String(readavailable(io)))
   end
end

HTTP.open(&quot;GET&quot;, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    n = 0
    r = startread(http)
    l = parse(Int, HTTP.header(r, &quot;Content-Length&quot;))
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        while !eof(http)
            bytes = readavailable(http)
            write(vlc, bytes)
            n += length(bytes)
            println(&quot;streamed $n-bytes $((100*n)÷l)%\u1b[1A&quot;)
        end
    end
end</code></pre><p>Interfacing with RESTful JSON APIs:</p><pre><code class="language-julia hljs">using JSON
params = Dict(&quot;user&quot;=&gt;&quot;RAO...tjN&quot;, &quot;token&quot;=&gt;&quot;NzU...Wnp&quot;, &quot;message&quot;=&gt;&quot;Hello!&quot;)
url = &quot;http://api.domain.com/1/messages.json&quot;
r = HTTP.post(url, body=JSON.json(params))
println(JSON.parse(String(r.body)))</code></pre><p>Stream bodies from and to files:</p><pre><code class="language-julia hljs">in = open(&quot;foo.png&quot;, &quot;r&quot;)
out = open(&quot;foo.jpg&quot;, &quot;w&quot;)
HTTP.request(&quot;POST&quot;, &quot;http://convert.com/png2jpg&quot;, [], in, response_stream=out)</code></pre><p>Stream bodies through: <code>open() do io</code>:</p><pre><code class="language-julia hljs">HTTP.open(&quot;POST&quot;, &quot;http://music.com/play&quot;) do io
    write(io, JSON.json([
        &quot;auth&quot; =&gt; &quot;12345XXXX&quot;,
        &quot;song_id&quot; =&gt; 7,
    ]))
    r = startread(io)
    @show r.status
    while !eof(io)
        bytes = readavailable(io)
        play_audio(bytes)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L64-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.get" href="#HTTP.get"><code>HTTP.get</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.get(url [, headers]; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;GET&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L463-L467">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.put" href="#HTTP.put"><code>HTTP.put</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.put(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;PUT&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L470-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.post" href="#HTTP.post"><code>HTTP.post</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.post(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;POST&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L477-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.head" href="#HTTP.head"><code>HTTP.head</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.head(url; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;HEAD&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L491-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.patch" href="#HTTP.patch"><code>HTTP.patch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.patch(url, headers, body; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;PATCH&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L484-L488">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.delete" href="#HTTP.delete"><code>HTTP.delete</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.delete(url [, headers]; &lt;keyword arguments&gt;) -&gt; HTTP.Response</code></pre><p>Shorthand for <code>HTTP.request(&quot;DELETE&quot;, ...)</code>. See <a href="#HTTP.request"><code>HTTP.request</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L498-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.open" href="#HTTP.open"><code>HTTP.open</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">WebSockets.open(handler, url; verbose=false, kw...)</code></pre><p>Initiate a websocket connection to <code>url</code> (which should have schema like <code>ws://</code> or <code>wss://</code>), and call <code>handler(ws)</code> with the websocket connection. Passing <code>verbose=true</code> or <code>verbose=2</code> will enable debug logging for the life of the websocket connection. <code>handler</code> should be a function of the form <code>f(ws) -&gt; nothing</code>, where <code>ws</code> is a <a href="#HTTP.WebSockets.WebSocket"><code>WebSocket</code></a>. Supported keyword arguments are the same as supported by <a href="#HTTP.request"><code>HTTP.request</code></a>. Typical websocket usage is:</p><pre><code class="language-julia hljs">WebSockets.open(url) do ws
    # iterate incoming websocket messages
    for msg in ws
        # send message back to server or do other logic here
        send(ws, msg)
    end
    # iteration ends when the websocket connection is closed by server or error
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L330-L349">source</a></section><section><div><pre><code class="nohighlight hljs">HTTP.open(method, url, [,headers]) do io
    write(io, body)
    [startread(io) -&gt; HTTP.Response]
    while !eof(io)
        readavailable(io) -&gt; AbstractVector{UInt8}
    end
end -&gt; HTTP.Response</code></pre><p>The <code>HTTP.open</code> API allows the request body to be written to (and/or the response body to be read from) an <code>IO</code> stream.</p><p>e.g. Streaming an audio file to the <code>vlc</code> player:</p><pre><code class="language-julia hljs">HTTP.open(:GET, &quot;https://tinyurl.com/bach-cello-suite-1-ogg&quot;) do http
    open(`vlc -q --play-and-exit --intf dummy -`, &quot;w&quot;) do vlc
        write(vlc, http)
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L508-L528">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.download" href="#HTTP.download"><code>HTTP.download</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download(url, [local_path], [headers]; update_period=1, kw...)</code></pre><p>Similar to <code>Base.download</code> this downloads a file, returning the filename. If the <code>local_path</code>:</p><ul><li>is not provided, then it is saved in a temporary directory</li><li>if part to a directory is provided then it is saved into that directory</li><li>otherwise the local path is uses as the filename to save to.</li></ul><p>When saving into a directory, the filename is determined (where possible), from the rules of the HTTP.</p><ul><li><code>update_period</code> controls how often (in seconds) to report the progress.<ul><li>set to <code>Inf</code> to disable reporting</li></ul></li><li><code>headers</code> specifies headers to be used for the HTTP GET request</li><li>any additional keyword args (<code>kw...</code>) are passed on to the HTTP request.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/download.jl#L84-L100">source</a></section></article><h3 id="Request/Response-Objects"><a class="docs-heading-anchor" href="#Request/Response-Objects">Request/Response Objects</a><a id="Request/Response-Objects-1"></a><a class="docs-heading-anchor-permalink" href="#Request/Response-Objects" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.Request" href="#HTTP.Messages.Request"><code>HTTP.Messages.Request</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.Request(method, target, headers=[], body=nobody;
    version=v&quot;1.1&quot;, url::URI=URI(), responsebody=nothing, parent=nothing, context=HTTP.Context())</code></pre><p>Represents a HTTP Request Message with fields:</p><ul><li><p><code>method::String</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.1.1">RFC7230 3.1.1</a></p></li><li><p><code>target::String</code>  <a href="https://tools.ietf.org/html/rfc7230#section-5.3">RFC7230 5.3</a></p></li><li><p><code>version::VersionNumber</code>  <a href="https://tools.ietf.org/html/rfc7230#section-2.6">RFC7230 2.6</a></p></li><li><p><code>headers::HTTP.Headers</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.2">RFC7230 3.2</a></p></li><li><p><code>body::Union{Vector{UInt8}, IO}</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.3">RFC7230 3.3</a></p></li><li><p><code>response</code>, the <code>Response</code> to this <code>Request</code></p></li><li><p><code>url::URI</code>, the full URI of the request</p></li><li><p><code>parent</code>, the <code>Response</code> (if any) that led to this request (e.g. in the case of a redirect).  <a href="https://tools.ietf.org/html/rfc7231#section-6.4">RFC7230 6.4</a></p></li><li><p><code>context</code>, a <code>Dict{Symbol, Any}</code> store used by middleware to share state</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L139-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.Response" href="#HTTP.Messages.Response"><code>HTTP.Messages.Response</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.Response(status, headers::HTTP.Headers, body; request=nothing)
HTTP.Response(status, body)
HTTP.Response(body)</code></pre><p>Represents an HTTP response message with fields:</p><ul><li><p><code>version::VersionNumber</code>  <a href="https://tools.ietf.org/html/rfc7230#section-2.6">RFC7230 2.6</a></p></li><li><p><code>status::Int16</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.1.2">RFC7230 3.1.2</a>  <a href="https://tools.ietf.org/html/rfc7231#section-6">RFC7231 6</a></p></li><li><p><code>headers::Vector{Pair{String,String}}</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.2">RFC7230 3.2</a></p></li><li><p><code>body::Vector{UInt8}</code> or <code>body::IO</code>  <a href="https://tools.ietf.org/html/rfc7230#section-3.3">RFC7230 3.3</a></p></li><li><p><code>request</code>, the <code>Request</code> that yielded this <code>Response</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L73-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Streams.Stream" href="#HTTP.Streams.Stream"><code>HTTP.Streams.Stream</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Stream(::Request, ::IO)</code></pre><p>Creates a <code>HTTP.Stream</code> that wraps an existing <code>IO</code> stream.</p><ul><li><p><code>startwrite(::Stream)</code> sends the <code>Request</code> headers to the <code>IO</code> stream.</p></li><li><p><code>write(::Stream, body)</code> sends the <code>body</code> (or a chunk of the body).</p></li><li><p><code>closewrite(::Stream)</code> sends the final <code>0</code> chunk (if needed) and calls <code>closewrite</code> on the <code>IO</code> stream.</p></li><li><p><code>startread(::Stream)</code> calls <code>startread</code> on the <code>IO</code> stream then  reads and parses the <code>Response</code> headers.</p></li><li><p><code>eof(::Stream)</code> and <code>readavailable(::Stream)</code> parse the body from the <code>IO</code>  stream.</p></li><li><p><code>closeread(::Stream)</code> reads the trailers and calls <code>closeread</code> on the <code>IO</code>  stream.  When the <code>IO</code> stream is a <a href="#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a>,  calling <code>closeread</code> releases the connection back to the connection pool  for reuse. If a complete response has not been received, <code>closeread</code> throws  <code>EOFError</code>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Streams.jl#L19-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.WebSockets.WebSocket" href="#HTTP.WebSockets.WebSocket"><code>HTTP.WebSockets.WebSocket</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">WebSocket(io::HTTP.Connection, req, resp; client=true)</code></pre><p>Representation of a websocket connection. Use <code>WebSockets.open</code> to open a websocket connection, passing a handler function <code>f(ws)</code> to send and receive messages. Use <code>WebSockets.listen</code> to listen for incoming websocket connections, passing a handler function <code>f(ws)</code> to send and receive messages.</p><p>Call <code>send(ws, msg)</code> to send a message; if <code>msg</code> is an <code>AbstractString</code>, a TEXT websocket message will be sent; if <code>msg</code> is an <code>AbstractVector{UInt8}</code>, a BINARY websocket message will be sent. Otherwise, <code>msg</code> should be an iterable of either <code>AbstractString</code> or <code>AbstractVector{UInt8}</code>, and a fragmented message will be sent, one frame for each iterated element.</p><p>Control frames can be sent by calling <code>ping(ws[, data])</code>, <code>pong(ws[, data])</code>, or <code>close(ws[, body::WebSockets.CloseFrameBody])</code>. Calling <code>close</code> will initiate the close sequence and close the underlying connection.</p><p>To receive messages, call <code>receive(ws)</code>, which will block until a non-control, full message is received. PING messages will automatically be responded to when received. CLOSE messages will also be acknowledged and then a <code>WebSocketError</code> will be thrown with the <code>WebSockets.CloseFrameBody</code> payload, which may include a non-error CLOSE frame status code. <code>WebSockets.isok(err)</code> can be called to check if the CLOSE was normal or unexpected. Fragmented messages will be received until the final frame is received and the full concatenated payload can be returned. <code>receive(ws)</code> returns a <code>Vector{UInt8}</code> for BINARY messages, and a <code>String</code> for TEXT messages.</p><p>For convenience, <code>WebSocket</code>s support the iteration protocol, where each iteration will <code>receive</code> a non-control message, with iteration terminating when the connection is closed. E.g.:</p><pre><code class="language-julia hljs">WebSockets.open(url) do ws
    for msg in ws
        # do cool stuff with msg
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L244-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.header" href="#HTTP.Messages.header"><code>HTTP.Messages.header</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.header(::Message, key [, default=&quot;&quot;]) -&gt; String</code></pre><p>Get header value for <code>key</code> (case-insensitive).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L330-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.headers" href="#HTTP.Messages.headers"><code>HTTP.Messages.headers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.headers(m::Message, key) -&gt; Vector{String}</code></pre><p>Get all headers with key <code>k</code> or empty if none</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L339-L343">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.hasheader" href="#HTTP.Messages.hasheader"><code>HTTP.Messages.hasheader</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.hasheader(::Message, key) -&gt; Bool</code></pre><p>Does header value for <code>key</code> exist (case-insensitive)?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L349-L353">source</a></section><section><div><pre><code class="nohighlight hljs">HTTP.hasheader(::Message, key, value) -&gt; Bool</code></pre><p>Does header for <code>key</code> match <code>value</code> (both case-insensitive)?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.headercontains" href="#HTTP.Messages.headercontains"><code>HTTP.Messages.headercontains</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.headercontains(::Message, key, value) -&gt; Bool</code></pre><p>Does the header for <code>key</code> (interpreted as comma-separated list) contain <code>value</code> (both case-insensitive)?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.setheader" href="#HTTP.Messages.setheader"><code>HTTP.Messages.setheader</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.setheader(::Message, key =&gt; value)</code></pre><p>Set header <code>value</code> for <code>key</code> (case-insensitive).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.appendheader" href="#HTTP.Messages.appendheader"><code>HTTP.Messages.appendheader</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.appendheader(::Message, key =&gt; value)</code></pre><p>Append a header value to <code>message.headers</code>.</p><p>If <code>key</code> is the same as the previous header, the <code>value</code> is <a href="https://stackoverflow.com/a/24502264">appended to the value of the previous header with a comma delimiter</a></p><p><code>Set-Cookie</code> headers are not comma-combined because <a href="https://tools.ietf.org/html/rfc6265#section-3">cookies often contain internal commas</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L397-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.removeheader" href="#HTTP.Messages.removeheader"><code>HTTP.Messages.removeheader</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.removeheader(::Message, key)</code></pre><p>Remove header for <code>key</code> (case-insensitive).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L420-L424">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.decode" href="#HTTP.Messages.decode"><code>HTTP.Messages.decode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.decode(r::Union{Request, Response}) -&gt; Vector{UInt8}</code></pre><p>For a gzip encoded request/response body, decompress it and return the decompressed body.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L437-L442">source</a></section></article><h3 id="Request-body-types"><a class="docs-heading-anchor" href="#Request-body-types">Request body types</a><a id="Request-body-types-1"></a><a class="docs-heading-anchor-permalink" href="#Request-body-types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Forms.Form" href="#HTTP.Forms.Form"><code>HTTP.Forms.Form</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.Form(data; boundary=string(rand(UInt128), base=16))</code></pre><p>Construct a request body for multipart/form-data encoding from <code>data</code>.</p><p><code>data</code> must iterate key-value pairs (e.g. <code>Dict</code> or <code>Vector{Pair}</code>) where the key/value of the iterator is the key/value of each mutipart boundary chunk. Files and other large data arguments can be provided as values as IO arguments: either an <code>IOStream</code> such as returned via <code>open(file)</code>, or an <code>IOBuffer</code> for in-memory data.</p><p>For complete control over a multipart chunk&#39;s details, an <a href="#HTTP.Forms.Multipart"><code>HTTP.Multipart</code></a> type is provided to support setting the <code>filename</code>, <code>Content-Type</code>, and <code>Content-Transfer-Encoding</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">data = Dict(
    &quot;text&quot; =&gt; &quot;text data&quot;,
    # filename (cat.png) and content-type (image/png) inferred from the IOStream
    &quot;file1&quot; =&gt; open(&quot;cat.png&quot;),
    # manully controlled chunk
    &quot;file2&quot; =&gt; HTTP.Multipart(&quot;dog.jpeg&quot;, open(&quot;mydog.jpg&quot;), &quot;image/jpeg&quot;),
)
body = HTTP.Form(data)
headers = []
HTTP.post(url, headers, body)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/multipart.jl#L75-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Forms.Multipart" href="#HTTP.Forms.Multipart"><code>HTTP.Forms.Multipart</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.Multipart(filename::String, data::IO, content_type=HTTP.sniff(data), content_transfer_encoding=&quot;&quot;)</code></pre><p>A type to represent a single multipart upload chunk for a file. This type would be used as the value in a key-value pair when constructing a <a href="#HTTP.Forms.Form"><code>HTTP.Form</code></a> for a request body (see example below). The <code>data</code> argument must be an <code>IO</code> type such as <code>IOStream</code>, or <code>IOBuffer</code>. The <code>content_type</code> and <code>content_transfer_encoding</code> arguments allow manual setting of these multipart headers. <code>Content-Type</code> will default to the result of the <code>HTTP.sniff(data)</code> mimetype detection algorithm, whereas <code>Content-Transfer-Encoding</code> will be left out if not specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">body = HTTP.Form(Dict(
    &quot;key&quot; =&gt; HTTP.Multipart(&quot;File.txt&quot;, open(&quot;MyFile.txt&quot;), &quot;text/plain&quot;),
))
headers = []
HTTP.post(url, headers, body)</code></pre><p><strong>Extended help</strong></p><p>Filename SHOULD be included when the Multipart represents the contents of a file <a href="https://tools.ietf.org/html/rfc7578#section-4.2">RFC7578 4.2</a></p><p>Content-Disposition set to &quot;form-data&quot; MUST be included with each Multipart. An additional &quot;name&quot; parameter MUST be included An optional &quot;filename&quot; parameter SHOULD be included if the contents of a file are sent This will be formatted such as:   Content-Disposition: form-data; name=&quot;user&quot;; filename=&quot;myfile.txt&quot; <a href="https://tools.ietf.org/html/rfc7578#section-4.2">RFC7578 4.2</a></p><p>Content-Type for each Multipart is optional, but SHOULD be included if the contents of a file are sent. <a href="https://tools.ietf.org/html/rfc7578#section-4.4">RFC7578 4.4</a></p><p>Content-Transfer-Encoding for each Multipart is deprecated <a href="https://tools.ietf.org/html/rfc7578#section-4.7">RFC7578 4.7</a></p><p>Other Content- header fields MUST be ignored <a href="https://tools.ietf.org/html/rfc7578#section-4.8">RFC7578 4.8</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/multipart.jl#L142-L182">source</a></section></article><h3 id="Request-exceptions"><a class="docs-heading-anchor" href="#Request-exceptions">Request exceptions</a><a id="Request-exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Request-exceptions" title="Permalink"></a></h3><p>Request functions may throw the following exceptions:</p><article class="docstring"><header><a class="docstring-binding" id="HTTP.Exceptions.ConnectError" href="#HTTP.Exceptions.ConnectError"><code>HTTP.Exceptions.ConnectError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.ConnectError</code></pre><p>Raised when an error occurs while trying to establish a request connection to the remote server. To see the underlying error, see the <code>error</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Exceptions.jl#L63-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Exceptions.TimeoutError" href="#HTTP.Exceptions.TimeoutError"><code>HTTP.Exceptions.TimeoutError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.TimeoutError</code></pre><p>Raised when a request times out according to <code>readtimeout</code> keyword argument provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Exceptions.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Exceptions.StatusError" href="#HTTP.Exceptions.StatusError"><code>HTTP.Exceptions.StatusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.StatusError</code></pre><p>Raised when an <code>HTTP.Response</code> has a <code>4xx</code>, <code>5xx</code> or unrecognised status code.</p><p>Fields:</p><ul><li><code>status::Int16</code>, the response status code.</li><li><code>method::String</code>, the request method.</li><li><code>target::String</code>, the request target.</li><li><code>response</code>, the <a href="#HTTP.Messages.Response"><code>HTTP.Response</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Exceptions.jl#L86-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Exceptions.RequestError" href="#HTTP.Exceptions.RequestError"><code>HTTP.Exceptions.RequestError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.RequestError</code></pre><p>Raised when an error occurs while physically sending a request to the remote server or reading the response back. To see the underlying error, see the <code>error</code> field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Exceptions.jl#L104-L109">source</a></section></article><h3 id="URIs"><a class="docs-heading-anchor" href="#URIs">URIs</a><a id="URIs-1"></a><a class="docs-heading-anchor-permalink" href="#URIs" title="Permalink"></a></h3><p>HTTP.jl uses the <a href="https://github.com/JuliaWeb/URIs.jl">URIs.jl</a> package for handling URIs. Some functionality from URIs.jl, relevant to HTTP.jl, are listed below:</p><article class="docstring"><header><a class="docstring-binding" id="URIs.URI" href="#URIs.URI"><code>URIs.URI</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">URI(; scheme=&quot;&quot;, host=&quot;&quot;, port=&quot;&quot;, etc...)
URI(str) = parse(URI, str::String)</code></pre><p>A type representing a URI (e.g. a URL). Can be constructed from distinct parts using the various supported keyword arguments, or from a string. The <code>URI</code> constructors will automatically escape any provided <code>query</code> arguments, typically provided as <code>&quot;key&quot;=&gt;&quot;value&quot;::Pair</code> or <code>Dict(&quot;key&quot;=&gt;&quot;value&quot;)</code>. Note that multiple values for a single query key can provided like <code>Dict(&quot;key&quot;=&gt;[&quot;value1&quot;, &quot;value2&quot;])</code>.</p><p>When constructing a <code>URI</code> from a <code>String</code>, you need to first unescape that string: <code>URI( URIs.unescapeuri(str) )</code>.</p><p>The <code>URI</code> struct stores the complete URI in the <code>uri::String</code> field and the component parts in the following <code>SubString</code> fields:</p><ul><li><code>scheme</code>, e.g. <code>&quot;http&quot;</code> or <code>&quot;https&quot;</code></li><li><code>userinfo</code>, e.g. <code>&quot;username:password&quot;</code></li><li><code>host</code> e.g. <code>&quot;julialang.org&quot;</code></li><li><code>port</code> e.g. <code>&quot;80&quot;</code> or <code>&quot;&quot;</code></li><li><code>path</code> e.g <code>&quot;/&quot;</code></li><li><code>query</code> e.g. <code>&quot;Foo=1&amp;Bar=2&quot;</code></li><li><code>fragment</code></li></ul><p>The <code>queryparams(::URI)</code> function returns a <code>Dict</code> containing the <code>query</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="URIs.escapeuri" href="#URIs.escapeuri"><code>URIs.escapeuri</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">escapeuri(x)</code></pre><p>Apply URI percent-encoding to escape special characters in <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="URIs.unescapeuri" href="#URIs.unescapeuri"><code>URIs.unescapeuri</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unescapeuri(str)</code></pre><p>Percent-decode a string according to the URI escaping rules.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="URIs.splitpath" href="#URIs.splitpath"><code>URIs.splitpath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">URIs.splitpath(path|uri; rstrip_empty_segment=true)</code></pre><p>Splits the path into component segments based on <code>/</code>, according to http://tools.ietf.org/html/rfc3986#section-3.3. Any fragment and query parts of the string are ignored if present.</p><p>A final empty path segment (trailing &#39;/&#39;) is removed, if present. This is technically incompatible with the segment grammar of RFC3986, but it seems to be a common recommendation to make paths with and without a trailing slash equivalent. To preserve any final empty path segment, set <code>rstrip_empty_segment=false</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; URIs.splitpath(URI(&quot;http://example.com/foo/bar?a=b&amp;c=d&quot;))
2-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;

julia&gt; URIs.splitpath(&quot;/foo/bar/&quot;)
2-element Array{String,1}:
 &quot;foo&quot;
 &quot;bar&quot;</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isvalid-Tuple{URI}" href="#Base.isvalid-Tuple{URI}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>checks if a <code>URI</code> is valid</p></div></section></article><h3 id="Cookies"><a class="docs-heading-anchor" href="#Cookies">Cookies</a><a id="Cookies-1"></a><a class="docs-heading-anchor-permalink" href="#Cookies" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.Cookie" href="#HTTP.Cookies.Cookie"><code>HTTP.Cookies.Cookie</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Cookie()
Cookie(; kwargs...)
Cookie(name, value; kwargs...)</code></pre><p>A <code>Cookie</code> represents an HTTP cookie as sent in the <code>&quot;Set-Cookie&quot;</code> header of an HTTP response or the Cookie header of an HTTP request. Supported fields (which can be set using keyword arguments) include:</p><ul><li><code>name::String</code>: name of the cookie</li><li><code>value::String</code>: value of the cookie</li><li><code>path::String</code>: applicable path for the cookie</li><li><code>domain::String</code>: applicable domain for the cookie</li><li><code>expires::Dates.DateTime</code>: when the cookie should expire</li><li><code>maxage::Int</code>: <code>maxage == 0</code> means no max age, <code>maxage &lt; 0</code> means delete cookie now, <code>maxage &gt; 0</code> means the # of seconds until expiration</li><li><code>secure::Bool</code>: secure cookie attribute</li><li><code>httponly::Bool</code>: httponly cookie attribute</li><li><code>hostonly::Bool</code>: hostonly cookie attribute</li><li><code>samesite::Bool</code>: SameSite cookie attribute</li></ul><p>See <a href="http://tools.ietf.org/html/rfc6265">IETF RFC 6265</a> for details.</p><p>The string representation of a cookie is generated by calling <a href="#HTTP.Cookies.stringify"><code>stringify(cookie; isrequest=true)</code></a>, where <code>isrequest=true</code> will only include the <code>name=value</code> pair for requests, and if <code>false</code>, will generate the <code>&quot;Set-Cookie&quot;</code> representation for a response header.</p><p>A <code>Vector{Cookie}</code> can be retrieved from a <code>Request</code>/<code>Response</code> object by calling <a href="#HTTP.Cookies.cookies"><code>Cookies.cookies(r)</code></a>.</p><p>A <code>Cookie</code> can be added to a <code>Request</code>/<code>Response</code> object by calling <a href="#HTTP.Cookies.addcookie!"><code>Cookies.addcookie!(r, cookie)</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/cookies.jl#L41-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.stringify" href="#HTTP.Cookies.stringify"><code>HTTP.Cookies.stringify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stringify(cookie::Cookie, isrequest=true)</code></pre><p>Generate the string representation of a cookie. By default, <code>isrequest=true</code>, and only the <code>name=value</code> pair will be included in the cookie string. For <code>isrequest=false</code>, the other cookie attributes will be included, <code>;</code>-separated, for use in a &quot;Set-Cookie&quot; header.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/cookies.jl#L127-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.addcookie!" href="#HTTP.Cookies.addcookie!"><code>HTTP.Cookies.addcookie!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Cookies.addcookie!(r::Union{HTTP.Request, HTTP.Response}, c::Cookie)</code></pre><p>Convenience function for adding a single cookie to a request or response object. For requests, the cookie will be stringified and concatenated to any existing &quot;Cookie&quot; header. For responses, an additional &quot;Set-Cookie&quot; header will be appended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/cookies.jl#L169-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.cookies" href="#HTTP.Cookies.cookies"><code>HTTP.Cookies.cookies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.cookies(r::Union{Request, Response}) -&gt; Vector{Cookie}</code></pre><p>Return a list of cookies, if any, parsed from the request &quot;Cookie&quot; or response &quot;Set-Cookie&quot; headers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/cookies.jl#L312-L317">source</a></section></article><h3 id="WebSockets"><a class="docs-heading-anchor" href="#WebSockets">WebSockets</a><a id="WebSockets-1"></a><a class="docs-heading-anchor-permalink" href="#WebSockets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Sockets.send-Tuple{HTTP.WebSockets.WebSocket, Any}" href="#Sockets.send-Tuple{HTTP.WebSockets.WebSocket, Any}"><code>Sockets.send</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">send(ws::WebSocket, msg)</code></pre><p>Send a message on a websocket connection. If <code>msg</code> is an <code>AbstractString</code>, a TEXT websocket message will be sent; if <code>msg</code> is an <code>AbstractVector{UInt8}</code>, a BINARY websocket message will be sent. Otherwise, <code>msg</code> should be an iterable of either <code>AbstractString</code> or <code>AbstractVector{UInt8}</code>, and a fragmented message will be sent, one frame for each iterated element.</p><p>Control frames can be sent by calling <code>ping(ws[, data])</code>, <code>pong(ws[, data])</code>, or <code>close(ws[, body::WebSockets.CloseFrameBody])</code>. Calling <code>close</code> will initiate the close sequence and close the underlying connection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L477-L489">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.WebSockets.receive" href="#HTTP.WebSockets.receive"><code>HTTP.WebSockets.receive</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">receive(ws::WebSocket) -&gt; Union{String, Vector{UInt8}}</code></pre><p>Receive a message from a websocket connection. Returns a <code>String</code> if the message was TEXT, or a <code>Vector{UInt8}</code> if the message was BINARY. If control frames (ping or pong) are received, they are handled automatically and a non-control message is waited for. If a CLOSE message is received, it is responded to and a <code>WebSocketError</code> is thrown with the <code>WebSockets.CloseFrameBody</code> as the error value. This error can be checked with <code>WebSockets.isok(err)</code> to see if the closing was &quot;normal&quot; or if an actual error occurred. For fragmented messages, the incoming frames will continue to be read until the final fragment is received. The bodies of each fragment are concatenated into the final message returned by <code>receive</code>. Note that <code>WebSocket</code> objects can be iterated, where each iteration yields a message until the connection is closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L639-L654">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>HTTP.WebSockets.close(::HTTP.WebSockets.WebSocket, body)</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="HTTP.WebSockets.ping" href="#HTTP.WebSockets.ping"><code>HTTP.WebSockets.ping</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ping(ws, data=[])</code></pre><p>Send a PING control frame on a websocket connection. <code>data</code> is an optional body to send with the message. PONG messages are automatically responded to when a PING message is received by a websocket connection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L524-L530">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.WebSockets.pong" href="#HTTP.WebSockets.pong"><code>HTTP.WebSockets.pong</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pong(ws, data=[])</code></pre><p>Send a PONG control frame on a websocket connection. <code>data</code> is an optional body to send with the message. Note that PING messages are automatically responded to internally by the websocket connection with a corresponding PONG message, but in certain cases, a unidirectional PONG message can be used as a one-way heartbeat.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L537-L545">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iterate-Tuple{HTTP.WebSockets.WebSocket, Any}" href="#Base.iterate-Tuple{HTTP.WebSockets.WebSocket, Any}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iterate(ws)</code></pre><p>Continuously call <code>receive(ws)</code> on a <code>WebSocket</code> connection, with each iteration yielding a message until the connection is closed. E.g.</p><pre><code class="language-julia hljs">for msg in ws
    # do something with msg
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L682-L693">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.WebSockets.isclosed" href="#HTTP.WebSockets.isclosed"><code>HTTP.WebSockets.isclosed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">WebSockets.isclosed(ws) -&gt; Bool</code></pre><p>Check whether a <code>WebSocket</code> has sent and received CLOSE frames.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L303-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.WebSockets.isok" href="#HTTP.WebSockets.isok"><code>HTTP.WebSockets.isok</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">WebSockets.isok(x::WebSocketError) -&gt; Bool</code></pre><p>Returns true if the <code>WebSocketError</code> has a non-error status code. When calling <code>receive(websocket)</code>, if a CLOSE frame is received, the CLOSE frame body is parsed and thrown inside the <code>WebSocketError</code>, but if the CLOSE frame has a non-error status code, it&#39;s safe to ignore the error and return from the <code>WebSockets.open</code> or <code>WebSockets.listen</code> calls without throwing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L232-L241">source</a></section></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HTTP.Sniff.sniff" href="#HTTP.Sniff.sniff"><code>HTTP.Sniff.sniff</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.sniff(content::Union{Vector{UInt8}, String, IO}) =&gt; String (mimetype)</code></pre><p><code>HTTP.sniff</code> will look at the first 512 bytes of <code>content</code> to try and determine a valid mimetype. If a mimetype can&#39;t be determined appropriately, <code>&quot;application/octet-stream&quot;</code> is returned.</p><p>Supports JSON detection through the <code>HTTP.isjson(content)</code> function.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; HTTP.sniff(&quot;Hello world!!&quot;)
&quot;text/plain; charset=utf-8&quot;

julia&gt; HTTP.sniff(&quot;&lt;html&gt;&lt;body&gt;Hello world!!&lt;/body&gt;&lt;/html&gt;&quot;)
&quot;text/html; charset=utf-8&quot;

julia&gt; HTTP.sniff(&quot;{&quot;a&quot;: -1.0}&quot;)
&quot;application/json; charset=utf-8&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/sniff.jl#L26-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Strings.escapehtml" href="#HTTP.Strings.escapehtml"><code>HTTP.Strings.escapehtml</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">escapehtml(i::String)</code></pre><p>Returns a string with special HTML characters escaped: &amp;, &lt;, &gt;, &quot;, &#39;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Strings.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Strings.tocameldash" href="#HTTP.Strings.tocameldash"><code>HTTP.Strings.tocameldash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tocameldash(s::String)</code></pre><p>Ensure the first character and characters that follow a &#39;-&#39; are uppercase.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Strings.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Strings.iso8859_1_to_utf8" href="#HTTP.Strings.iso8859_1_to_utf8"><code>HTTP.Strings.iso8859_1_to_utf8</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iso8859_1_to_utf8(bytes::AbstractVector{UInt8})</code></pre><p>Convert from ISO8859_1 to UTF8.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Strings.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Strings.ascii_lc_isequal" href="#HTTP.Strings.ascii_lc_isequal"><code>HTTP.Strings.ascii_lc_isequal</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Case insensitive ASCII character comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Strings.jl#L72-L74">source</a></section><section><div><pre><code class="nohighlight hljs">HTTP.ascii_lc_isequal(a::String, b::String)</code></pre><p>Case insensitive ASCII string comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Strings.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.statustext" href="#HTTP.Messages.statustext"><code>HTTP.Messages.statustext</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">statustext(::Int) -&gt; String</code></pre><p><code>String</code> representation of a HTTP status code.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; statustext(200)
&quot;OK&quot;

julia&gt; statustext(404)
&quot;Not Found&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/status_messages.jl#L1-L14">source</a></section></article><h2 id="Server-/-Handlers"><a class="docs-heading-anchor" href="#Server-/-Handlers">Server / Handlers</a><a id="Server-/-Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Server-/-Handlers" title="Permalink"></a></h2><h3 id="Core-Server"><a class="docs-heading-anchor" href="#Core-Server">Core Server</a><a id="Core-Server-1"></a><a class="docs-heading-anchor-permalink" href="#Core-Server" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Servers.listen" href="#HTTP.Servers.listen"><code>HTTP.Servers.listen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.listen(handler, host=Sockets.localhost, port=8081; kw...)
HTTP.listen(handler, port::Integer=8081; kw...)
HTTP.listen(handler, server::Base.IOServer; kw...)
HTTP.listen!(args...; kw...) -&gt; HTTP.Server</code></pre><p>Listen for HTTP connections and execute the <code>handler</code> function for each request. Listening details can be passed as <code>host</code>/<code>port</code> pair, a single <code>port</code> (<code>host</code> will default to <code>localhost</code>), or an already listening <code>server</code> object, as returned from <code>Sockets.listen</code>. To open up a server to external requests, the <code>host</code> argument is typically <code>&quot;0.0.0.0&quot;</code>.</p><p>The <code>HTTP.listen!</code> form is non-blocking and returns an <code>HTTP.Server</code> object which can be <code>wait(server)</code>ed on manually, or <code>close(server)</code>ed to gracefully shut down the server. Calling <code>HTTP.forceclose(server)</code> will immediately force close the server and all active connections. <code>HTTP.listen</code> will block on the server listening loop until interrupted or and an irrecoverable error occurs.</p><p>The <code>handler</code> function should be of the form <code>f(::HTTP.Stream)::Nothing</code>, and should at the minimum set a status via <code>setstatus()</code> and call <code>startwrite()</code> either explicitly or implicitly by writing out a response via <code>write()</code>. Failure to do this will result in an HTTP 500 error being transmitted to the client.</p><p>Optional keyword arguments:</p><ul><li><code>sslconfig=nothing</code>, Provide an <code>MbedTLS.SSLConfig</code> object to handle ssl  connections. Pass <code>sslconfig=MbedTLS.SSLConfig(false)</code> to disable ssl  verification (useful for testing). Construct a custom <code>SSLConfig</code> object  with <code>MbedTLS.SSLConfig(certfile, keyfile)</code>.</li><li><code>tcpisvalid = tcp-&gt;true</code>, function <code>f(::TCPSocket)::Bool</code> to check if accepted  connections are valid before processing requests. e.g. to do source IP filtering.</li><li><code>readtimeout::Int=0</code>, close the connection if no data is received for this  many seconds. Use readtimeout = 0 to disable.</li><li><code>reuseaddr::Bool=false</code>, allow multiple servers to listen on the same port.  Not supported on some OS platforms. Can check <code>HTTP.Servers.supportsreuseaddr()</code>.</li><li><code>server::Base.IOServer=nothing</code>, provide an <code>IOServer</code> object to listen on;  allows manually closing or configuring the server socket.</li><li><code>verbose::Bool=false</code>, log connection information to <code>stdout</code>.</li><li><code>access_log::Function</code>, function for formatting access log messages. The  function should accept two arguments, <code>io::IO</code> to which the messages should  be written, and <code>http::HTTP.Stream</code> which can be used to query information  from. See also <a href="#HTTP.@logfmt_str"><code>@logfmt_str</code></a>.</li><li><code>on_shutdown::Union{Function, Vector{&lt;:Function}, Nothing}=nothing</code>, one or  more functions to be run if the server is closed (for example by an  <code>InterruptException</code>). Note, shutdown function(s) will not run if an  <code>IOServer</code> object is supplied to the <code>server</code> keyword argument and closed  by <code>close(server)</code>.</li></ul><p>e.g.</p><pre><code class="language-julia hljs"># start a blocking server
HTTP.listen(&quot;127.0.0.1&quot;, 8081) do http
    HTTP.setheader(http, &quot;Content-Type&quot; =&gt; &quot;text/html&quot;)
    write(http, &quot;target uri: $(http.message.target)&lt;BR&gt;&quot;)
    write(http, &quot;request body:&lt;BR&gt;&lt;PRE&gt;&quot;)
    write(http, read(http))
    write(http, &quot;&lt;/PRE&gt;&quot;)
    return
end

# non-blocking server
server = HTTP.listen!(&quot;127.0.0.1&quot;, 8081) do http
    @show http.message
    @show HTTP.header(http, &quot;Content-Type&quot;)
    while !eof(http)
        println(&quot;body data: &quot;, String(readavailable(http)))
    end
    HTTP.setstatus(http, 404)
    HTTP.setheader(http, &quot;Foo-Header&quot; =&gt; &quot;bar&quot;)
    startwrite(http)
    write(http, &quot;response body&quot;)
    write(http, &quot;more response body&quot;)
end
# can gracefully close server manually
close(server)</code></pre><p>To run the following HTTP chat example, open two Julia REPL windows and paste the example code into both of them. Then in one window run <code>chat_server()</code> and in the other run <code>chat_client()</code>, then type <code>hello</code> and press return. Whatever you type on the client will be displayed on the server and vis-versa.</p><pre><code class="nohighlight hljs">using HTTP

function chat(io::HTTP.Stream)
    @async while !eof(io)
        write(stdout, readavailable(io), &quot;\n&quot;)
    end
    while isopen(io)
        write(io, readline(stdin))
    end
end

chat_server() = HTTP.listen(&quot;127.0.0.1&quot;, 8087) do io
    write(io, &quot;HTTP.jl Chat Server. Welcome!&quot;)
    chat(io)
end

chat_client() = HTTP.open(&quot;POST&quot;, &quot;http://127.0.0.1:8087&quot;) do io
    chat(io)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Servers.jl#L201-L303">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.serve" href="#HTTP.Handlers.serve"><code>HTTP.Handlers.serve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.serve(handler, host=Sockets.localhost, port=8081; kw...)
HTTP.serve(handler, port::Integer=8081; kw...)
HTTP.serve(handler, server::Base.IOServer; kw...)
HTTP.serve!(args...; kw...) -&gt; HTTP.Server</code></pre><p>Listen for HTTP connections and execute the <code>handler</code> function for each request. Listening details can be passed as <code>host</code>/<code>port</code> pair, a single <code>port</code> (<code>host</code> will default to <code>localhost</code>), or an already listening <code>server</code> object, as returned from <code>Sockets.listen</code>. To open up a server to external requests, the <code>host</code> argument is typically <code>&quot;0.0.0.0&quot;</code>.</p><p>The <code>HTTP.serve!</code> form is non-blocking and returns an <code>HTTP.Server</code> object which can be <code>wait(server)</code>ed on manually, or <code>close(server)</code>ed to gracefully shut down the server. Calling <code>HTTP.forceclose(server)</code> will immediately force close the server and all active connections. <code>HTTP.serve</code> will block on the server listening loop until interrupted or and an irrecoverable error occurs.</p><p>The <code>handler</code> function should be of the form <code>f(req::HTTP.Request)::HTTP.Response</code>. Alternatively, passing <code>stream=true</code> requires the <code>handler</code> to be of the form <code>f(stream::HTTP.Stream) -&gt; Nothing</code>. See <a href="#HTTP.Handlers.Router"><code>HTTP.Router</code></a> for details on using it as a request handler.</p><p>Optional keyword arguments:</p><ul><li><code>sslconfig=nothing</code>, Provide an <code>MbedTLS.SSLConfig</code> object to handle ssl</li></ul><p>connections. Pass <code>sslconfig=MbedTLS.SSLConfig(false)</code> to disable ssl verification (useful for testing). Construct a custom <code>SSLConfig</code> object with <code>MbedTLS.SSLConfig(certfile, keyfile)</code>.</p><ul><li><code>tcpisvalid = tcp-&gt;true</code>, function <code>f(::TCPSocket)::Bool</code> to check if accepted</li></ul><p>connections are valid before processing requests. e.g. to do source IP filtering.</p><ul><li><code>readtimeout::Int=0</code>, close the connection if no data is received for this</li></ul><p>many seconds. Use readtimeout = 0 to disable.</p><ul><li><code>reuseaddr::Bool=false</code>, allow multiple servers to listen on the same port.</li></ul><p>Not supported on some OS platforms. Can check <code>HTTP.Servers.supportsreuseaddr()</code>.</p><ul><li><code>server::Base.IOServer=nothing</code>, provide an <code>IOServer</code> object to listen on;</li></ul><p>allows manually closing or configuring the server socket.</p><ul><li><code>verbose::Bool=false</code>, log connection information to <code>stdout</code>.</li><li><code>access_log::Function</code>, function for formatting access log messages. The</li></ul><p>function should accept two arguments, <code>io::IO</code> to which the messages should be written, and <code>http::HTTP.Stream</code> which can be used to query information from. See also <a href="@ref"><code>@logfmt_str</code></a>.</p><ul><li><code>on_shutdown::Union{Function, Vector{&lt;:Function}, Nothing}=nothing</code>, one or</li></ul><p>more functions to be run if the server is closed (for example by an <code>InterruptException</code>). Note, shutdown function(s) will not run if an <code>IOServer</code> object is supplied to the <code>server</code> keyword argument and closed by <code>close(server)</code>.</p><pre><code class="language-julia hljs"># start a blocking echo server
HTTP.serve(&quot;127.0.0.1&quot;, 8081) do req
    return HTTP.Response(200, req.body)
end

# non-blocking server
server = HTTP.serve!(8081) do req
    return HTTP.Response(200, &quot;response body&quot;)
end
# can gracefully close server manually
close(server)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L69-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.WebSockets.listen" href="#HTTP.WebSockets.listen"><code>HTTP.WebSockets.listen</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">WebSockets.listen(handler, host, port; verbose=false, kw...)
WebSockets.listen!(handler, host, port; verbose=false, kw...) -&gt; HTTP.Server</code></pre><p>Listen for websocket connections on <code>host</code> and <code>port</code>, and call <code>handler(ws)</code>, which should be a function taking a single <code>WebSocket</code> argument. Keyword arguments <code>kw...</code> are the same as supported by <a href="#HTTP.Servers.listen"><code>HTTP.listen</code></a>. Typical usage is like:</p><pre><code class="language-julia hljs">WebSockets.listen(host, port) do ws
    # iterate incoming websocket messages
    for msg in ws
        # send message back to client or do other logic here
        send(ws, msg)
    end
    # iteration ends when the websocket connection is closed by client or error
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/WebSockets.jl#L395-L413">source</a></section></article><h3 id="Middleware-/-Handlers"><a class="docs-heading-anchor" href="#Middleware-/-Handlers">Middleware / Handlers</a><a id="Middleware-/-Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Middleware-/-Handlers" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.Handler" href="#HTTP.Handlers.Handler"><code>HTTP.Handlers.Handler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Handler</code></pre><p>Abstract type for the handler interface that exists for documentation purposes. A <code>Handler</code> is any function of the form <code>f(req::HTTP.Request) -&gt; HTTP.Response</code>. There is no requirement to subtype <code>Handler</code> and users should not rely on or dispatch on <code>Handler</code>. A <code>Handler</code> function <code>f</code> can be passed to <a href="#HTTP.Handlers.serve"><code>HTTP.serve</code></a> wherein a server will pass each incoming request to <code>f</code> to be handled and a response to be returned. Handler functions are also the inputs to <a href="#HTTP.Handlers.Middleware"><code>Middleware</code></a> functions which are functions of the form <code>f(::Handler) -&gt; Handler</code>, i.e. they take a <code>Handler</code> function as input, and return a &quot;modified&quot; or enhanced <code>Handler</code> function.</p><p>For advanced cases, a <code>Handler</code> function can also be of the form <code>f(stream::HTTP.Stream) -&gt; Nothing</code>. In this case, the server would be run like <code>HTTP.serve(f, ...; stream=true)</code>. For this use-case, the handler function reads the request and writes the response to the stream directly. Note that any middleware used with a stream handler also needs to be of the form <code>f(stream_handler) -&gt; stream_handler</code>, i.e. it needs to accept a stream <code>Handler</code> function and return a stream <code>Handler</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L9-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.Middleware" href="#HTTP.Handlers.Middleware"><code>HTTP.Handlers.Middleware</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Middleware</code></pre><p>Abstract type for the middleware interface that exists for documentation purposes. A <code>Middleware</code> is any function of the form <code>f(::Handler) -&gt; Handler</code> (ref: <a href="#HTTP.Handlers.Handler"><code>Handler</code></a>). There is no requirement to subtype <code>Middleware</code> and users should not rely on or dispatch on the <code>Middleware</code> type. While <code>HTTP.serve(f, ...)</code> requires a <em>handler</em> function <code>f</code> to be passed, middleware can be &quot;stacked&quot; to create a chain of functions that are called in sequence, like <code>HTTP.serve(base_handler |&gt; cookie_middleware |&gt; auth_middlware, ...)</code>, where the <code>base_handler</code> <code>Handler</code> function is passed to <code>cookie_middleware</code>, which takes the handler and returns a &quot;modified&quot; handler (that parses and stores cookies). This &quot;modified&quot; handler is then an input to the <code>auth_middlware</code>, which further enhances/modifies the handler.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.streamhandler" href="#HTTP.Handlers.streamhandler"><code>HTTP.Handlers.streamhandler</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">streamhandler(request_handler) -&gt; stream handler</code></pre><p>Middleware that takes a request handler and returns a stream handler. Used by default in <code>HTTP.serve</code> to take the user-provided request handler and process the <code>Stream</code> from <code>HTTP.listen</code> and pass the parsed <code>Request</code> to the handler.</p><p>Is included by default in <code>HTTP.serve</code> as the base &quot;middleware&quot; when <code>stream=false</code> is passed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L44-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.Router" href="#HTTP.Handlers.Router"><code>HTTP.Handlers.Router</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HTTP.Router(_404, _405, middleware=nothing)</code></pre><p>Define a router object that maps incoming requests by path to registered routes and associated handlers. Paths can be registered using <a href="#HTTP.Handlers.register!"><code>HTTP.register!</code></a>. The router object itself is a &quot;request handler&quot; that can be called like:</p><pre><code class="nohighlight hljs">r = HTTP.Router()
resp = r(reqest)</code></pre><p>Which will inspect the <code>request</code>, find the matching, registered handler from the url, and pass the request on to be handled further.</p><p>See <a href="#HTTP.Handlers.register!"><code>HTTP.register!</code></a> for additional information on registering handlers based on routes.</p><p>If a request doesn&#39;t have a matching, registered handler, the <code>_404</code> handler is called which, by default, returns a <code>HTTP.Response(404)</code>. If a route matches the path, but not the method/verb (e.g. there&#39;s a registerd route for &quot;GET /api&quot;, but the request is &quot;POST /api&quot;), then the <code>_405</code> handler is called, which by default returns <code>HTTP.Response(405)</code> (method not allowed).</p><p>A <code>middleware</code> (<a href="#HTTP.Handlers.Middleware"><code>Middleware</code></a>) can optionally be provided as well, which will be called after the router has matched the request to a route, but before the route&#39;s handler is called. This provides a &quot;hook&quot; for matched routes that can be helpful for metric tracking, logging, etc. Note that the middleware is only called if the route is matched; for the 404 and 405 cases, users should wrap those handlers in the <code>middleware</code> manually.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L319-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.register!" href="#HTTP.Handlers.register!"><code>HTTP.Handlers.register!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.register!(r::Router, method, path, handler)
HTTP.register!(r::Router, path, handler)</code></pre><p>Register a handler function that should be called when an incoming request matches <code>path</code> and the optionally provided <code>method</code> (if not provided, any method is allowed). Can be used to dynamically register routes. When a registered route is matched, the original route string is stored in the <code>request.context[:route]</code> variable. The following path types are allowed for matching:</p><ul><li><code>/api/widgets</code>: exact match of static strings</li><li><code>/api/*/owner</code>: single <code>*</code> to wildcard match anything for a single segment</li><li><code>/api/widget/{id}</code>: Define a path variable <code>id</code> that matches any valued provided for this segment; path variables are available in the request context like <code>HTTP.getparams(req)[&quot;id&quot;]</code></li><li><code>/api/widget/{id:[0-9]+}</code>: Define a path variable <code>id</code> that does a regex match for integers for this segment</li><li><code>/api/**</code>: double wildcard matches any number of trailing segments in the request path; the double wildcard must be the last segment in the path</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L360-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.getparam" href="#HTTP.Handlers.getparam"><code>HTTP.Handlers.getparam</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.getparam(req, name, default=nothing) -&gt; String</code></pre><p>Retrieve a matched path parameter with name <code>name</code> from request context. If a path was registered with a router via <code>HTTP.register!</code> like &quot;/api/widget/{id}&quot;, then the path parameter can be retrieved like `id = HTTP.getparam(req, &quot;id&quot;).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L462-L468">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.getparams" href="#HTTP.Handlers.getparams"><code>HTTP.Handlers.getparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.getparams(req) -&gt; Dict{String, String}</code></pre><p>Retrieve any matched path parameters from the request context. If a path was registered with a router via <code>HTTP.register!</code> like &quot;/api/widget/{id}&quot;, then the path parameters are available in the request context and can be retrieved like <code>id = HTTP.getparams(req)[&quot;id&quot;]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L452-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.cookie_middleware" href="#HTTP.Handlers.cookie_middleware"><code>HTTP.Handlers.cookie_middleware</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.Handlers.cookie_middleware(handler) -&gt; handler</code></pre><p>Middleware that parses and stores any cookies in the incoming request in the request context. Cookies can then be retrieved by calling <a href="#HTTP.Handlers.getcookies"><code>HTTP.getcookies(req)</code></a> in subsequent middlewares/handlers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L475-L481">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Handlers.getcookies" href="#HTTP.Handlers.getcookies"><code>HTTP.Handlers.getcookies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.getcookies(req) -&gt; Vector{Cookie}</code></pre><p>Retrieve any parsed cookies from a request context. Cookies are expected to be stored in the <code>req.context[:cookies]</code> of the request context as implemented in the <a href="#HTTP.Handlers.cookie_middleware"><code>HTTP.Handlers.cookie_middleware</code></a> middleware.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Handlers.jl#L491-L498">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.@logfmt_str" href="#HTTP.@logfmt_str"><code>HTTP.@logfmt_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">logfmt&quot;...&quot;</code></pre><p>Parse an <a href="https://nginx.org/en/docs/http/ngx_http_log_module.html#log_format">NGINX-style log format string</a> and return a function mapping <code>(io::IO, http::HTTP.Stream) -&gt; body</code> suitable for passing to <a href="#HTTP.Servers.listen"><code>HTTP.listen</code></a> using the <code>access_log</code> keyword argument.</p><p>The following variables are currently supported:</p><ul><li><code>$http_name</code>: arbitrary request header (with <code>-</code> replaced with <code>_</code>, e.g. <code>http_user_agent</code>)</li><li><code>$sent_http_name</code>: arbitrary response header (with <code>-</code> replaced with <code>_</code>)</li><li><code>$request</code>: the request line, e.g. <code>GET /index.html HTTP/1.1</code></li><li><code>$request_method</code>: the request method</li><li><code>$request_uri</code>: the request URI</li><li><code>$remote_addr</code>: client address</li><li><code>$remote_port</code>: client port</li><li><code>$remote_user</code>: user name supplied with the Basic authentication</li><li><code>$server_protocol</code>: server protocol</li><li><code>$time_iso8601</code>: local time in ISO8601 format</li><li><code>$time_local</code>: local time in Common Log Format</li><li><code>$status</code>: response status code</li><li><code>$body_bytes_sent</code>: number of bytes in response body</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">logfmt&quot;[$time_iso8601] \&quot;$request\&quot; $status&quot; # [2021-05-01T12:34:40+0100] &quot;GET /index.html HTTP/1.1&quot; 200

logfmt&quot;$remote_addr \&quot;$http_user_agent\&quot;&quot; # 127.0.0.1 &quot;curl/7.47.0&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/access_log.jl#L1-L30">source</a></section></article><h2 id="Advanced-Topics"><a class="docs-heading-anchor" href="#Advanced-Topics">Advanced Topics</a><a id="Advanced-Topics-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-Topics" title="Permalink"></a></h2><h3 id="Messages-Interface"><a class="docs-heading-anchor" href="#Messages-Interface">Messages Interface</a><a id="Messages-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Messages-Interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.iserror" href="#HTTP.Messages.iserror"><code>HTTP.Messages.iserror</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">iserror(::Response)</code></pre><p>Does this <code>Response</code> have an error status?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.isredirect" href="#HTTP.Messages.isredirect"><code>HTTP.Messages.isredirect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isredirect(::Response)</code></pre><p>Does this <code>Response</code> have a redirect status?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L239-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.ischunked" href="#HTTP.Messages.ischunked"><code>HTTP.Messages.ischunked</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ischunked(::Message)</code></pre><p>Does the <code>Message</code> have a &quot;Transfer-Encoding: chunked&quot; header?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.issafe" href="#HTTP.Messages.issafe"><code>HTTP.Messages.issafe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">issafe(::Request)</code></pre><p>https://tools.ietf.org/html/rfc7231#section-4.2.1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.isidempotent" href="#HTTP.Messages.isidempotent"><code>HTTP.Messages.isidempotent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isidempotent(::Request)</code></pre><p>https://tools.ietf.org/html/rfc7231#section-4.2.2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.retryable" href="#HTTP.Messages.retryable"><code>HTTP.Messages.retryable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">retryable(::Request)</code></pre><p>Whether a <code>Request</code> is eligible to be retried.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L257-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.defaultheader!" href="#HTTP.Messages.defaultheader!"><code>HTTP.Messages.defaultheader!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">defaultheader!(::Message, key =&gt; value)</code></pre><p>Set header <code>value</code> in message for <code>key</code> if it is not already set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L383-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.readheaders" href="#HTTP.Messages.readheaders"><code>HTTP.Messages.readheaders</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">readheaders(::IO, ::Message)</code></pre><p>Read headers (and startline) from an <code>IO</code> stream into a <code>Message</code> struct. Throw <code>EOFError</code> if input is incomplete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L508-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.DefaultHeadersRequest.setuseragent!" href="#HTTP.DefaultHeadersRequest.setuseragent!"><code>HTTP.DefaultHeadersRequest.setuseragent!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setuseragent!(x::Union{String, Nothing})</code></pre><p>Set the default User-Agent string to be used in each HTTP request. Can be manually overridden by passing an explicit <code>User-Agent</code> header. Setting <code>nothing</code> will prevent the default <code>User-Agent</code> header from being passed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/DefaultHeadersRequest.jl#L53-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.readchunksize" href="#HTTP.Messages.readchunksize"><code>HTTP.Messages.readchunksize</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Read chunk-size from an <code>IO</code> stream. After the final zero size chunk, read trailers into a <code>Message</code> struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L535-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}" href="#HTTP.Messages.headerscomplete-Tuple{HTTP.Messages.Response}"><code>HTTP.Messages.headerscomplete</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">headerscomplete(::Message)</code></pre><p>Have the headers been read into this <code>Message</code>?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L282-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.writestartline" href="#HTTP.Messages.writestartline"><code>HTTP.Messages.writestartline</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writestartline(::IO, ::Message)</code></pre><p>e.g. <code>&quot;GET /path HTTP/1.1\r\n&quot;</code> or <code>&quot;HTTP/1.1 200 OK\r\n&quot;</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L458-L462">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Messages.writeheaders" href="#HTTP.Messages.writeheaders"><code>HTTP.Messages.writeheaders</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">writeheaders(::IO, ::Message)</code></pre><p>Write <code>Message</code> start line and a line for each &quot;name: value&quot; pair and a trailing blank line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L473-L478">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.write-Tuple{IO, HTTP.Messages.Message}" href="#Base.write-Tuple{IO, HTTP.Messages.Message}"><code>Base.write</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write(::IO, ::Message)</code></pre><p>Write start line, headers and body of HTTP Message.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Messages.jl#L489-L493">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Streams.closebody" href="#HTTP.Streams.closebody"><code>HTTP.Streams.closebody</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">closebody(::Stream)</code></pre><p>Write the final <code>0</code> chunk if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Streams.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Streams.isaborted" href="#HTTP.Streams.isaborted"><code>HTTP.Streams.isaborted</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isaborted(::Stream{&lt;:Response})</code></pre><p>Has the server signaled that it does not wish to receive the message body?</p><p>&quot;If [the response] indicates the server does not wish to receive the  message body and is closing the connection, the client SHOULD  immediately cease transmitting the body and close the connection.&quot; <a href="https://tools.ietf.org/html/rfc7230#section-6.5">RFC7230, 6.5</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Streams.jl#L319-L328">source</a></section></article><h3 id="Cookie-Persistence"><a class="docs-heading-anchor" href="#Cookie-Persistence">Cookie Persistence</a><a id="Cookie-Persistence-1"></a><a class="docs-heading-anchor-permalink" href="#Cookie-Persistence" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.CookieJar" href="#HTTP.Cookies.CookieJar"><code>HTTP.Cookies.CookieJar</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CookieJar()</code></pre><p>A thread-safe object for storing cookies returned in &quot;Set-Cookie&quot; response headers. Keyed by appropriate host from the original request made. Can be created manually and passed like <code>HTTP.get(url; cookiejar=mycookiejar)</code> to avoid using the default global <code>CookieJar</code>. The 2 main functions for interacting with a <code>CookieJar</code> are <a href="#HTTP.Cookies.getcookies!"><code>Cookies.getcookies!</code></a>, which returns a <code>Vector{Cookie}</code> for a given url (and will remove expired cookies from the jar), and <a href="#HTTP.Cookies.setcookies!"><code>Cookies.setcookies!</code></a>, which will store &quot;Set-Cookie&quot; response headers in the cookie jar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/cookiejar.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.getcookies!" href="#HTTP.Cookies.getcookies!"><code>HTTP.Cookies.getcookies!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Cookies.getcookies!(jar::CookieJar, url::URI)</code></pre><p>Retrieve valid <code>Cookie</code>s from the <code>CookieJar</code> according to the provided <code>url</code>. Cookies will be returned as a <code>Vector{Cookie}</code>. Only cookies for <code>http</code> or <code>https</code> scheme in the url will be returned. Cookies will be checked according to the canonical host of the url and any cookie max age or expiration will be accounted for. Expired cookies will not be returned and will be removed from the cookie jar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/cookiejar.jl#L53-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Cookies.setcookies!" href="#HTTP.Cookies.setcookies!"><code>HTTP.Cookies.setcookies!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Cookies.setcookies!(jar::CookieJar, url::URI, headers::Headers)</code></pre><p>Identify, &quot;Set-Cookie&quot; response headers from <code>headers</code>, parse the <code>Cookie</code>s, and store valid entries in the cookie <code>jar</code> according to the canonical host in <code>url</code>. Cookies can be retrieved from the <code>jar</code> via <a href="#HTTP.Cookies.getcookies!"><code>Cookies.getcookies!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/cookiejar.jl#L108-L114">source</a></section></article><h3 id="Client-side-Middleware-(Layers)"><a class="docs-heading-anchor" href="#Client-side-Middleware-(Layers)">Client-side Middleware (Layers)</a><a id="Client-side-Middleware-(Layers)-1"></a><a class="docs-heading-anchor-permalink" href="#Client-side-Middleware-(Layers)" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Layer" href="#HTTP.Layer"><code>HTTP.Layer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Layer</code></pre><p>Abstract type to represent a client-side middleware that exists for documentation purposes. A layer is any function of the form <code>f(::Handler) -&gt; Handler</code>, where <a href="#HTTP.Handlers.Handler"><code>Handler</code></a> is a function of the form <code>f(::Request) -&gt; Response</code>. Note that the <code>Handler</code> definition is from the server-side documentation, and is &quot;hard-coded&quot; on the client side. It may also be apparent that a <code>Layer</code> is the same as the <a href="#HTTP.Handlers.Middleware"><code>Middleware</code></a> interface from server-side, which is true, but we define <code>Layer</code> to clarify the client-side distinction and its unique usage. Custom layers can be deployed in one of two ways:</p><ul><li><a href="#HTTP.@client"><code>HTTP.@client</code></a>: Create a custom &quot;client&quot; with shorthand verb definitions, but which include custom layers; only these new verb methods will use the custom layers.</li><li><a href="#HTTP.pushlayer!"><code>HTTP.pushlayer!</code></a>/<a href="#HTTP.poplayer!"><code>HTTP.poplayer!</code></a>: Allows globally adding and removing layers from the default HTTP.jl layer stack; <em>all</em> http requests will then use the custom layers</li></ul><p><strong>Quick Examples</strong></p><pre><code class="language-julia hljs">module Auth

using HTTP

function auth_layer(handler)
    # returns a `Handler` function; check for a custom keyword arg `authcreds` that
    # a user would pass like `HTTP.get(...; authcreds=creds)`.
    # We also accept trailing keyword args `kw...` and pass them along later.
    return function(req; authcreds=nothing, kw...)
        # only apply the auth layer if the user passed `authcreds`
        if authcreds !== nothing
            # we add a custom header with stringified auth creds
            HTTP.setheader(req, &quot;X-Auth-Creds&quot; =&gt; string(authcreds))
        end
        # pass the request along to the next layer by calling `auth_layer` arg `handler`
        # also pass along the trailing keyword args `kw...`
        return handler(req; kw...)
    end
end

# Create a new client with the auth layer added
HTTP.@client [auth_layer]

end # module

# Can now use custom client like:
Auth.get(url; authcreds=creds) # performs GET request with auth_layer layer included

# Or can include layer globally in all HTTP.jl requests
HTTP.pushlayer!(Auth.auth_layer)

# Now can use normal HTTP.jl methods and auth_layer will be included
HTTP.get(url; authcreds=creds)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L279-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.@client" href="#HTTP.@client"><code>HTTP.@client</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">HTTP.@client requestlayers
HTTP.@client requestlayers streamlayers
HTTP.@client (first=requestlayers, last=requestlayers) (first=streamlayers, last=streamlayers)</code></pre><p>Convenience macro for creating a custom HTTP.jl client that will include custom layers when performing requests. It&#39;s common to want to define a custom <a href="#HTTP.Layer"><code>Layer</code></a> to enhance a specific category of requests, such as custom authentcation for a web API. Instead of affecting the global HTTP.jl request stack via <a href="#HTTP.pushlayer!"><code>HTTP.pushlayer!</code></a>, a custom wrapper client can be defined with convenient shorthand methods. See <a href="#HTTP.Layer"><code>Layer</code></a> for an example of defining a custom layer and creating a new client that includes the layer.</p><p>Custom layer arguments can be provided as a collection of request or stream-based layers; alternatively, a NamedTuple with keys <code>first</code> and <code>last</code> can be provided with values being a collection of layers. The NamedTuple form provides finer control over the order in which the layers will be included in the default http layer stack: <code>first</code> request layers are executed before all other layers, <code>last</code> request layers are executed right before all stream layers, and similarly for stream layers.</p><p>An empty collection can always be passed for request or stream layers when not needed.</p><p>One use case for custom clients is to control the value of standard <code>HTTP.request</code> keyword arguments. This can be achieved by passing a <code>(first=[defaultkeywordlayer],)</code> where <code>defaultkeywordlayer</code> is defined like:</p><pre><code class="language-julia hljs">defaultkeywordlayer(handler) = (req; kw...) -&gt; handler(req; retry=false, redirect=false, kw...)</code></pre><p>This client-side layer is basically a no-op as it doesn&#39;t modify the request at all, except that it hard-codes the value of the <code>retry</code> and <code>redirect</code> keyword arguments. When we pass this layer as <code>(first=[defaultkeywordlayer],)</code> this ensures this layer will be executed before all other layers, effectively over-writing the default and any user-provided keyword arguments for <code>retry</code> or <code>redirect</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L416-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.pushlayer!" href="#HTTP.pushlayer!"><code>HTTP.pushlayer!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.pushlayer!(layer; request=true)</code></pre><p>Push a layer onto the stack of layers that will be applied to all requests. The &quot;layer&quot; is expected to be a function that takes and returns a <code>Handler</code> function. See <a href="#HTTP.Layer"><code>Layer</code></a> for more details. If <code>request=false</code>, the layer is expected to take and return a &quot;stream&quot; handler function. The custom <code>layer</code> will be put on the top of the stack, so it will be the first layer executed. To add a layer at the bottom of the stack, see <a href="#HTTP.pushfirstlayer!"><code>HTTP.pushfirstlayer!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L333-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.pushfirstlayer!" href="#HTTP.pushfirstlayer!"><code>HTTP.pushfirstlayer!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.pushfirstlayer!(layer; request=true)</code></pre><p>Push a layer to the start of the stack of layers that will be applied to all requests. The &quot;layer&quot; is expected to be a function that takes and returns a <code>Handler</code> function. See <a href="#HTTP.Layer"><code>Layer</code></a> for more details. If <code>request=false</code>, the layer is expected to take and return a &quot;stream&quot; handler function. The custom <code>layer</code> will be put on the bottom of the stack, so it will be the last layer executed. To add a layer at the top of the stack, see <a href="#HTTP.pushlayer!"><code>HTTP.pushlayer!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L345-L354">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.poplayer!" href="#HTTP.poplayer!"><code>HTTP.poplayer!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.poplayer!(; request=true)</code></pre><p>Inverse of <a href="#HTTP.pushlayer!"><code>HTTP.pushlayer!</code></a>, removes the top layer of the global HTTP.jl layer stack. Can be used to &quot;cleanup&quot; after a custom layer has been added. If <code>request=false</code>, will remove the top &quot;stream&quot; layer as opposed to top &quot;request&quot; layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L357-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.popfirstlayer!" href="#HTTP.popfirstlayer!"><code>HTTP.popfirstlayer!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.popfirstlayer!(; request=true)</code></pre><p>Inverse of <a href="#HTTP.pushfirstlayer!"><code>HTTP.pushfirstlayer!</code></a>, removes the bottom layer of the global HTTP.jl layer stack. Can be used to &quot;cleanup&quot; after a custom layer has been added. If <code>request=false</code>, will remove the bottom &quot;stream&quot; layer as opposed to bottom &quot;request&quot; layer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L366-L372">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.MessageRequest.messagelayer" href="#HTTP.MessageRequest.messagelayer"><code>HTTP.MessageRequest.messagelayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">messagelayer(handler) -&gt; handler</code></pre><p>Construct a <a href="#HTTP.Messages.Request"><code>Request</code></a> object from method, url, headers, and body. Hard-coded as the first layer in the request pipeline.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/MessageRequest.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.RedirectRequest.redirectlayer" href="#HTTP.RedirectRequest.redirectlayer"><code>HTTP.RedirectRequest.redirectlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">redirectlayer(handler) -&gt; handler</code></pre><p>Redirects the request in the case of 3xx response status.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/RedirectRequest.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.DefaultHeadersRequest.defaultheaderslayer" href="#HTTP.DefaultHeadersRequest.defaultheaderslayer"><code>HTTP.DefaultHeadersRequest.defaultheaderslayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">defaultheaderslayer(handler) -&gt; handler</code></pre><p>Sets default expected headers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/DefaultHeadersRequest.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.BasicAuthRequest.basicauthlayer" href="#HTTP.BasicAuthRequest.basicauthlayer"><code>HTTP.BasicAuthRequest.basicauthlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">basicauthlayer(handler) -&gt; handler</code></pre><p>Add <code>Authorization: Basic</code> header using credentials from url userinfo.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/BasicAuthRequest.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.CookieRequest.cookielayer" href="#HTTP.CookieRequest.cookielayer"><code>HTTP.CookieRequest.cookielayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cookielayer(handler) -&gt; handler</code></pre><p>Check for host-appropriate cookies to include in the outgoing request from the <code>cookiejar</code> keyword argument (by default, a global cookiejar is used). Store &quot;Set-Cookie&quot; cookies from the response headers.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/CookieRequest.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.CanonicalizeRequest.canonicalizelayer" href="#HTTP.CanonicalizeRequest.canonicalizelayer"><code>HTTP.CanonicalizeRequest.canonicalizelayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">canonicalizelayer(handler) -&gt; handler</code></pre><p>Rewrite request and response headers in Canonical-Camel-Dash-Format.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/CanonicalizeRequest.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.TimeoutRequest.timeoutlayer" href="#HTTP.TimeoutRequest.timeoutlayer"><code>HTTP.TimeoutRequest.timeoutlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timeoutlayer(handler) -&gt; handler</code></pre><p>Close the <code>HTTP.Stream</code> if no data has been received for <code>readtimeout</code> seconds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/TimeoutRequest.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.ExceptionRequest.exceptionlayer" href="#HTTP.ExceptionRequest.exceptionlayer"><code>HTTP.ExceptionRequest.exceptionlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">exceptionlayer(handler) -&gt; handler</code></pre><p>Throw a <code>StatusError</code> if the request returns an error response status.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/ExceptionRequest.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.RetryRequest.retrylayer" href="#HTTP.RetryRequest.retrylayer"><code>HTTP.RetryRequest.retrylayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">retrylayer(handler) -&gt; handler</code></pre><p>Retry the request if it throws a recoverable exception.</p><p><code>Base.retry</code> and <code>Base.ExponentialBackOff</code> implement a randomised exponentially increasing delay is introduced between attempts to avoid exacerbating network congestion.</p><p>Methods of <code>isrecoverable(e)</code> define which exception types lead to a retry. e.g. <code>Sockets.DNSError</code>, <code>Base.EOFError</code> and <code>HTTP.StatusError</code> (if status is <code>5xx</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/RetryRequest.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.ConnectionRequest.connectionlayer" href="#HTTP.ConnectionRequest.connectionlayer"><code>HTTP.ConnectionRequest.connectionlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">connectionlayer(handler) -&gt; handler</code></pre><p>Retrieve an <code>IO</code> connection from the ConnectionPool.</p><p>Close the connection if the request throws an exception. Otherwise leave it open so that it can be reused.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/ConnectionRequest.jl#L47-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.DebugRequest.debuglayer" href="#HTTP.DebugRequest.debuglayer"><code>HTTP.DebugRequest.debuglayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">debuglayer(handler) -&gt; handler</code></pre><p>If <code>verbose</code> keyword arg is &gt; 0, or the HTTP.jl global <code>DEBUG_LEVEL[]</code> is &gt; 0, then enabled debug logging with verbosity <code>verbose</code> for the lifetime of the request.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/DebugRequest.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.StreamRequest.streamlayer" href="#HTTP.StreamRequest.streamlayer"><code>HTTP.StreamRequest.streamlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">streamlayer(stream) -&gt; HTTP.Response</code></pre><p>Create a <a href="#HTTP.Streams.Stream"><code>Stream</code></a> to send a <code>Request</code> and <code>body</code> to an <code>IO</code> stream and read the response.</p><p>Send the <code>Request</code> body in a background task and begins reading the response immediately so that the transmission can be aborted if the <code>Response</code> status indicates that the server does not wish to receive the message body. <a href="https://tools.ietf.org/html/rfc7230#section-6.5">RFC7230 6.5</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/StreamRequest.jl#L9-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.ContentTypeDetection.contenttypedetectionlayer" href="#HTTP.ContentTypeDetection.contenttypedetectionlayer"><code>HTTP.ContentTypeDetection.contenttypedetectionlayer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">contenttypedetectionlayer(handler) -&gt; handler</code></pre><p>Try and detect the content type of the request body and add the &quot;Content-Type&quot; header.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/clientlayers/ContentTypeRequest.jl#L8-L12">source</a></section></article><h3 id="Raw-Request-Connection"><a class="docs-heading-anchor" href="#Raw-Request-Connection">Raw Request Connection</a><a id="Raw-Request-Connection-1"></a><a class="docs-heading-anchor-permalink" href="#Raw-Request-Connection" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.openraw" href="#HTTP.openraw"><code>HTTP.openraw</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">HTTP.openraw(method, url, [, headers])::Tuple{Connection, Response}</code></pre><p>Open a raw socket that is unmanaged by HTTP.jl. Useful for doing HTTP upgrades to other protocols.  Any bytes of the body read from the socket when reading headers, is returned as excess bytes in the last tuple argument.</p><p>Example of a WebSocket upgrade:</p><pre><code class="language-julia hljs">headers = Dict(
    &quot;Upgrade&quot; =&gt; &quot;websocket&quot;,
    &quot;Connection&quot; =&gt; &quot;Upgrade&quot;,
    &quot;Sec-WebSocket-Key&quot; =&gt; &quot;dGhlIHNhbXBsZSBub25jZQ==&quot;,
    &quot;Sec-WebSocket-Version&quot; =&gt; &quot;13&quot;)

socket, response, excess = HTTP.openraw(&quot;GET&quot;, &quot;ws://echo.websocket.org&quot;, headers)

# Write a WebSocket frame
frame = UInt8[0x81, 0x85, 0x37, 0xfa, 0x21, 0x3d, 0x7f, 0x9f, 0x4d, 0x51, 0x58]
write(socket, frame)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/HTTP.jl#L532-L553">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.ConnectionPool.Connection" href="#HTTP.ConnectionPool.Connection"><code>HTTP.ConnectionPool.Connection</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Connection</code></pre><p>A <code>TCPSocket</code> or <code>SSLContext</code> connection to a HTTP <code>host</code> and <code>port</code>.</p><p>Fields:</p><ul><li><code>host::String</code></li><li><code>port::String</code>, exactly as specified in the URI (i.e. may be empty).</li><li><code>idle_timeout</code>, No. of seconds to maintain connection after last request/response.</li><li><code>require_ssl_verification</code>, whether ssl verification is required for an ssl connection</li><li><code>peerip</code>, remote IP adress (used for debug/log messages).</li><li><code>peerport</code>, remote TCP port number (used for debug/log messages).</li><li><code>localport</code>, local TCP port number (used for debug messages).</li><li><code>io::T</code>, the <code>TCPSocket</code> or `SSLContext.</li><li><code>clientconnection::Bool</code>, whether the Connection was created from client code (as opposed to server code)</li><li><code>buffer::IOBuffer</code>, left over bytes read from the connection after  the end of a response header (or chunksize). These bytes are usually  part of the response body.</li><li><code>timestamp</code>, time data was last received.</li><li><code>readable</code>, whether the Connection object is readable</li><li><code>writable</code>, whether the Connection object is writable</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/ConnectionPool.jl#L37-L58">source</a></section></article><h3 id="Parser-Interface"><a class="docs-heading-anchor" href="#Parser-Interface">Parser Interface</a><a id="Parser-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Parser-Interface" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.find_end_of_header" href="#HTTP.Parsers.find_end_of_header"><code>HTTP.Parsers.find_end_of_header</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_end_of_header(bytes) -&gt; length or 0</code></pre><p>Find length of header delimited by <code>\r\n\r\n</code> or <code>\n\n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Parsers.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.find_end_of_chunk_size" href="#HTTP.Parsers.find_end_of_chunk_size"><code>HTTP.Parsers.find_end_of_chunk_size</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Find <code>\n</code> after chunk size in <code>bytes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Parsers.jl#L273-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.find_end_of_trailer" href="#HTTP.Parsers.find_end_of_trailer"><code>HTTP.Parsers.find_end_of_trailer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_end_of_trailer(bytes) -&gt; length or 0</code></pre><p>Find length of trailer delimited by <code>\r\n\r\n</code> (or starting with <code>\r\n</code>). <a href="https://tools.ietf.org/html/rfc7230#section-4.1">RFC7230 4.1</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Parsers.jl#L294-L299">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.parse_status_line!" href="#HTTP.Parsers.parse_status_line!"><code>HTTP.Parsers.parse_status_line!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parse HTTP response-line <code>bytes</code> and set the <code>status</code> and <code>version</code> fields of <code>response</code>. Return a <code>SubString</code> containing the header-field lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Parsers.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.parse_request_line!" href="#HTTP.Parsers.parse_request_line!"><code>HTTP.Parsers.parse_request_line!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parse HTTP request-line <code>bytes</code> and set the <code>method</code>, <code>target</code> and <code>version</code> fields of <code>request</code>. Return a <code>SubString</code> containing the header-field lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Parsers.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.parse_header_field" href="#HTTP.Parsers.parse_header_field"><code>HTTP.Parsers.parse_header_field</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parse HTTP header-field. Return <code>Pair(field-name =&gt; field-value)</code> and a <code>SubString</code> containing the remaining header-field lines.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Parsers.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HTTP.Parsers.parse_chunk_size" href="#HTTP.Parsers.parse_chunk_size"><code>HTTP.Parsers.parse_chunk_size</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parse HTTP chunk-size. Return number of bytes of chunk-data.</p><pre><code class="nohighlight hljs">chunk-size = 1*HEXDIG</code></pre><p><a href="https://tools.ietf.org/html/rfc7230#section-4.1">RFC7230 4.1</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaWeb/HTTP.jl/blob/786b1ee79fe00a451d3734ee065b9953dfff768c/src/Parsers.jl#L310-L316">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../websockets/">« WebSockets</a><a class="docs-footer-nextpage" href="../examples/">Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Wednesday 24 August 2022 16:19">Wednesday 24 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
